[
    {
      "question_id": 1471,
      "db_id": "debit_card_specializing",
      "question": "What is the ratio of customers who pay in EUR against customers who pay in CZK?",
      "evidence": "ratio of customers who pay in EUR against customers who pay in CZK = count(Currency = 'EUR') / count(Currency = 'CZK').",
      "SQL": "SELECT CAST(SUM(IIF(Currency = 'EUR', 1, 0)) AS FLOAT) / SUM(IIF(Currency = 'CZK', 1, 0)) AS ratio FROM customers",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["customers"],
        "columns": ["customers.Currency"],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains customer currency information\">customers</table>",
        "<column purpose=\"filter and calculate: Used to count customers paying in EUR and CZK\">customers.Currency</column>",
        "<output_schema purpose=\"Ratio of EUR to CZK customers\">real</output_schema>",
        "<warning>The proposal is missing a COUNT or SUM aggregation function, which is necessary to calculate the ratio of customers.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for customer currency information--><table>customers</table>",
        "<!--Filter and count customers paying in EUR--><column>customers.Currency</column>",
        "<!--Ratio of EUR to CZK customers--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1472,
      "db_id": "debit_card_specializing",
      "question": "In 2012, who had the least consumption in LAM?",
      "evidence": "Year 2012 can be presented as Between 201201 And 201212; The first 4 strings of the Date values in the yearmonth table can represent year.",
      "SQL": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM' AND SUBSTR(T2.Date, 1, 4) = '2012' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) ASC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["customers", "yearmonth"],
        "columns": [
          "customers.CustomerID",
          "yearmonth.CustomerID",
          "yearmonth.Date",
          "customers.Segment",
          "yearmonth.Consumption"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for customer information and segment filtering\">customers</table>",
        "<table purpose=\"Required for consumption data and date filtering\">yearmonth</table>",
        "<column purpose=\"join: customers.CustomerID, output: 'who had the least consumption'\">customers.CustomerID</column>",
        "<column purpose=\"join: yearmonth.CustomerID\">yearmonth.CustomerID</column>",
        "<column purpose=\"filter: 'In 2012'\">yearmonth.Date</column>",
        "<column purpose=\"filter: 'in LAM'\">customers.Segment</column>",
        "<column purpose=\"calculate: 'least consumption'\">yearmonth.Consumption</column>",
        "<output_schema purpose=\"CustomerID of the customer with least consumption\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'consumption in LAM'--><table>yearmonth</table>",
        "<!--Required for 'LAM' segment--><table>customers</table>",
        "<!--filter: 'In 2012'--><column>yearmonth.Date</column>",
        "<!--calculate: 'least consumption'--><column>yearmonth.Consumption</column>",
        "<!--join: yearmonth.CustomerID--><column>customers.CustomerID</column>",
        "<!--filter: 'in LAM'--><column>customers.Segment</column>",
        "<!--identify: 'who had the least consumption'--><column>yearmonth.CustomerID</column>",
        "<!--who had the least consumption--><output_schema>integer</output_schema>",
        "<!--least consumption value--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1473,
      "db_id": "debit_card_specializing",
      "question": "What was the average monthly consumption of customers in SME for the year 2013?",
      "evidence": "Average Monthly consumption = AVG(Consumption) / 12; Year 2013 can be presented as Between 201301 And 201312; The first 4 strings of the Date values in the yearmonth table can represent year.",
      "SQL": "SELECT AVG(T2.Consumption) / 12 FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE SUBSTR(T2.Date, 1, 4) = '2013' AND T1.Segment = 'SME'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["customers", "yearmonth"],
        "columns": [
          "yearmonth.Consumption",
          "customers.CustomerID",
          "yearmonth.CustomerID",
          "yearmonth.Date",
          "customers.Segment"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for customer segment information\">customers</table>",
        "<table purpose=\"Required for monthly consumption data\">yearmonth</table>",
        "<column purpose=\"calculate: 'average monthly consumption'\">yearmonth.Consumption</column>",
        "<column purpose=\"join: customers.CustomerID\">customers.CustomerID</column>",
        "<column purpose=\"join: yearmonth.CustomerID\">yearmonth.CustomerID</column>",
        "<column purpose=\"filter: 'for the year 2013'\">yearmonth.Date</column>",
        "<column purpose=\"filter: 'customers in SME'\">customers.Segment</column>",
        "<output_schema purpose=\"average monthly consumption\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'monthly consumption'--><table>yearmonth</table>",
        "<!--Required for 'customers in SME'--><table>customers</table>",
        "<!--join: yearmonth.CustomerID--><column>customers.CustomerID</column>",
        "<!--join: customers.CustomerID--><column>yearmonth.CustomerID</column>",
        "<!--filter: 'customers in SME'--><column>customers.Segment</column>",
        "<!--filter: 'for the year 2013'--><column>yearmonth.Date</column>",
        "<!--calculate: 'average monthly consumption'--><column>yearmonth.Consumption</column>",
        "<!--average monthly consumption for SME customers in 2013--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1476,
      "db_id": "debit_card_specializing",
      "question": "What was the difference in gas consumption between CZK-paying customers and EUR-paying customers in 2012?",
      "evidence": "Year 2012 can be presented as Between 201201 And 201212; The first 4 strings of the Date values in the yearmonth table can represent year; Difference in Consumption = CZK customers consumption in 2012 - EUR customers consumption in 2012",
      "SQL": "SELECT SUM(IIF(T1.Currency = 'CZK', T2.Consumption, 0)) - SUM(IIF(T1.Currency = 'EUR', T2.Consumption, 0)) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE SUBSTR(T2.Date, 1, 4) = '2012'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["customers", "yearmonth"],
        "columns": [
          "customers.Currency",
          "yearmonth.Consumption",
          "customers.CustomerID",
          "yearmonth.CustomerID",
          "yearmonth.Date"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for customer currency information\">customers</table>",
        "<table purpose=\"Required for consumption data\">yearmonth</table>",
        "<column purpose=\"filter: distinguish between CZK and EUR paying customers\">customers.Currency</column>",
        "<column purpose=\"calculate: difference in gas consumption\">yearmonth.Consumption</column>",
        "<column purpose=\"join: customers.CustomerID\">customers.CustomerID</column>",
        "<column purpose=\"join: yearmonth.CustomerID\">yearmonth.CustomerID</column>",
        "<column purpose=\"filter: 'in 2012'\">yearmonth.Date</column>",
        "<output_schema purpose=\"difference in gas consumption\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for customer currency information--><table>customers</table>",
        "<!--Required for consumption data--><table>yearmonth</table>",
        "<!--Join customers and yearmonth tables--><column>customers.CustomerID</column>",
        "<!--Join customers and yearmonth tables--><column>yearmonth.CustomerID</column>",
        "<!--Filter for year 2012--><column>yearmonth.Date</column>",
        "<!--Calculate consumption--><column>yearmonth.Consumption</column>",
        "<!--Filter customers by currency--><column>customers.Currency</column>",
        "<!--Difference in gas consumption between CZK and EUR customers--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1479,
      "db_id": "debit_card_specializing",
      "question": "Which year recorded the most consumption of gas paid in CZK?",
      "evidence": "The first 4 strings of the Date values in the yearmonth table can represent year.",
      "SQL": "SELECT SUBSTR(T2.Date, 1, 4) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'CZK' GROUP BY SUBSTR(T2.Date, 1, 4) ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["customers", "yearmonth"],
        "columns": [
          "yearmonth.Date",
          "customers.CustomerID",
          "yearmonth.CustomerID",
          "customers.Currency",
          "yearmonth.Consumption"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for customer currency information\">customers</table>",
        "<table purpose=\"Required for consumption data and date information\">yearmonth</table>",
        "<column purpose=\"filter: extract year from date, 'Which year recorded'\">yearmonth.Date</column>",
        "<column purpose=\"join: customers.CustomerID\">customers.CustomerID</column>",
        "<column purpose=\"join: yearmonth.CustomerID\">yearmonth.CustomerID</column>",
        "<column purpose=\"filter: 'paid in CZK'\">customers.Currency</column>",
        "<column purpose=\"calculate: 'most consumption'\">yearmonth.Consumption</column>",
        "<output_schema purpose=\"year with most consumption\">text</output_schema>",
        "<warning>The output schema should be more specific, such as 'YYYY' format for the year</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'consumption of gas'--><table>yearmonth</table>",
        "<!--Required for currency information--><table>customers</table>",
        "<!--join: yearmonth.CustomerID--><column>customers.CustomerID</column>",
        "<!--join: customers.CustomerID--><column>yearmonth.CustomerID</column>",
        "<!--filter: 'paid in CZK'--><column>customers.Currency</column>",
        "<!--calculate: 'consumption of gas'--><column>yearmonth.Consumption</column>",
        "<!--extract year: 'Which year'--><column>yearmonth.Date</column>",
        "<!--year with most consumption--><output_schema>integer</output_schema>",
        "<!--total consumption for that year--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1480,
      "db_id": "debit_card_specializing",
      "question": "What was the gas consumption peak month for SME customers in 2013?",
      "evidence": "Year 2013 can be presented as Between 201301 And 201312; The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month.",
      "SQL": "SELECT SUBSTR(T2.Date, 5, 2) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE SUBSTR(T2.Date, 1, 4) = '2013' AND T1.Segment = 'SME' GROUP BY SUBSTR(T2.Date, 5, 2) ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["customers", "yearmonth"],
        "columns": [
          "yearmonth.Date",
          "customers.CustomerID",
          "yearmonth.CustomerID",
          "customers.Segment",
          "yearmonth.Consumption"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for filtering SME customers\">customers</table>",
        "<table purpose=\"Required for consumption data and date information\">yearmonth</table>",
        "<column purpose=\"filter: '2013', extract month for peak consumption\">yearmonth.Date</column>",
        "<column purpose=\"join: yearmonth.CustomerID\">customers.CustomerID</column>",
        "<column purpose=\"join: customers.CustomerID\">yearmonth.CustomerID</column>",
        "<column purpose=\"filter: 'SME customers'\">customers.Segment</column>",
        "<column purpose=\"calculate: 'gas consumption peak month'\">yearmonth.Consumption</column>",
        "<output_schema purpose=\"month of peak consumption\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'SME customers'--><table>customers</table>",
        "<!--Required for 'gas consumption' and 'month'--><table>yearmonth</table>",
        "<!--filter: 'SME customers'--><column>customers.Segment</column>",
        "<!--join: yearmonth.CustomerID--><column>customers.CustomerID</column>",
        "<!--join: customers.CustomerID--><column>yearmonth.CustomerID</column>",
        "<!--filter: 'in 2013'--><column>yearmonth.Date</column>",
        "<!--calculate: 'gas consumption'--><column>yearmonth.Consumption</column>",
        "<!--peak month for SME customers in 2013--><output_schema>text</output_schema>",
        "<!--total consumption for the peak month--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1481,
      "db_id": "debit_card_specializing",
      "question": "What is the difference in the annual average consumption of the customers with the least amount of consumption paid in CZK for 2013 between SME and LAM, LAM and KAM, and KAM and SME?",
      "evidence": "annual average consumption of customer with the lowest consumption in each segment = total consumption per year / the number of customer with lowest consumption in each segment; Difference in annual average = SME's annual average - LAM's annual average; Difference in annual average = LAM's annual average - KAM's annual average; Year 2013 can be presented as Between 201301 And 201312; The first 4 strings of the Date values in the yearmonth table can represent year.",
      "SQL": "SELECT CAST(SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) , CAST(SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'KAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) , CAST(SUM(IIF(T1.Segment = 'KAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'CZK' AND T2.Consumption = ( SELECT MIN(Consumption) FROM yearmonth ) AND T2.Date BETWEEN 201301 AND 201312",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["customers", "yearmonth"],
        "columns": [
          "yearmonth.Consumption",
          "customers.Segment",
          "customers.CustomerID",
          "yearmonth.CustomerID",
          "yearmonth.Date",
          "customers.Currency"
        ],
        "output_schema": ["real", "real", "real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for customer segment and currency information\">customers</table>",
        "<table purpose=\"Required for consumption data and date information\">yearmonth</table>",
        "<column purpose=\"calculate: 'annual average consumption', filter: 'least amount of consumption'\">yearmonth.Consumption</column>",
        "<column purpose=\"filter: 'SME and LAM, LAM and KAM, and KAM and SME'\">customers.Segment</column>",
        "<column purpose=\"join: customers.CustomerID\">customers.CustomerID</column>",
        "<column purpose=\"join: yearmonth.CustomerID\">yearmonth.CustomerID</column>",
        "<column purpose=\"filter: 'Year 2013'\">yearmonth.Date</column>",
        "<column purpose=\"filter: 'paid in CZK'\">customers.Currency</column>",
        "<output_schema purpose=\"difference in annual average consumption between SME and LAM\">real</output_schema>",
        "<output_schema purpose=\"difference in annual average consumption between LAM and KAM\">real</output_schema>",
        "<output_schema purpose=\"difference in annual average consumption between KAM and SME\">real</output_schema>",
        "<warning>The query might not correctly identify the customers with the least amount of consumption for each segment. It's currently selecting the overall minimum consumption, which may not be the correct approach.</warning>",
        "<warning>The calculation of annual average consumption might need to be adjusted to account for the number of months each customer has data for in 2013.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for customer segment and currency--><table>customers</table>",
        "<!--Required for consumption data--><table>yearmonth</table>",
        "<!--Join customers and yearmonth--><column>customers.CustomerID</column>",
        "<!--Join customers and yearmonth--><column>yearmonth.CustomerID</column>",
        "<!--Filter for CZK currency--><column>customers.Currency</column>",
        "<!--Filter for customer segments--><column>customers.Segment</column>",
        "<!--Filter for year 2013--><column>yearmonth.Date</column>",
        "<!--Calculate consumption--><column>yearmonth.Consumption</column>",
        "<!--Difference in annual average consumption between SME and LAM--><output_schema>real</output_schema>",
        "<!--Difference in annual average consumption between LAM and KAM--><output_schema>real</output_schema>",
        "<!--Difference in annual average consumption between KAM and SME--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1482,
      "db_id": "debit_card_specializing",
      "question": "Which of the three segments\u2014SME, LAM and KAM\u2014has the biggest and lowest percentage increases in consumption paid in EUR between 2012 and 2013?",
      "evidence": "Increase or Decrease = consumption for 2013 - consumption for 2012; Percentage of Increase = (Increase or Decrease / consumption for 2013) * 100%; The first 4 strings of the Date values in the yearmonth table can represent year",
      "SQL": "SELECT CAST((SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0))) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0)), CAST(SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) , CAST(SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["customers", "yearmonth"],
        "columns": [
          "customers.Segment",
          "yearmonth.Date",
          "yearmonth.Consumption",
          "customers.CustomerID",
          "yearmonth.CustomerID"
        ],
        "output_schema": ["real", "real", "real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for customer segment information\">customers</table>",
        "<table purpose=\"Required for consumption data over time\">yearmonth</table>",
        "<column purpose=\"filter: 'SME, LAM and KAM'\">customers.Segment</column>",
        "<column purpose=\"filter: 'between 2012 and 2013'\">yearmonth.Date</column>",
        "<column purpose=\"calculate: 'consumption' and 'percentage increases'\">yearmonth.Consumption</column>",
        "<column purpose=\"join: customers.CustomerID\">customers.CustomerID</column>",
        "<column purpose=\"join: yearmonth.CustomerID\">yearmonth.CustomerID</column>",
        "<output_schema purpose=\"percentage increase for SME segment\">real</output_schema>",
        "<output_schema purpose=\"percentage increase for LAM segment\">real</output_schema>",
        "<output_schema purpose=\"percentage increase for KAM segment\">real</output_schema>",
        "<error>customers.Currency is missing. It's needed to filter for consumption paid in EUR.</error>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for customer segments and currency--><table>customers</table>",
        "<!--Required for consumption data--><table>yearmonth</table>",
        "<!--Filter for customer segments--><column>customers.Segment</column>",
        "<!--Filter for EUR currency--><column>customers.Currency</column>",
        "<!--Join customers and yearmonth--><column>customers.CustomerID</column>",
        "<!--Join customers and yearmonth--><column>yearmonth.CustomerID</column>",
        "<!--Calculate consumption and filter by year--><column>yearmonth.Date</column>",
        "<!--Calculate consumption--><column>yearmonth.Consumption</column>",
        "<!--Segment with biggest percentage increase--><output_schema>text</output_schema>",
        "<!--Biggest percentage increase value--><output_schema>real</output_schema>",
        "<!--Segment with lowest percentage increase--><output_schema>text</output_schema>",
        "<!--Lowest percentage increase value--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1483,
      "db_id": "debit_card_specializing",
      "question": "How much did customer 6 consume in total between August and November 2013?",
      "evidence": "Between August And November 2013 refers to Between 201308 And 201311; The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month.",
      "SQL": "SELECT SUM(Consumption) FROM yearmonth WHERE CustomerID = 6 AND Date BETWEEN '201308' AND '201311'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["yearmonth"],
        "columns": [
          "yearmonth.Consumption",
          "yearmonth.CustomerID",
          "yearmonth.Date"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for customer consumption data\">yearmonth</table>",
        "<column purpose=\"calculate: 'consume in total'\">yearmonth.Consumption</column>",
        "<column purpose=\"filter: 'customer 6'\">yearmonth.CustomerID</column>",
        "<column purpose=\"filter: 'between August and November 2013'\">yearmonth.Date</column>",
        "<output_schema purpose=\"total consumption for customer 6 between August and November 2013\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for customer consumption data--><table>yearmonth</table>",
        "<!--Filter: 'customer 6'--><column>yearmonth.CustomerID</column>",
        "<!--Filter: 'between August and November 2013'--><column>yearmonth.Date</column>",
        "<!--Calculate: 'consume in total'--><column>yearmonth.Consumption</column>",
        "<!--Total consumption for customer 6 between August and November 2013--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1484,
      "db_id": "debit_card_specializing",
      "question": "How many more \"discount\" gas stations does the Czech Republic have compared to Slovakia?",
      "evidence": "Czech Republic can be represented as the Country value in gasstations table is 'CZE'; Slovakia can be represented as the Country value in the gasstations table is 'SVK';  Computation of more \"discount\" gas stations= Total no. of discount gas stations in Czech Republic - Total no. of discount gas stations in Slovakia",
      "SQL": "SELECT SUM(IIF(Country = 'CZE', 1, 0)) - SUM(IIF(Country = 'SVK', 1, 0)) FROM gasstations WHERE Segment = 'Discount'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["gasstations"],
        "columns": ["gasstations.Country", "gasstations.Segment"],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for counting gas stations by country and segment\">gasstations</table>",
        "<column purpose=\"filter: 'Czech Republic' and 'Slovakia'\">gasstations.Country</column>",
        "<column purpose=\"filter: 'discount' gas stations\">gasstations.Segment</column>",
        "<output_schema purpose=\"difference in count of discount gas stations\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for gas station information--><table>gasstations</table>",
        "<!--Filter for Czech Republic--><column>gasstations.Country</column>",
        "<!--Filter for Slovakia--><column>gasstations.Country</column>",
        "<!--Filter for \"discount\" gas stations--><column>gasstations.Segment</column>",
        "<!--Difference in number of discount gas stations--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1486,
      "db_id": "debit_card_specializing",
      "question": "Is it true that more SMEs pay in Czech koruna than in euros? If so, how many more?",
      "evidence": "Amount of more SMEs = Total of SMEs pay using Currency CZK - Total of SMEs pay using Currency EUR",
      "SQL": "SELECT SUM(Currency = 'CZK') - SUM(Currency = 'EUR') FROM customers WHERE Segment = 'SME'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["customers"],
        "columns": ["customers.Currency", "customers.Segment"],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for customer information including currency and segment\">customers</table>",
        "<column purpose=\"filter: 'SMEs', calculate: difference between CZK and EUR\">customers.Segment</column>",
        "<column purpose=\"calculate: difference between CZK and EUR for SMEs\">customers.Currency</column>",
        "<output_schema purpose=\"difference in count of SMEs paying in CZK vs EUR\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for SME customer information--><table>customers</table>",
        "<!--Filter for SME segment--><column>customers.Segment</column>",
        "<!--Count customers by currency--><column>customers.Currency</column>",
        "<!--Count of SMEs by currency--><output_schema>text</output_schema>",
        "<!--Count of SMEs by currency--><output_schema>integer</output_schema>",
        "<!--Difference in counts (if applicable)--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1490,
      "db_id": "debit_card_specializing",
      "question": "How many percent of LAM customer consumed more than 46.73?",
      "evidence": "Percentage of LAM customer consumed more than 46.73 = (Total no. of LAM customers who consumed more than 46.73 / Total no. of LAM customers) * 100.",
      "SQL": "SELECT CAST(SUM(IIF(T2.Consumption > 46.73, 1, 0)) AS FLOAT) * 100 / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["customers", "yearmonth"],
        "columns": [
          "yearmonth.Consumption",
          "customers.CustomerID",
          "yearmonth.CustomerID",
          "customers.Segment"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for filtering LAM customers and joining with yearmonth\">customers</table>",
        "<table purpose=\"Required for consumption data\">yearmonth</table>",
        "<column purpose=\"calculate: 'consumed more than 46.73'\">yearmonth.Consumption</column>",
        "<column purpose=\"join: yearmonth.CustomerID\">customers.CustomerID</column>",
        "<column purpose=\"join: customers.CustomerID\">yearmonth.CustomerID</column>",
        "<column purpose=\"filter: 'LAM customer'\">customers.Segment</column>",
        "<output_schema purpose=\"percentage of LAM customers who consumed more than 46.73\">real</output_schema>",
        "<warning>The proposal doesn't specify which time period to consider for consumption. The question doesn't mention a specific time frame, so you might want to consider all available data or add a time filter if needed.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'LAM customer' information--><table>customers</table>",
        "<!--Required for consumption data--><table>yearmonth</table>",
        "<!--Filter: 'LAM customer'--><column>customers.Segment</column>",
        "<!--Join: customers.CustomerID--><column>customers.CustomerID</column>",
        "<!--Join: yearmonth.CustomerID--><column>yearmonth.CustomerID</column>",
        "<!--Calculate: 'consumed more than 46.73'--><column>yearmonth.Consumption</column>",
        "<!--Percentage of LAM customers consuming more than 46.73--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1493,
      "db_id": "debit_card_specializing",
      "question": "In February 2012, what percentage of customers consumed more than 528.3?",
      "evidence": "February 2012 refers to '201202' in yearmonth.date; The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month.",
      "SQL": "SELECT CAST(SUM(IIF(Consumption > 528.3, 1, 0)) AS FLOAT) * 100 / COUNT(CustomerID) FROM yearmonth WHERE Date = '201202'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["yearmonth"],
        "columns": [
          "yearmonth.Consumption",
          "yearmonth.CustomerID",
          "yearmonth.Date"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for monthly consumption data\">yearmonth</table>",
        "<column purpose=\"calculate: 'percentage of customers consumed more than 528.3'\">yearmonth.Consumption</column>",
        "<column purpose=\"count: total number of customers\">yearmonth.CustomerID</column>",
        "<column purpose=\"filter: 'In February 2012'\">yearmonth.Date</column>",
        "<output_schema purpose=\"percentage of customers\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for customer consumption data--><table>yearmonth</table>",
        "<!--Filter for February 2012--><column>yearmonth.Date</column>",
        "<!--Calculate percentage of customers--><column>yearmonth.CustomerID</column>",
        "<!--Compare consumption to 528.3--><column>yearmonth.Consumption</column>",
        "<!--Percentage of customers--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1498,
      "db_id": "debit_card_specializing",
      "question": "What is the highest monthly consumption in the year 2012?",
      "evidence": "The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month.",
      "SQL": "SELECT SUM(Consumption) FROM yearmonth WHERE SUBSTR(Date, 1, 4) = '2012' GROUP BY SUBSTR(Date, 5, 2) ORDER BY SUM(Consumption) DESC LIMIT 1",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["yearmonth"],
        "columns": ["yearmonth.Consumption", "yearmonth.Date"],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'monthly consumption in the year 2012'\">yearmonth</table>",
        "<column purpose=\"calculate: 'highest monthly consumption'\">yearmonth.Consumption</column>",
        "<column purpose=\"filter: 'in the year 2012', group: 'monthly'\">yearmonth.Date</column>",
        "<output_schema purpose=\"highest monthly consumption\">real</output_schema>",
        "<warning>The proposal is missing an aggregation function (e.g., SUM, MAX) to calculate the total monthly consumption.</warning>",
        "<warning>The proposal is missing a GROUP BY clause to aggregate consumption by month.</warning>",
        "<warning>The proposal is missing an ORDER BY clause to find the highest monthly consumption.</warning>",
        "<warning>The proposal is missing a LIMIT clause to select only the highest value.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'monthly consumption'--><table>yearmonth</table>",
        "<!--filter: 'in the year 2012'--><column>yearmonth.Date</column>",
        "<!--calculate: 'highest monthly consumption'--><column>yearmonth.Consumption</column>",
        "<!--highest monthly consumption in 2012--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1500,
      "db_id": "debit_card_specializing",
      "question": "Please list the product description of the products consumed in September, 2013.",
      "evidence": "September 2013 refers to 201309; The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month.",
      "SQL": "SELECT T3.Description FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN products AS T3 ON T1.ProductID = T3.ProductID WHERE T2.Date = '201309'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["transactions_1k", "yearmonth", "products"],
        "columns": [
          "products.Description",
          "transactions_1k.CustomerID",
          "yearmonth.CustomerID",
          "yearmonth.Date",
          "transactions_1k.ProductID",
          "products.ProductID"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for transaction data\">transactions_1k</table>",
        "<table purpose=\"Required for monthly consumption data\">yearmonth</table>",
        "<table purpose=\"Required for product descriptions\">products</table>",
        "<column purpose=\"output: 'product description of the products consumed'\">products.Description</column>",
        "<column purpose=\"join: yearmonth.CustomerID\">transactions_1k.CustomerID</column>",
        "<column purpose=\"join: transactions_1k.CustomerID\">yearmonth.CustomerID</column>",
        "<column purpose=\"filter: 'in September, 2013'\">yearmonth.Date</column>",
        "<column purpose=\"join: products.ProductID\">transactions_1k.ProductID</column>",
        "<column purpose=\"join: transactions_1k.ProductID\">products.ProductID</column>",
        "<output_schema purpose=\"product description\">text</output_schema>",
        "<error>The proposed solution does not account for the specific date format in the yearmonth table. The query should use SUBSTR() or similar function to extract year and month from the Date column.</error>",
        "<warning>The solution assumes that all transactions in the transactions_1k table are relevant for September 2013. If this table contains data for other months, an additional join condition or filter on the transaction date may be necessary.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'products consumed'--><table>yearmonth</table>",
        "<!--Required for 'product description'--><table>products</table>",
        "<!--Required for linking yearmonth to products--><table>transactions_1k</table>",
        "<!--Filter: 'September, 2013' (201309)--><column>yearmonth.Date</column>",
        "<!--Join: yearmonth.CustomerID--><column>transactions_1k.CustomerID</column>",
        "<!--Join: transactions_1k.ProductID--><column>products.ProductID</column>",
        "<!--Output: 'product description'--><column>products.Description</column>",
        "<!--Product descriptions consumed in September 2013--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1501,
      "db_id": "debit_card_specializing",
      "question": "Please list the countries of the gas stations with transactions taken place in June, 2013.",
      "evidence": "June 2013 refers to '201306'; The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month;",
      "SQL": "SELECT DISTINCT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN yearmonth AS T3 ON T1.CustomerID = T3.CustomerID WHERE T3.Date = '201306'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["transactions_1k", "gasstations", "yearmonth"],
        "columns": [
          "gasstations.Country",
          "transactions_1k.GasStationID",
          "gasstations.GasStationID",
          "transactions_1k.CustomerID",
          "yearmonth.CustomerID",
          "yearmonth.Date"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for transaction data\">transactions_1k</table>",
        "<table purpose=\"Required for gas station country information\">gasstations</table>",
        "<table purpose=\"Required for filtering transactions by date\">yearmonth</table>",
        "<column purpose=\"output: 'list the countries of the gas stations'\">gasstations.Country</column>",
        "<column purpose=\"join: gasstations.GasStationID\">transactions_1k.GasStationID</column>",
        "<column purpose=\"join: transactions_1k.GasStationID\">gasstations.GasStationID</column>",
        "<column purpose=\"join: yearmonth.CustomerID\">transactions_1k.CustomerID</column>",
        "<column purpose=\"join: transactions_1k.CustomerID\">yearmonth.CustomerID</column>",
        "<column purpose=\"filter: 'in June, 2013'\">yearmonth.Date</column>",
        "<output_schema purpose=\"countries of the gas stations\">text</output_schema>",
        "<warning>The query uses DISTINCT, which is not explicitly mentioned in the proposal. Consider adding it to ensure unique country listings.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'countries of the gas stations'--><table>gasstations</table>",
        "<!--Required for 'transactions taken place'--><table>transactions_1k</table>",
        "<!--Required for filtering transactions in June 2013--><table>yearmonth</table>",
        "<!--join: transactions_1k.GasStationID--><column>gasstations.GasStationID</column>",
        "<!--join: gasstations.GasStationID--><column>transactions_1k.GasStationID</column>",
        "<!--join: transactions_1k.CustomerID--><column>yearmonth.CustomerID</column>",
        "<!--join: yearmonth.CustomerID--><column>transactions_1k.CustomerID</column>",
        "<!--filter: 'in June, 2013'--><column>yearmonth.Date</column>",
        "<!--'countries of the gas stations'--><column>gasstations.Country</column>",
        "<!--list the countries--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1505,
      "db_id": "debit_card_specializing",
      "question": "Among the customers who paid in euro, how many of them have a monthly consumption of over 1000?",
      "evidence": "Pays in euro = Currency = 'EUR'.",
      "SQL": "SELECT COUNT(*) FROM yearmonth AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Currency = 'EUR' AND T1.Consumption > 1000.00",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["yearmonth", "customers"],
        "columns": [
          "yearmonth.CustomerID",
          "customers.CustomerID",
          "customers.Currency",
          "yearmonth.Consumption"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"contains monthly consumption data\">yearmonth</table>",
        "<table purpose=\"contains customer currency information\">customers</table>",
        "<column purpose=\"join: yearmonth with customers\">yearmonth.CustomerID</column>",
        "<column purpose=\"join: customers with yearmonth\">customers.CustomerID</column>",
        "<column purpose=\"filter: 'customers who paid in euro'\">customers.Currency</column>",
        "<column purpose=\"filter: 'monthly consumption of over 1000'\">yearmonth.Consumption</column>",
        "<output_schema purpose=\"count of customers meeting the criteria\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'customers who paid in euro'--><table>customers</table>",
        "<!--Required for 'monthly consumption'--><table>yearmonth</table>",
        "<!--filter: 'paid in euro'--><column>customers.Currency</column>",
        "<!--join: customers.CustomerID--><column>customers.CustomerID</column>",
        "<!--join: yearmonth.CustomerID--><column>yearmonth.CustomerID</column>",
        "<!--filter: 'monthly consumption of over 1000'--><column>yearmonth.Consumption</column>",
        "<!--count of customers meeting criteria--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1506,
      "db_id": "debit_card_specializing",
      "question": "Please list the product descriptions of the transactions taken place in the gas stations in the Czech Republic.",
      "evidence": "Czech Republic can be represented as the Country value in the gasstations table is 'CZE'; ",
      "SQL": "SELECT DISTINCT T3.Description FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN products AS T3 ON T1.ProductID = T3.ProductID WHERE T2.Country = 'CZE'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["transactions_1k", "gasstations", "products"],
        "columns": [
          "products.Description",
          "transactions_1k.GasStationID",
          "gasstations.GasStationID",
          "gasstations.Country",
          "transactions_1k.ProductID",
          "products.ProductID"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for transaction data\">transactions_1k</table>",
        "<table purpose=\"Required for gas station country information\">gasstations</table>",
        "<table purpose=\"Required for product descriptions\">products</table>",
        "<column purpose=\"output: 'product descriptions'\">products.Description</column>",
        "<column purpose=\"join: gasstations.GasStationID\">transactions_1k.GasStationID</column>",
        "<column purpose=\"join: transactions_1k.GasStationID\">gasstations.GasStationID</column>",
        "<column purpose=\"filter: 'Czech Republic'\">gasstations.Country</column>",
        "<column purpose=\"join: products.ProductID\">transactions_1k.ProductID</column>",
        "<column purpose=\"join: transactions_1k.ProductID\">products.ProductID</column>",
        "<output_schema purpose=\"product descriptions\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'transactions taken place'--><table>transactions_1k</table>",
        "<!--Required for 'gas stations in the Czech Republic'--><table>gasstations</table>",
        "<!--Required for 'product descriptions'--><table>products</table>",
        "<!--join: transactions_1k.GasStationID--><column>gasstations.GasStationID</column>",
        "<!--join: gasstations.GasStationID--><column>transactions_1k.GasStationID</column>",
        "<!--filter: 'Czech Republic'--><column>gasstations.Country</column>",
        "<!--join: transactions_1k.ProductID--><column>products.ProductID</column>",
        "<!--join: products.ProductID--><column>transactions_1k.ProductID</column>",
        "<!--output: 'product descriptions'--><column>products.Description</column>",
        "<!--product descriptions of transactions in Czech Republic--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1507,
      "db_id": "debit_card_specializing",
      "question": "Please list the disparate time of the transactions taken place in the gas stations from chain no. 11.",
      "evidence": "",
      "SQL": "SELECT DISTINCT T1.Time FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.ChainID = 11",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["transactions_1k", "gasstations"],
        "columns": [
          "transactions_1k.Time",
          "transactions_1k.GasStationID",
          "gasstations.GasStationID",
          "gasstations.ChainID"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains transaction data including time and gas station information\">transactions_1k</table>",
        "<table purpose=\"Contains gas station information including chain ID\">gasstations</table>",
        "<column purpose=\"output: 'disparate time of the transactions'\">transactions_1k.Time</column>",
        "<column purpose=\"join: transactions_1k.GasStationID = gasstations.GasStationID\">transactions_1k.GasStationID</column>",
        "<column purpose=\"join: transactions_1k.GasStationID = gasstations.GasStationID\">gasstations.GasStationID</column>",
        "<column purpose=\"filter: 'from chain no. 11'\">gasstations.ChainID</column>",
        "<output_schema purpose=\"time of transactions\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'transactions taken place in the gas stations'--><table>transactions_1k</table>",
        "<!--Required to filter 'from chain no. 11'--><table>gasstations</table>",
        "<!--Time of transactions--><column>transactions_1k.Time</column>",
        "<!--Join: transactions_1k.GasStationID--><column>gasstations.GasStationID</column>",
        "<!--Filter: 'from chain no. 11'--><column>gasstations.ChainID</column>",
        "<!--Join: gasstations.GasStationID--><column>transactions_1k.GasStationID</column>",
        "<!--List the disparate time of transactions--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1509,
      "db_id": "debit_card_specializing",
      "question": "Among the transactions made in the gas stations in the Czech Republic, how many of them are taken place after 2012/1/1?",
      "evidence": "Czech Republic can be represented as the Country value in the gasstations table is 'CZE'",
      "SQL": "SELECT COUNT(T1.TransactionID) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.Country = 'CZE' AND STRFTIME('%Y', T1.Date) >= '2012'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["transactions_1k", "gasstations"],
        "columns": [
          "transactions_1k.TransactionID",
          "transactions_1k.GasStationID",
          "gasstations.GasStationID",
          "gasstations.Country",
          "transactions_1k.Date"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains transaction data for gas stations\">transactions_1k</table>",
        "<table purpose=\"Contains information about gas stations, including country\">gasstations</table>",
        "<column purpose=\"calculate: count of transactions\">transactions_1k.TransactionID</column>",
        "<column purpose=\"join: with gasstations.GasStationID\">transactions_1k.GasStationID</column>",
        "<column purpose=\"join: with transactions_1k.GasStationID\">gasstations.GasStationID</column>",
        "<column purpose=\"filter: 'Czech Republic can be represented as the Country value in the gasstations table is 'CZE''\">gasstations.Country</column>",
        "<column purpose=\"filter: 'transactions made ... after 2012/1/1'\">transactions_1k.Date</column>",
        "<output_schema purpose=\"count of transactions\">integer</output_schema>",
        "<warning>The SQL query uses STRFTIME to extract the year, but the Date column is already in date format. A simple comparison with '2012-01-01' would be more efficient.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for transaction details--><table>transactions_1k</table>",
        "<!--Required for gas station country information--><table>gasstations</table>",
        "<!--Filter: 'transactions made in the gas stations in the Czech Republic'--><column>gasstations.Country</column>",
        "<!--Join: transactions_1k.GasStationID--><column>gasstations.GasStationID</column>",
        "<!--Join: gasstations.GasStationID--><column>transactions_1k.GasStationID</column>",
        "<!--Filter: 'taken place after 2012/1/1'--><column>transactions_1k.Date</column>",
        "<!--Count of transactions meeting the criteria--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1514,
      "db_id": "debit_card_specializing",
      "question": "What kind of currency did the customer paid at 16:25:00 in 2012/8/24?",
      "evidence": "'2012/8/24' can be represented by '2012-08-24'; ",
      "SQL": "SELECT DISTINCT T3.Currency FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN customers AS T3 ON T1.CustomerID = T3.CustomerID WHERE T1.Date = '2012-08-24' AND T1.Time = '16:25:00'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["transactions_1k", "gasstations", "customers"],
        "columns": [
          "customers.Currency",
          "transactions_1k.GasStationID",
          "gasstations.GasStationID",
          "transactions_1k.CustomerID",
          "customers.CustomerID",
          "transactions_1k.Date",
          "transactions_1k.Time"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for transaction details\">transactions_1k</table>",
        "<table warning=\"This table is not necessary for the query\">gasstations</table>",
        "<table purpose=\"Required for customer currency information\">customers</table>",
        "<column purpose=\"calculate: 'What kind of currency'\">customers.Currency</column>",
        "<column warning=\"This column is not necessary for the query\">transactions_1k.GasStationID</column>",
        "<column warning=\"This column is not necessary for the query\">gasstations.GasStationID</column>",
        "<column purpose=\"join: customers.CustomerID\">transactions_1k.CustomerID</column>",
        "<column purpose=\"join: transactions_1k.CustomerID\">customers.CustomerID</column>",
        "<column purpose=\"filter: '2012/8/24'\">transactions_1k.Date</column>",
        "<column purpose=\"filter: '16:25:00'\">transactions_1k.Time</column>",
        "<output_schema purpose=\"currency type\">text</output_schema>",
        "<error>The join with gasstations table is unnecessary for this query as we don't need any information from this table to answer the question.</error>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for transaction details--><table>transactions_1k</table>",
        "<!--Required for customer currency information--><table>customers</table>",
        "<!--Filter: 'at 16:25:00'--><column>transactions_1k.Time</column>",
        "<!--Filter: 'in 2012/8/24'--><column>transactions_1k.Date</column>",
        "<!--Join: customers.CustomerID--><column>transactions_1k.CustomerID</column>",
        "<!--Join: transactions_1k.CustomerID--><column>customers.CustomerID</column>",
        "<!--Output: 'currency did the customer paid'--><column>customers.Currency</column>",
        "<!--Currency used by the customer--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1515,
      "db_id": "debit_card_specializing",
      "question": "What segment did the customer have at 2012/8/23 21:20:00?",
      "evidence": "'2012/8/23' can be represented by '2012-08-23'",
      "SQL": "SELECT T2.Segment FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.date = '2012-08-23' AND T1.time = '21:20:00'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["transactions_1k", "customers"],
        "columns": [
          "customers.Segment",
          "transactions_1k.CustomerID",
          "customers.CustomerID",
          "transactions_1k.Date",
          "transactions_1k.Time"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for transaction details at the specified date and time\">transactions_1k</table>",
        "<table purpose=\"Required for customer segment information\">customers</table>",
        "<column purpose=\"calculate: 'What segment did the customer have'\">customers.Segment</column>",
        "<column purpose=\"join: customers.CustomerID\">transactions_1k.CustomerID</column>",
        "<column purpose=\"join: transactions_1k.CustomerID\">customers.CustomerID</column>",
        "<column purpose=\"filter: 'at 2012/8/23'\">transactions_1k.Date</column>",
        "<column purpose=\"filter: '21:20:00'\">transactions_1k.Time</column>",
        "<output_schema purpose=\"customer segment\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for customer segment--><table>customers</table>",
        "<!--Required for transaction date and time--><table>transactions_1k</table>",
        "<!--join: transactions_1k.CustomerID--><column>customers.CustomerID</column>",
        "<!--join: customers.CustomerID--><column>transactions_1k.CustomerID</column>",
        "<!--filter: '2012-08-23'--><column>transactions_1k.Date</column>",
        "<!--filter: '21:20:00'--><column>transactions_1k.Time</column>",
        "<!--customer segment at specified date and time--><column>customers.Segment</column>",
        "<!--customer segment at specified date and time--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1521,
      "db_id": "debit_card_specializing",
      "question": "For all the transactions happened during 8:00-9:00 in 2012/8/26, how many happened in CZE?",
      "evidence": "Czech Republic can be represented as the Country value in the gasstations table is 'CZE'; '2012/8/26' can be represented by '2012-08-26'; during 8:00-9:00 can be represented as Time BETWEEN '08:00:00' AND '09:00:00'",
      "SQL": "SELECT COUNT(T1.TransactionID) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-26' AND T1.Time BETWEEN '08:00:00' AND '09:00:00' AND T2.Country = 'CZE'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["transactions_1k", "gasstations"],
        "columns": [
          "transactions_1k.TransactionID",
          "transactions_1k.GasStationID",
          "gasstations.GasStationID",
          "gasstations.Country",
          "transactions_1k.Date",
          "transactions_1k.Time"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for transaction details\">transactions_1k</table>",
        "<table purpose=\"Required for country information\">gasstations</table>",
        "<column purpose=\"calculate: count of transactions\">transactions_1k.TransactionID</column>",
        "<column purpose=\"join: with gasstations.GasStationID\">transactions_1k.GasStationID</column>",
        "<column purpose=\"join: with transactions_1k.GasStationID\">gasstations.GasStationID</column>",
        "<column purpose=\"filter: 'CZE'\">gasstations.Country</column>",
        "<column purpose=\"filter: '2012-08-26'\">transactions_1k.Date</column>",
        "<column purpose=\"filter: between '08:00:00' and '09:00:00'\">transactions_1k.Time</column>",
        "<output_schema purpose=\"count of transactions\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for transaction details--><table>transactions_1k</table>",
        "<!--Required for country information--><table>gasstations</table>",
        "<!--Filter: '2012/8/26'--><column>transactions_1k.Date</column>",
        "<!--Filter: 'during 8:00-9:00'--><column>transactions_1k.Time</column>",
        "<!--Join: transactions_1k.GasStationID--><column>gasstations.GasStationID</column>",
        "<!--Filter: 'in CZE'--><column>gasstations.Country</column>",
        "<!--Count of transactions--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1524,
      "db_id": "debit_card_specializing",
      "question": "What's the nationality of the customer who spent 548.4 in 2012/8/24?",
      "evidence": "'2012/8/24' can be represented by '2012-08-24'",
      "SQL": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-24' AND T1.Price  = 548.4",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["transactions_1k", "gasstations"],
        "columns": [
          "gasstations.Country",
          "transactions_1k.GasStationID",
          "gasstations.GasStationID",
          "transactions_1k.Date",
          "transactions_1k.Price"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for transaction details\">transactions_1k</table>",
        "<table purpose=\"Required for gas station country information\">gasstations</table>",
        "<column purpose=\"output: 'nationality of the customer'\">gasstations.Country</column>",
        "<column purpose=\"join: transactions_1k.GasStationID\">transactions_1k.GasStationID</column>",
        "<column purpose=\"join: gasstations.GasStationID\">gasstations.GasStationID</column>",
        "<column purpose=\"filter: '2012/8/24'\">transactions_1k.Date</column>",
        "<column purpose=\"filter: 'spent 548.4'\">transactions_1k.Price</column>",
        "<output_schema purpose=\"country code representing nationality\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for transaction details--><table>transactions_1k</table>",
        "<!--Required for customer information--><table>customers</table>",
        "<!--Required for gas station information--><table>gasstations</table>",
        "<!--Filter: '2012/8/24'--><column>transactions_1k.Date</column>",
        "<!--Filter: 'spent 548.4'--><column>transactions_1k.Price</column>",
        "<!--Join: transactions_1k.CustomerID--><column>customers.CustomerID</column>",
        "<!--Join: transactions_1k.GasStationID--><column>gasstations.GasStationID</column>",
        "<!--Nationality of the customer--><column>gasstations.Country</column>",
        "<!--Nationality of the customer--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1525,
      "db_id": "debit_card_specializing",
      "question": "What is the percentage of the customers who used EUR in 2012/8/25?",
      "evidence": "'2012/8/25' can be represented by '2012-08-25'",
      "SQL": "SELECT CAST(SUM(IIF(T2.Currency = 'EUR', 1, 0)) AS FLOAT) * 100 / COUNT(T1.CustomerID) FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-25'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["transactions_1k", "customers"],
        "columns": [
          "customers.Currency",
          "transactions_1k.CustomerID",
          "customers.CustomerID",
          "transactions_1k.Date"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for transaction data on '2012-08-25'\">transactions_1k</table>",
        "<table purpose=\"Required for customer currency information\">customers</table>",
        "<column purpose=\"filter: 'who used EUR'\">customers.Currency</column>",
        "<column purpose=\"join: customers.CustomerID\">transactions_1k.CustomerID</column>",
        "<column purpose=\"join: transactions_1k.CustomerID\">customers.CustomerID</column>",
        "<column purpose=\"filter: 'in 2012/8/25'\">transactions_1k.Date</column>",
        "<output_schema purpose=\"percentage of customers\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for customer currency information--><table>customers</table>",
        "<!--Required for transaction dates and customer IDs--><table>transactions_1k</table>",
        "<!--Filter: 'in 2012/8/25'--><column>transactions_1k.Date</column>",
        "<!--Join: customers.CustomerID--><column>transactions_1k.CustomerID</column>",
        "<!--Join: transactions_1k.CustomerID--><column>customers.CustomerID</column>",
        "<!--Filter: 'who used EUR'--><column>customers.Currency</column>",
        "<!--Percentage of customers who used EUR--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1526,
      "db_id": "debit_card_specializing",
      "question": "For the customer who paid 634.8 in 2012/8/25, what was the consumption decrease rate from Year 2012 to 2013?",
      "evidence": "'2012/8/24' can be represented by '2012-08-24'; Consumption decrease rate = (consumption_2012 - consumption_2013) / consumption_2012",
      "SQL": "SELECT CAST(SUM(IIF(SUBSTRING(Date, 1, 4) = '2012', Consumption, 0)) - SUM(IIF(SUBSTRING(Date, 1, 4) = '2013', Consumption, 0)) AS FLOAT) / SUM(IIF(SUBSTRING(Date, 1, 4) = '2012', Consumption, 0)) FROM yearmonth WHERE CustomerID = ( SELECT T1.CustomerID FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' AND T1.Price  = 1513.12 )",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["yearmonth", "transactions_1k", "gasstations"],
        "columns": [
          "yearmonth.Date",
          "yearmonth.Consumption",
          "transactions_1k.CustomerID",
          "yearmonth.CustomerID",
          "transactions_1k.Date",
          "transactions_1k.Price",
          "transactions_1k.GasStationID",
          "gasstations.GasStationID"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for calculating consumption in 2012 and 2013\">yearmonth</table>",
        "<table purpose=\"Required to identify the customer who paid 634.8 on 2012-08-25\">transactions_1k</table>",
        "<table warning=\"This table is not necessary for the given query\">gasstations</table>",
        "<column purpose=\"filter: to separate consumption for 2012 and 2013\">yearmonth.Date</column>",
        "<column purpose=\"calculate: consumption for 2012 and 2013\">yearmonth.Consumption</column>",
        "<column purpose=\"join: to link transactions with yearmonth data\">transactions_1k.CustomerID</column>",
        "<column purpose=\"join: to link transactions with yearmonth data\">yearmonth.CustomerID</column>",
        "<column purpose=\"filter: to identify the transaction on '2012-08-25'\">transactions_1k.Date</column>",
        "<column purpose=\"filter: to identify the transaction with Price 634.8\">transactions_1k.Price</column>",
        "<column warning=\"This column is not necessary for the given query\">transactions_1k.GasStationID</column>",
        "<column warning=\"This column is not necessary for the given query\">gasstations.GasStationID</column>",
        "<output_schema purpose=\"consumption decrease rate from 2012 to 2013\">real</output_schema>",
        "<error>The Price value in the proposal (634.8) does not match the value in the SQL query (1513.12)</error>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for finding the customer who paid 634.8 on 2012-08-25--><table>transactions_1k</table>",
        "<!--Required for getting consumption data--><table>yearmonth</table>",
        "<!--Filter transactions for the specific date--><column>transactions_1k.Date</column>",
        "<!--Filter transactions for the specific price--><column>transactions_1k.Price</column>",
        "<!--Join transactions with yearmonth--><column>transactions_1k.CustomerID</column>",
        "<!--Join transactions with yearmonth--><column>yearmonth.CustomerID</column>",
        "<!--Filter yearmonth data for 2012 and 2013--><column>yearmonth.Date</column>",
        "<!--Calculate consumption for 2012 and 2013--><column>yearmonth.Consumption</column>",
        "<!--Consumption decrease rate--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1528,
      "db_id": "debit_card_specializing",
      "question": "What is the percentage of \"premium\" against the overall segment in Country = \"SVK\"?",
      "evidence": "",
      "SQL": "SELECT CAST(SUM(IIF(Country = 'SVK' AND Segment = 'Premium', 1, 0)) AS FLOAT) * 100 / SUM(IIF(Country = 'SVK', 1, 0)) FROM gasstations",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["gasstations"],
        "columns": ["gasstations.Country", "gasstations.Segment"],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for analyzing gas station segments in Slovakia\">gasstations</table>",
        "<column purpose=\"filter: 'Country = 'SVK''\">gasstations.Country</column>",
        "<column purpose=\"filter: 'premium' segment, calculate: percentage of premium segment\">gasstations.Segment</column>",
        "<output_schema purpose=\"percentage of 'premium' against overall segment\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'segment' information--><table>gasstations</table>",
        "<!--Filter: 'Country = \"SVK\"'--><column>gasstations.Country</column>",
        "<!--Calculate: 'percentage of \"premium\" against the overall segment'--><column>gasstations.Segment</column>",
        "<!--Percentage of premium segment in SVK--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1529,
      "db_id": "debit_card_specializing",
      "question": "What is the amount spent by customer \"38508\" at the gas stations? How much had the customer spent in January 2012?",
      "evidence": "January 2012 refers to the Date value = '201201'",
      "SQL": "SELECT SUM(T1.Price ) , SUM(IIF(T3.Date = '201201', T1.Price, 0)) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN yearmonth AS T3 ON T1.CustomerID = T3.CustomerID WHERE T1.CustomerID = '38508'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["transactions_1k", "gasstations", "yearmonth"],
        "columns": [
          "transactions_1k.Price",
          "yearmonth.Date",
          "transactions_1k.GasStationID",
          "gasstations.GasStationID",
          "transactions_1k.CustomerID",
          "yearmonth.CustomerID"
        ],
        "output_schema": ["real", "real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains transaction data for customer spending at gas stations\">transactions_1k</table>",
        "<table purpose=\"Contains gas station information\">gasstations</table>",
        "<table purpose=\"Contains monthly consumption data for customers\">yearmonth</table>",
        "<column purpose=\"calculate: 'amount spent by customer'\">transactions_1k.Price</column>",
        "<column purpose=\"filter: 'January 2012'\">yearmonth.Date</column>",
        "<column purpose=\"join: transactions_1k.GasStationID\">transactions_1k.GasStationID</column>",
        "<column purpose=\"join: gasstations.GasStationID\">gasstations.GasStationID</column>",
        "<column purpose=\"filter: 'customer 38508', join: transactions_1k.CustomerID\">transactions_1k.CustomerID</column>",
        "<column purpose=\"join: yearmonth.CustomerID\">yearmonth.CustomerID</column>",
        "<output_schema purpose=\"total amount spent by customer 38508\">real</output_schema>",
        "<output_schema purpose=\"amount spent by customer 38508 in January 2012\">real</output_schema>",
        "<warning>The proposed solution doesn't include a filter for CustomerID = 38508, which is necessary to answer the question.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'amount spent by customer \"38508\"'--><table>transactions_1k</table>",
        "<!--Required for 'amount spent in January 2012'--><table>yearmonth</table>",
        "<!--filter: 'customer \"38508\"'--><column>transactions_1k.CustomerID</column>",
        "<!--calculate: 'amount spent'--><column>transactions_1k.Price</column>",
        "<!--filter: 'customer \"38508\"'--><column>yearmonth.CustomerID</column>",
        "<!--filter: 'in January 2012'--><column>yearmonth.Date</column>",
        "<!--calculate: 'amount spent in January 2012'--><column>yearmonth.Consumption</column>",
        "<!--amount spent at gas stations--><output_schema>real</output_schema>",
        "<!--amount spent in January 2012--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1531,
      "db_id": "debit_card_specializing",
      "question": "Who is the top spending customer and how much is the average price per single item purchased by this customer? What currency was being used?",
      "evidence": "average price per single item = Total(price) / Total(amount)",
      "SQL": "SELECT T2.CustomerID, SUM(T2.Price / T2.Amount), T1.Currency FROM customers AS T1 INNER JOIN transactions_1k AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.CustomerID = ( SELECT CustomerID FROM yearmonth ORDER BY Consumption DESC LIMIT 1 ) GROUP BY T2.CustomerID, T1.Currency",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["customers", "transactions_1k", "yearmonth"],
        "columns": [
          "yearmonth.CustomerID",
          "yearmonth.Consumption",
          "transactions_1k.CustomerID",
          "transactions_1k.Price",
          "transactions_1k.Amount",
          "customers.Currency",
          "customers.CustomerID"
        ],
        "output_schema": ["integer", "real", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for customer information and currency\">customers</table>",
        "<table purpose=\"Required for transaction details\">transactions_1k</table>",
        "<table purpose=\"Required to identify the top spending customer\">yearmonth</table>",
        "<column purpose=\"join: customers.CustomerID, transactions_1k.CustomerID; filter: top spending customer\">yearmonth.CustomerID</column>",
        "<column purpose=\"calculate: identify top spending customer\">yearmonth.Consumption</column>",
        "<column purpose=\"join: customers.CustomerID, yearmonth.CustomerID\">transactions_1k.CustomerID</column>",
        "<column purpose=\"calculate: average price per single item\">transactions_1k.Price</column>",
        "<column purpose=\"calculate: average price per single item\">transactions_1k.Amount</column>",
        "<column purpose=\"output: currency used by top spending customer\">customers.Currency</column>",
        "<column purpose=\"join: transactions_1k.CustomerID, yearmonth.CustomerID\">customers.CustomerID</column>",
        "<output_schema purpose=\"CustomerID of top spending customer\">integer</output_schema>",
        "<output_schema purpose=\"average price per single item\">real</output_schema>",
        "<output_schema purpose=\"currency used\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'top spending customer'--><table>transactions_1k</table>",
        "<!--Required for currency information--><table>customers</table>",
        "<!--join: transactions_1k.CustomerID--><column>customers.CustomerID</column>",
        "<!--join: customers.CustomerID--><column>transactions_1k.CustomerID</column>",
        "<!--calculate: 'top spending customer'--><column>transactions_1k.Price</column>",
        "<!--calculate: 'average price per single item'--><column>transactions_1k.Price</column>",
        "<!--calculate: 'average price per single item'--><column>transactions_1k.Amount</column>",
        "<!--identify: 'top spending customer'--><column>transactions_1k.CustomerID</column>",
        "<!--currency information--><column>customers.Currency</column>",
        "<!--top spending customer ID--><output_schema>integer</output_schema>",
        "<!--average price per single item--><output_schema>real</output_schema>",
        "<!--currency used--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1533,
      "db_id": "debit_card_specializing",
      "question": "For all the people who paid more than 29.00 per unit of product id No.5. Give their consumption status in the August of 2012.",
      "evidence": "August of 2012 refers to the Date value = '201208' ; Price per unit of product = Price / Amount;",
      "SQL": "SELECT T2.Consumption FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Price / T1.Amount > 29.00 AND T1.ProductID = 5 AND T2.Date = '201208'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["transactions_1k", "yearmonth"],
        "columns": [
          "yearmonth.Consumption",
          "transactions_1k.CustomerID",
          "yearmonth.CustomerID",
          "yearmonth.Date",
          "transactions_1k.Price",
          "transactions_1k.Amount",
          "transactions_1k.ProductID"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for transaction data including price and amount\">transactions_1k</table>",
        "<table purpose=\"Required for consumption data in August 2012\">yearmonth</table>",
        "<column purpose=\"calculate: 'consumption status in the August of 2012'\">yearmonth.Consumption</column>",
        "<column purpose=\"join: transactions_1k.CustomerID\">yearmonth.CustomerID</column>",
        "<column purpose=\"join: yearmonth.CustomerID\">transactions_1k.CustomerID</column>",
        "<column purpose=\"filter: 'August of 2012'\">yearmonth.Date</column>",
        "<column purpose=\"calculate: 'paid more than 29.00 per unit'\">transactions_1k.Price</column>",
        "<column purpose=\"calculate: 'paid more than 29.00 per unit'\">transactions_1k.Amount</column>",
        "<column purpose=\"filter: 'product id No.5'\">transactions_1k.ProductID</column>",
        "<output_schema purpose=\"consumption status\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'people who paid more than 29.00 per unit of product id No.5'--><table>transactions_1k</table>",
        "<!--Required for 'consumption status in the August of 2012'--><table>yearmonth</table>",
        "<!--Filter: 'product id No.5'--><column>transactions_1k.ProductID</column>",
        "<!--Calculate: 'Price per unit of product'--><column>transactions_1k.Price</column>",
        "<!--Calculate: 'Price per unit of product'--><column>transactions_1k.Amount</column>",
        "<!--Join: transactions_1k.CustomerID--><column>yearmonth.CustomerID</column>",
        "<!--Join: yearmonth.CustomerID--><column>transactions_1k.CustomerID</column>",
        "<!--Filter: 'August of 2012'--><column>yearmonth.Date</column>",
        "<!--Output: 'consumption status'--><column>yearmonth.Consumption</column>",
        "<!--CustomerID of people who paid more than 29.00 per unit of product id No.5--><output_schema>integer</output_schema>",
        "<!--Consumption status in August 2012--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1312,
      "db_id": "student_club",
      "question": "What's Angela Sanders's major?",
      "evidence": "Angela Sanders is the full name; full name refers to first_name, last_name; major refers to major_name.",
      "SQL": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Angela' AND T1.last_name = 'Sanders'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["member", "major"],
        "columns": [
          "major.major_name",
          "member.link_to_major",
          "major.major_id",
          "member.first_name",
          "member.last_name"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains member information, including Angela Sanders\">member</table>",
        "<table purpose=\"Contains major information\">major</table>",
        "<column purpose=\"Output: 'Angela Sanders's major'\">major.major_name</column>",
        "<column purpose=\"Join: link member to major\">member.link_to_major</column>",
        "<column purpose=\"Join: link major to member\">major.major_id</column>",
        "<column purpose=\"Filter: 'Angela Sanders'\">member.first_name</column>",
        "<column purpose=\"Filter: 'Angela Sanders'\">member.last_name</column>",
        "<output_schema purpose=\"Major name is stored as text\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for member information--><table>member</table>",
        "<!--Required for major information--><table>major</table>",
        "<!--Filter: 'Angela Sanders's'--><column>member.first_name</column>",
        "<!--Filter: 'Angela Sanders's'--><column>member.last_name</column>",
        "<!--Join: member.link_to_major--><column>member.link_to_major</column>",
        "<!--Join: major.major_id--><column>major.major_id</column>",
        "<!--Output: 'major'--><column>major.major_name</column>",
        "<!--Angela Sanders's major--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1317,
      "db_id": "student_club",
      "question": "Among the students from the Student_Club who attended the event \"Women's Soccer\", how many of them want a T-shirt that's in medium size?",
      "evidence": "Women's Soccer is an event name; T-shirt that is in medium size refers to t_shirt_size = 'Medium'",
      "SQL": "SELECT COUNT(T1.event_id) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T1.event_name = 'Women''s Soccer' AND T3.t_shirt_size = 'Medium'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["event", "attendance", "member"],
        "columns": [
          "event.event_id",
          "attendance.link_to_event",
          "attendance.link_to_member",
          "member.member_id",
          "member.t_shirt_size",
          "event.event_name"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'Women's Soccer' event\">event</table>",
        "<table purpose=\"Required to link events with members who attended\">attendance</table>",
        "<table purpose=\"Required for member information, including t-shirt size\">member</table>",
        "<column purpose=\"join: attendance.link_to_event\">event.event_id</column>",
        "<column purpose=\"join: event.event_id\">attendance.link_to_event</column>",
        "<column purpose=\"join: member.member_id\">attendance.link_to_member</column>",
        "<column purpose=\"join: attendance.link_to_member\">member.member_id</column>",
        "<column purpose=\"filter: 'T-shirt that's in medium size'\">member.t_shirt_size</column>",
        "<column purpose=\"filter: 'Women's Soccer' event\">event.event_name</column>",
        "<output_schema purpose=\"count of students with medium t-shirt size who attended Women's Soccer event\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'students who attended the event'--><table>attendance</table>",
        "<!--Required for 'event \"Women's Soccer\"'--><table>event</table>",
        "<!--Required for student information and t-shirt size--><table>member</table>",
        "<!--Join: attendance.link_to_event--><column>event.event_id</column>",
        "<!--Filter: 'event \"Women's Soccer\"'--><column>event.event_name</column>",
        "<!--Join: attendance.link_to_member--><column>member.member_id</column>",
        "<!--Filter: 'T-shirt that's in medium size'--><column>member.t_shirt_size</column>",
        "<!--Count of students meeting criteria--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1322,
      "db_id": "student_club",
      "question": "Among the events attended by more than 10 members of the Student_Club, how many of them are meetings?",
      "evidence": "meetings events refers to type = 'Meeting'; attended by more than 10 members refers to COUNT(event_id) > 10",
      "SQL": "SELECT T1.event_name FROM event AS T1  INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event GROUP BY T1.event_id  HAVING COUNT(T2.link_to_event) > 10 EXCEPT SELECT T1.event_name  FROM event AS T1  WHERE T1.type = 'Meeting'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["event", "attendance"],
        "columns": [
          "event.event_name",
          "event.event_id",
          "attendance.link_to_event",
          "event.type"
        ],
        "output_schema": []
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for event details and filtering\">event</table>",
        "<table purpose=\"Required for counting attendees\">attendance</table>",
        "<column purpose=\"Output: event names\">event.event_name</column>",
        "<column purpose=\"join: event.event_id = attendance.link_to_event, group by: 'events attended by more than 10 members'\">event.event_id</column>",
        "<column purpose=\"join: event.event_id = attendance.link_to_event, count: 'attended by more than 10 members'\">attendance.link_to_event</column>",
        "<column purpose=\"filter: 'meetings events refers to type = 'Meeting''\">event.type</column>",
        "<error>The proposed solution is missing COUNT(*) or COUNT(attendance.link_to_member) to count the number of attendees per event</error>",
        "<error>The proposed solution is missing a column to count the number of meeting events that meet the criteria</error>",
        "<error>The output schema is missing. It should be an integer representing the count of meeting events attended by more than 10 members</error>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for event details--><table>event</table>",
        "<!--Required for attendance information--><table>attendance</table>",
        "<!--Join event and attendance tables--><column>event.event_id</column>",
        "<!--Join event and attendance tables--><column>attendance.link_to_event</column>",
        "<!--Filter for meeting events--><column>event.type</column>",
        "<!--Count attendees per event--><column>attendance.link_to_member</column>",
        "<!--Count of meeting events with more than 10 attendees--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1323,
      "db_id": "student_club",
      "question": "List all the names of events that had an attendance of over 20 students but were not fundraisers.",
      "evidence": "name of events refers to event_name; attendance of over 20 students COUNT(event_id) > 20.",
      "SQL": "SELECT T1.event_name FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event GROUP BY T1.event_id HAVING COUNT(T2.link_to_event) > 20 EXCEPT SELECT T1.event_name FROM event AS T1  WHERE T1.type = 'Fundraiser'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["event", "attendance"],
        "columns": [
          "event.event_name",
          "event.event_id",
          "attendance.link_to_event",
          "event.type"
        ],
        "output_schema": []
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for event details and filtering\">event</table>",
        "<table purpose=\"Required for counting attendance\">attendance</table>",
        "<column purpose=\"output: 'List all the names of events'\">event.event_name</column>",
        "<column purpose=\"join: attendance.link_to_event, group by: 'attendance of over 20 students'\">event.event_id</column>",
        "<column purpose=\"join: event.event_id, count: 'attendance of over 20 students'\">attendance.link_to_event</column>",
        "<column purpose=\"filter: 'were not fundraisers'\">event.type</column>",
        "<warning>The proposal is missing an output schema. Consider adding &lt;output_schema&gt;text&lt;/output_schema&gt; for the event names.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'names of events'--><table>event</table>",
        "<!--Required for 'attendance of over 20 students'--><table>attendance</table>",
        "<!--'names of events' refers to event_name--><column>event.event_name</column>",
        "<!--join: attendance.link_to_event--><column>event.event_id</column>",
        "<!--join: event.event_id--><column>attendance.link_to_event</column>",
        "<!--Required to count attendance--><column>attendance.link_to_member</column>",
        "<!--filter: 'were not fundraisers'--><column>event.type</column>",
        "<!--List all the names of events--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1331,
      "db_id": "student_club",
      "question": "What is the amount of the funds that the Vice President received?",
      "evidence": "'Vice President' is a position of Student Club; funds received refers to amount.",
      "SQL": "SELECT T2.amount FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.position = 'Vice President'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["member", "income"],
        "columns": [
          "income.amount",
          "member.member_id",
          "income.link_to_member",
          "member.position"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to get member information, including position\">member</table>",
        "<table purpose=\"Required to get income information\">income</table>",
        "<column purpose=\"calculate: 'amount of the funds'\">income.amount</column>",
        "<column purpose=\"join: income.link_to_member\">member.member_id</column>",
        "<column purpose=\"join: member.member_id\">income.link_to_member</column>",
        "<column purpose=\"filter: 'Vice President'\">member.position</column>",
        "<output_schema purpose=\"amount of funds received\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'funds received'--><table>income</table>",
        "<!--Required for 'Vice President'--><table>member</table>",
        "<!--join: income.link_to_member--><column>member.member_id</column>",
        "<!--join: member.member_id--><column>income.link_to_member</column>",
        "<!--filter: 'Vice President'--><column>member.position</column>",
        "<!--calculate: 'amount of the funds'--><column>income.amount</column>",
        "<!--amount of the funds received--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1334,
      "db_id": "student_club",
      "question": "List the full name of the Student_Club members that grew up in Illinois state.",
      "evidence": "full name of member refers to first_name, last_name",
      "SQL": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.state = 'Illinois'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["member", "zip_code"],
        "columns": [
          "member.first_name",
          "member.last_name",
          "member.zip",
          "zip_code.zip_code",
          "zip_code.state"
        ],
        "output_schema": ["text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains member information, including name and zip code\">member</table>",
        "<table purpose=\"Contains state information for zip codes\">zip_code</table>",
        "<column purpose=\"output: part of 'full name of the Student_Club members'\">member.first_name</column>",
        "<column purpose=\"output: part of 'full name of the Student_Club members'\">member.last_name</column>",
        "<column purpose=\"join: with zip_code.zip_code\">member.zip</column>",
        "<column purpose=\"join: with member.zip\">zip_code.zip_code</column>",
        "<column purpose=\"filter: 'grew up in Illinois state'\">zip_code.state</column>",
        "<output_schema purpose=\"first name of member\">text</output_schema>",
        "<output_schema purpose=\"last name of member\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for member information--><table>member</table>",
        "<!--Required for state information--><table>zip_code</table>",
        "<!--join: member.zip--><column>zip_code.zip_code</column>",
        "<!--join: zip_code.zip_code--><column>member.zip</column>",
        "<!--filter: 'grew up in Illinois state'--><column>zip_code.state</column>",
        "<!--'full name of the Student_Club members'--><column>member.first_name</column>",
        "<!--'full name of the Student_Club members'--><column>member.last_name</column>",
        "<!--full name of members from Illinois--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1338,
      "db_id": "student_club",
      "question": "Was each expense in October Meeting on October 8, 2019 approved?",
      "evidence": "event_name = 'October Meeting' where event_date = '2019-10-08'; approved = True means expenses was approved; approved = False means expenses was not approved",
      "SQL": "SELECT T3.approved FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'October Meeting' AND T1.event_date LIKE '2019-10-08%'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["event", "budget", "expense"],
        "columns": [
          "expense.approved",
          "event.event_id",
          "budget.link_to_event",
          "budget.budget_id",
          "expense.link_to_budget",
          "event.event_date",
          "event.event_name"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'October Meeting' event details\">event</table>",
        "<table purpose=\"Required to link event to expenses\">budget</table>",
        "<table purpose=\"Required for expense approval information\">expense</table>",
        "<column purpose=\"calculate: 'Was each expense approved?'\">expense.approved</column>",
        "<column purpose=\"join: budget.link_to_event\">event.event_id</column>",
        "<column purpose=\"join: event.event_id\">budget.link_to_event</column>",
        "<column purpose=\"join: expense.link_to_budget\">budget.budget_id</column>",
        "<column purpose=\"join: budget.budget_id\">expense.link_to_budget</column>",
        "<column purpose=\"filter: 'on October 8, 2019'\">event.event_date</column>",
        "<column purpose=\"filter: 'October Meeting'\">event.event_name</column>",
        "<output_schema purpose=\"approval status of expenses\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'October Meeting' event details--><table>event</table>",
        "<!--Required for expense details--><table>expense</table>",
        "<!--Required for linking expenses to events--><table>budget</table>",
        "<!--Filter: 'October Meeting'--><column>event.event_name</column>",
        "<!--Filter: 'on October 8, 2019'--><column>event.event_date</column>",
        "<!--Join: event to budget--><column>event.event_id</column>",
        "<!--Join: event to budget--><column>budget.link_to_event</column>",
        "<!--Join: budget to expense--><column>budget.budget_id</column>",
        "<!--Join: budget to expense--><column>expense.link_to_budget</column>",
        "<!--Filter: expenses in October--><column>expense.expense_date</column>",
        "<!--Check: 'Was each expense approved?'--><column>expense.approved</column>",
        "<!--Description of expense--><column>expense.expense_description</column>",
        "<!--Expense description--><output_schema>text</output_schema>",
        "<!--Approval status--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1339,
      "db_id": "student_club",
      "question": "Calculate the total average cost that Elijah Allen spent in the events on September and October.",
      "evidence": "Elijah Allen is the full name; full name refers to first_name, last_name; The 5th and 6th string of the expense_date in the expense table can refer to month; events in September and October refers to month(expense_date) = 9 OR month(expense_date) = 10",
      "SQL": "SELECT AVG(T2.cost) FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.last_name = 'Allen' AND T1.first_name = 'Elijah' AND (SUBSTR(T2.expense_date, 6, 2) = '09' OR SUBSTR(T2.expense_date, 6, 2) = '10')",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["member", "expense"],
        "columns": [
          "expense.cost",
          "member.member_id",
          "expense.link_to_member",
          "expense.expense_date",
          "member.first_name",
          "member.last_name"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for member information\">member</table>",
        "<table purpose=\"Required for expense information\">expense</table>",
        "<column purpose=\"calculate: 'total average cost'\">expense.cost</column>",
        "<column purpose=\"join: expense.link_to_member\">member.member_id</column>",
        "<column purpose=\"join: member.member_id\">expense.link_to_member</column>",
        "<column purpose=\"filter: 'events on September and October'\">expense.expense_date</column>",
        "<column purpose=\"filter: 'Elijah Allen'\">member.first_name</column>",
        "<column purpose=\"filter: 'Elijah Allen'\">member.last_name</column>",
        "<output_schema purpose=\"average cost\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for member information--><table>member</table>",
        "<!--Required for expense information--><table>expense</table>",
        "<!--Filter: 'Elijah Allen'--><column>member.first_name</column>",
        "<!--Filter: 'Elijah Allen'--><column>member.last_name</column>",
        "<!--Join: member to expense--><column>member.member_id</column>",
        "<!--Join: expense to member--><column>expense.link_to_member</column>",
        "<!--Filter: 'in September and October'--><column>expense.expense_date</column>",
        "<!--Calculate: 'total average cost'--><column>expense.cost</column>",
        "<!--Total average cost for Elijah Allen in September and October--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1340,
      "db_id": "student_club",
      "question": "Calculate the difference of the total amount spent in all events by the Student_Club in year 2019 and 2020.",
      "evidence": "The first 4 strings of the event_date values in the event table can represent year; The difference of the total amount spent = SUBTRACT(spent where YEAR(event_date) = 2019, spent where YEAR(event_date) = 2020)",
      "SQL": "SELECT SUM(CASE WHEN SUBSTR(T1.event_date, 1, 4) = '2019' THEN T2.spent ELSE 0 END) - SUM(CASE WHEN SUBSTR(T1.event_date, 1, 4) = '2020' THEN T2.spent ELSE 0 END) AS num FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["event", "budget"],
        "columns": [
          "event.event_date",
          "budget.spent",
          "event.event_id",
          "budget.link_to_event"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for event dates and to join with budget\">event</table>",
        "<table purpose=\"Required for spent amounts\">budget</table>",
        "<column purpose=\"filter: 'in year 2019 and 2020'\">event.event_date</column>",
        "<column purpose=\"calculate: 'total amount spent'\">budget.spent</column>",
        "<column purpose=\"join: event.event_id\">event.event_id</column>",
        "<column purpose=\"join: budget.link_to_event\">budget.link_to_event</column>",
        "<output_schema purpose=\"difference of total amount spent between 2019 and 2020\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'total amount spent in all events'--><table>budget</table>",
        "<!--Required for filtering by year and joining with budget--><table>event</table>",
        "<!--filter: 'in year 2019 and 2020'--><column>event.event_date</column>",
        "<!--calculate: 'total amount spent'--><column>budget.spent</column>",
        "<!--join: budget.link_to_event--><column>event.event_id</column>",
        "<!--join: event.event_id--><column>budget.link_to_event</column>",
        "<!--difference of total amount spent between 2019 and 2020--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1344,
      "db_id": "student_club",
      "question": "What was the notes of the fundraising on 2019/9/14?",
      "evidence": "fundraising on 2019/9/14 refers to source = 'Fundraising' where date_received = '2019-09-14'",
      "SQL": "SELECT notes FROM income WHERE source = 'Fundraising' AND date_received = '2019-09-14'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["income"],
        "columns": ["income.notes", "income.date_received", "income.source"],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for querying fundraising information\">income</table>",
        "<column purpose=\"retrieve: 'What was the notes of the fundraising'\">income.notes</column>",
        "<column purpose=\"filter: 'on 2019/9/14'\">income.date_received</column>",
        "<column purpose=\"filter: 'fundraising'\">income.source</column>",
        "<output_schema purpose=\"notes of the fundraising\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'fundraising' information--><table>income</table>",
        "<!--filter: 'source = 'Fundraising''--><column>income.source</column>",
        "<!--filter: 'date_received = '2019-09-14''--><column>income.date_received</column>",
        "<!--retrieve: 'notes of the fundraising'--><column>income.notes</column>",
        "<!--notes of the fundraising--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1346,
      "db_id": "student_club",
      "question": "Tell the phone number of \"Carlo Jacobs\".",
      "evidence": "Carlo Jacobs is the full name; full name refers to first_name, last_name;",
      "SQL": "SELECT phone FROM member WHERE first_name = 'Carlo' AND last_name = 'Jacobs'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["member"],
        "columns": ["member.phone", "member.first_name", "member.last_name"],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains member information including phone number and name\">member</table>",
        "<column purpose=\"retrieve: 'Tell the phone number'\">member.phone</column>",
        "<column purpose=\"filter: 'Carlo Jacobs'\">member.first_name</column>",
        "<column purpose=\"filter: 'Carlo Jacobs'\">member.last_name</column>",
        "<output_schema purpose=\"phone number is stored as text\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Carlo Jacobs'--><table>member</table>",
        "<!--filter: 'Carlo' in first name--><column>member.first_name</column>",
        "<!--filter: 'Jacobs' in last name--><column>member.last_name</column>",
        "<!--output: 'phone number'--><column>member.phone</column>",
        "<!--phone number of Carlo Jacobs--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1350,
      "db_id": "student_club",
      "question": "What is the status of the event which bought \"Post Cards, Posters\" on 2019/8/20?",
      "evidence": "'Post Cards, Posters' is an expense description; on 2019/8/20 refers to expense_date = '2019-8-20'; status of event refers to event_status",
      "SQL": "SELECT T1.event_status FROM budget AS T1 INNER JOIN expense AS T2 ON T1.budget_id = T2.link_to_budget WHERE T2.expense_description = 'Post Cards, Posters' AND T2.expense_date = '2019-08-20'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["budget", "expense"],
        "columns": [
          "budget.event_status",
          "budget.budget_id",
          "expense.link_to_budget",
          "expense.expense_date",
          "expense.expense_description"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'status of the event'\">budget</table>",
        "<table purpose=\"Required for expense details\">expense</table>",
        "<column purpose=\"output: 'status of the event'\">budget.event_status</column>",
        "<column purpose=\"join: expense.link_to_budget\">budget.budget_id</column>",
        "<column purpose=\"join: budget.budget_id\">expense.link_to_budget</column>",
        "<column purpose=\"filter: 'on 2019/8/20'\">expense.expense_date</column>",
        "<column purpose=\"filter: 'Post Cards, Posters'\">expense.expense_description</column>",
        "<output_schema purpose=\"event status (text value)\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for expense details--><table>expense</table>",
        "<!--Required for budget details--><table>budget</table>",
        "<!--Required for event details--><table>event</table>",
        "<!--Filter: \"Post Cards, Posters\"--><column>expense.expense_description</column>",
        "<!--Filter: \"on 2019/8/20\"--><column>expense.expense_date</column>",
        "<!--Join: expense to budget--><column>expense.link_to_budget</column>",
        "<!--Join: expense to budget--><column>budget.budget_id</column>",
        "<!--Join: budget to event--><column>budget.link_to_event</column>",
        "<!--Join: budget to event--><column>event.event_id</column>",
        "<!--Required: \"status of the event\"--><column>budget.event_status</column>",
        "<!--Status of the event--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1351,
      "db_id": "student_club",
      "question": "What was Brent Thomason's major?",
      "evidence": "Brent Thomason is the full name; full name refers to first_name, last_name; major refers to major_name",
      "SQL": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Brent' AND T1.last_name = 'Thomason'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["member", "major"],
        "columns": [
          "major.major_name",
          "member.link_to_major",
          "major.major_id",
          "member.first_name",
          "member.last_name"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains member information, including name and link to major\">member</table>",
        "<table purpose=\"Contains major information, including major name\">major</table>",
        "<column purpose=\"Output: 'Brent Thomason's major'\">major.major_name</column>",
        "<column purpose=\"Join: link member to major\">member.link_to_major</column>",
        "<column purpose=\"Join: link major to member\">major.major_id</column>",
        "<column purpose=\"Filter: 'Brent Thomason's first name'\">member.first_name</column>",
        "<column purpose=\"Filter: 'Brent Thomason's last name'\">member.last_name</column>",
        "<output_schema purpose=\"Major name is of type text\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Brent Thomason'--><table>member</table>",
        "<!--Required for 'major'--><table>major</table>",
        "<!--filter: 'Brent Thomason' (first name)--><column>member.first_name</column>",
        "<!--filter: 'Brent Thomason' (last name)--><column>member.last_name</column>",
        "<!--join: member.link_to_major--><column>member.link_to_major</column>",
        "<!--join: major.major_id--><column>major.major_id</column>",
        "<!--output: 'major'--><column>major.major_name</column>",
        "<!--Brent Thomason's major--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1352,
      "db_id": "student_club",
      "question": "For all the club members from \"Business\" major, how many of them wear medium size t-shirt?",
      "evidence": "'Business' is a major name; wear medium size t-shirt refers to t_shirt_size = 'Medium'",
      "SQL": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Business' AND T1.t_shirt_size = 'Medium'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["member", "major"],
        "columns": [
          "member.member_id",
          "member.link_to_major",
          "major.major_id",
          "major.major_name",
          "member.t_shirt_size"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains member information including t-shirt size\">member</table>",
        "<table purpose=\"Contains major information to filter for 'Business' major\">major</table>",
        "<column purpose=\"Used for counting members\">member.member_id</column>",
        "<column purpose=\"join: major.major_id\">member.link_to_major</column>",
        "<column purpose=\"join: member.link_to_major\">major.major_id</column>",
        "<column purpose=\"filter: 'Business' major\">major.major_name</column>",
        "<column purpose=\"filter: 'Medium' t-shirt size\">member.t_shirt_size</column>",
        "<output_schema purpose=\"Count of members meeting the criteria\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'club members'--><table>member</table>",
        "<!--Required for 'Business' major--><table>major</table>",
        "<!--join: member.link_to_major--><column>major.major_id</column>",
        "<!--join: major.major_id--><column>member.link_to_major</column>",
        "<!--filter: 'Business' major--><column>major.major_name</column>",
        "<!--filter: 'wear medium size t-shirt'--><column>member.t_shirt_size</column>",
        "<!--count of members--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1356,
      "db_id": "student_club",
      "question": "Which department was the President of the club in?",
      "evidence": "'President' is a position of Student Club",
      "SQL": "SELECT T2.department FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.position = 'President'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["member", "major"],
        "columns": [
          "major.department",
          "member.link_to_major",
          "major.major_id",
          "member.position"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains member information including position\">member</table>",
        "<table purpose=\"Contains department information for majors\">major</table>",
        "<column purpose=\"Output: department of the President\">major.department</column>",
        "<column purpose=\"Join: link member to major\">member.link_to_major</column>",
        "<column purpose=\"Join: link major to member\">major.major_id</column>",
        "<column purpose=\"Filter: identify the President\">member.position</column>",
        "<output_schema purpose=\"Department name is text\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'President' position--><table>member</table>",
        "<!--Required for department information--><table>major</table>",
        "<!--Filter: 'President' position--><column>member.position</column>",
        "<!--Join: member.link_to_major--><column>member.link_to_major</column>",
        "<!--Join: major.major_id--><column>major.major_id</column>",
        "<!--Required for department information--><column>major.department</column>",
        "<!--Department of the President--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1357,
      "db_id": "student_club",
      "question": "State the date Connor Hilton paid his/her dues.",
      "evidence": "Connor Hilton is the full name; full name refers to first_name, last_name; date the dues was paid refers to date_received where source = 'Dues';",
      "SQL": "SELECT T2.date_received FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.first_name = 'Connor' AND T1.last_name = 'Hilton' AND T2.source = 'Dues'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["member", "income"],
        "columns": [
          "income.date_received",
          "member.member_id",
          "income.link_to_member",
          "income.source",
          "member.first_name",
          "member.last_name"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to get member information\">member</table>",
        "<table purpose=\"Required to get income (dues) information\">income</table>",
        "<column purpose=\"calculate: 'date Connor Hilton paid his/her dues'\">income.date_received</column>",
        "<column purpose=\"join: income.link_to_member\">member.member_id</column>",
        "<column purpose=\"join: member.member_id\">income.link_to_member</column>",
        "<column purpose=\"filter: 'where source = 'Dues''\">income.source</column>",
        "<column purpose=\"filter: 'Connor Hilton is the full name'\">member.first_name</column>",
        "<column purpose=\"filter: 'Connor Hilton is the full name'\">member.last_name</column>",
        "<output_schema purpose=\"date the dues was paid\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for member information--><table>member</table>",
        "<!--Required for income information--><table>income</table>",
        "<!--Filter: 'Connor' in full name--><column>member.first_name</column>",
        "<!--Filter: 'Hilton' in full name--><column>member.last_name</column>",
        "<!--Join: income.link_to_member--><column>member.member_id</column>",
        "<!--Join: member.member_id--><column>income.link_to_member</column>",
        "<!--Filter: source = 'Dues'--><column>income.source</column>",
        "<!--Output: 'date Connor Hilton paid his/her dues'--><column>income.date_received</column>",
        "<!--Date Connor Hilton paid dues--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1359,
      "db_id": "student_club",
      "question": "How many times was the budget in Advertisement for \"Yearly Kickoff\" meeting more than \"October Meeting\"?",
      "evidence": "budget in Advertisement refer to category = 'Advertisement' in the budget table; DIVIDE(SUM(amount when event_name = 'Yearly Kickoff'), SUM(amount when event_name = 'October Meeting'))",
      "SQL": "SELECT CAST(SUM(CASE WHEN T2.event_name = 'Yearly Kickoff' THEN T1.amount ELSE 0 END) AS REAL) / SUM(CASE WHEN T2.event_name = 'October Meeting' THEN T1.amount ELSE 0 END) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Advertisement' AND T2.type = 'Meeting'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["budget", "event"],
        "columns": [
          "event.event_name",
          "budget.amount",
          "budget.link_to_event",
          "event.event_id",
          "event.type",
          "budget.category"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for budget information\">budget</table>",
        "<table purpose=\"Required for event information\">event</table>",
        "<column purpose=\"filter: 'Yearly Kickoff' and 'October Meeting'\">event.event_name</column>",
        "<column purpose=\"calculate: sum of amounts for each meeting\">budget.amount</column>",
        "<column purpose=\"join: budget to event\">budget.link_to_event</column>",
        "<column purpose=\"join: event to budget\">event.event_id</column>",
        "<column purpose=\"filter: 'Meeting'\">event.type</column>",
        "<column purpose=\"filter: 'Advertisement'\">budget.category</column>",
        "<output_schema purpose=\"ratio of budget amounts\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'budget in Advertisement'--><table>budget</table>",
        "<!--Required for event names--><table>event</table>",
        "<!--Filter: 'budget in Advertisement'--><column>budget.category</column>",
        "<!--Join: budget.link_to_event--><column>event.event_id</column>",
        "<!--Join: event.event_id--><column>budget.link_to_event</column>",
        "<!--Filter: 'Yearly Kickoff' and 'October Meeting'--><column>event.event_name</column>",
        "<!--Calculate: sum of amount--><column>budget.amount</column>",
        "<!--Result of division--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1361,
      "db_id": "student_club",
      "question": "What is the total cost of the pizzas for all the events?",
      "evidence": "total cost of the pizzas refers to SUM(cost) where expense_description = 'Pizza'",
      "SQL": "SELECT SUM(cost) FROM expense WHERE expense_description = 'Pizza'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["expense"],
        "columns": ["expense.cost", "expense.expense_description"],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'total cost of the pizzas for all the events'\">expense</table>",
        "<column purpose=\"calculate: 'total cost of the pizzas'\">expense.cost</column>",
        "<column purpose=\"filter: 'pizzas'\">expense.expense_description</column>",
        "<output_schema purpose=\"total cost of the pizzas\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'total cost of the pizzas'--><table>expense</table>",
        "<!--calculate: 'total cost of the pizzas'--><column>expense.cost</column>",
        "<!--filter: 'pizzas for all the events'--><column>expense.expense_description</column>",
        "<!--total cost of the pizzas--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1362,
      "db_id": "student_club",
      "question": "How many cities are there in Orange County, Virginia?",
      "evidence": "Orange County is the county name, Virginia is the state name",
      "SQL": "SELECT COUNT(city) FROM zip_code WHERE county = 'Orange County' AND state = 'Virginia'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["zip_code"],
        "columns": ["zip_code.city", "zip_code.county", "zip_code.state"],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains city, county, and state information\">zip_code</table>",
        "<column purpose=\"calculate: count of distinct cities\">zip_code.city</column>",
        "<column purpose=\"filter: 'Orange County'\">zip_code.county</column>",
        "<column purpose=\"filter: 'Virginia'\">zip_code.state</column>",
        "<output_schema purpose=\"count of cities\">integer</output_schema>",
        "<warning>The COUNT() function in the SQL query doesn't count distinct cities. To get the number of unique cities, you should use COUNT(DISTINCT city) instead of COUNT(city).</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for city and county information--><table>zip_code</table>",
        "<!--Filter for 'Orange County'--><column>zip_code.county</column>",
        "<!--Filter for 'Virginia'--><column>zip_code.state</column>",
        "<!--Count distinct cities--><column>zip_code.city</column>",
        "<!--Number of cities in Orange County, Virginia--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1368,
      "db_id": "student_club",
      "question": "What does the person with the phone number \"809-555-3360\" major in?",
      "evidence": "major in refers to major_name",
      "SQL": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.phone = '809-555-3360'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["member", "major"],
        "columns": [
          "major.major_name",
          "member.link_to_major",
          "major.major_id",
          "member.phone"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains member information including phone number\">member</table>",
        "<table purpose=\"Contains major information\">major</table>",
        "<column purpose=\"Output: 'What does the person ... major in?'\">major.major_name</column>",
        "<column purpose=\"join: major.major_id\">member.link_to_major</column>",
        "<column purpose=\"join: member.link_to_major\">major.major_id</column>",
        "<column purpose=\"filter: 'person with the phone number &quot;809-555-3360&quot;'\">member.phone</column>",
        "<output_schema purpose=\"major name is text\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for member information--><table>member</table>",
        "<!--Required for major information--><table>major</table>",
        "<!--Filter: 'person with the phone number \"809-555-3360\"'--><column>member.phone</column>",
        "<!--Join: member.link_to_major--><column>member.link_to_major</column>",
        "<!--Join: major.major_id--><column>major.major_id</column>",
        "<!--Output: 'major in refers to major_name'--><column>major.major_name</column>",
        "<!--Person's major--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1371,
      "db_id": "student_club",
      "question": "How many members attended the \"Women's Soccer\" event?",
      "evidence": "'Women's Soccer' is the event name;",
      "SQL": "SELECT COUNT(T2.link_to_member) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'Women''s Soccer'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["event", "attendance"],
        "columns": [
          "attendance.link_to_member",
          "event.event_id",
          "attendance.link_to_event",
          "event.event_name"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'Women's Soccer' event information\">event</table>",
        "<table purpose=\"Required for attendance information\">attendance</table>",
        "<column purpose=\"calculate: count of members who attended\">attendance.link_to_member</column>",
        "<column purpose=\"join: event.event_id\">event.event_id</column>",
        "<column purpose=\"join: attendance.link_to_event\">attendance.link_to_event</column>",
        "<column purpose=\"filter: 'Women's Soccer' event\">event.event_name</column>",
        "<output_schema purpose=\"count of members who attended\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Women's Soccer' event--><table>event</table>",
        "<!--Required for counting members who attended--><table>attendance</table>",
        "<!--Filter: 'Women's Soccer' event--><column>event.event_name</column>",
        "<!--Join: event.event_id--><column>attendance.link_to_event</column>",
        "<!--Join: attendance.link_to_event--><column>event.event_id</column>",
        "<!--Count: members who attended--><column>attendance.link_to_member</column>",
        "<!--Number of members who attended--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1375,
      "db_id": "student_club",
      "question": "List all the members of the \"School of Applied Sciences, Technology and Education\" department.",
      "evidence": "list all members means to list all the full name; full name refers to first_name, last_name;",
      "SQL": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'School of Applied Sciences, Technology and Education'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["member", "major"],
        "columns": [
          "member.first_name",
          "member.last_name",
          "member.link_to_major",
          "major.major_id",
          "major.department"
        ],
        "output_schema": ["text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains member information including names\">member</table>",
        "<table purpose=\"Contains department information for majors\">major</table>",
        "<column purpose=\"Output: part of full name\">member.first_name</column>",
        "<column purpose=\"Output: part of full name\">member.last_name</column>",
        "<column purpose=\"Join: link member to major\">member.link_to_major</column>",
        "<column purpose=\"Join: link major to member\">major.major_id</column>",
        "<column purpose=\"Filter: 'School of Applied Sciences, Technology and Education' department\">major.department</column>",
        "<output_schema purpose=\"First name of member\">text</output_schema>",
        "<output_schema purpose=\"Last name of member\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for member information--><table>member</table>",
        "<!--Required for department information--><table>major</table>",
        "<!--Join: member.link_to_major--><column>member.link_to_major</column>",
        "<!--Join: major.major_id--><column>major.major_id</column>",
        "<!--Filter: \"School of Applied Sciences, Technology and Education\" department--><column>major.department</column>",
        "<!--Part of full name--><column>member.first_name</column>",
        "<!--Part of full name--><column>member.last_name</column>",
        "<!--Full name of members--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1376,
      "db_id": "student_club",
      "question": "Among all the closed events, which event has the highest spend-to-budget ratio?",
      "evidence": "closed events refers to event_name where status = 'Closed'; highest spend-to budget ratio refers to MAX(DIVIDE(spent, amount))",
      "SQL": "SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.status = 'Closed' ORDER BY T1.spent / T1.amount DESC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["budget", "event"],
        "columns": [
          "event.event_name",
          "budget.link_to_event",
          "event.event_id",
          "event.status",
          "budget.spent",
          "budget.amount"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for budget information\">budget</table>",
        "<table purpose=\"Required for event information\">event</table>",
        "<column purpose=\"output: name of the event with highest spend-to-budget ratio\">event.event_name</column>",
        "<column purpose=\"join: link budget to event\">budget.link_to_event</column>",
        "<column purpose=\"join: link event to budget\">event.event_id</column>",
        "<column purpose=\"filter: 'closed events'\">event.status</column>",
        "<column purpose=\"calculate: numerator of spend-to-budget ratio\">budget.spent</column>",
        "<column purpose=\"calculate: denominator of spend-to-budget ratio\">budget.amount</column>",
        "<output_schema purpose=\"event name is a text field\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'closed events'--><table>event</table>",
        "<!--Required for 'spend-to-budget ratio'--><table>budget</table>",
        "<!--filter: 'closed events'--><column>event.status</column>",
        "<!--join: budget.link_to_event--><column>event.event_id</column>",
        "<!--join: event.event_id--><column>budget.link_to_event</column>",
        "<!--calculate: 'spend-to-budget ratio'--><column>budget.spent</column>",
        "<!--calculate: 'spend-to-budget ratio'--><column>budget.amount</column>",
        "<!--Required for output--><column>event.event_name</column>",
        "<!--event with highest spend-to-budget ratio--><output_schema>text</output_schema>",
        "<!--highest spend-to-budget ratio--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1378,
      "db_id": "student_club",
      "question": "What is the highest amount of budget spend for an event?",
      "evidence": "highest amount of budget spend refers to MAX(spent)",
      "SQL": "SELECT MAX(spent) FROM budget",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["budget"],
        "columns": ["budget.spent"],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'highest amount of budget spend for an event'\">budget</table>",
        "<column purpose=\"calculate: 'highest amount of budget spend'\">budget.spent</column>",
        "<output_schema purpose=\"highest amount of budget spend\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'highest amount of budget spend'--><table>budget</table>",
        "<!--calculate: 'highest amount of budget spend'--><column>budget.spent</column>",
        "<!--highest amount of budget spend--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1380,
      "db_id": "student_club",
      "question": "What is the total amount of money spent for food?",
      "evidence": "total amount of money spent refers to SUM(spent); spent for food refers to category = 'Food'",
      "SQL": "SELECT SUM(spent) FROM budget WHERE category = 'Food'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["budget"],
        "columns": ["budget.spent", "budget.category"],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'total amount of money spent for food'\">budget</table>",
        "<column purpose=\"calculate: 'total amount of money spent'\">budget.spent</column>",
        "<column purpose=\"filter: 'spent for food'\">budget.category</column>",
        "<output_schema purpose=\"total amount of money spent for food\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'total amount of money spent'--><table>budget</table>",
        "<!--filter: 'for food'--><column>budget.category</column>",
        "<!--calculate: 'total amount of money spent'--><column>budget.spent</column>",
        "<!--total amount of money spent for food--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1381,
      "db_id": "student_club",
      "question": "List the name of students that have attended more than 7 events.",
      "evidence": "name of students means the full name; full name refers to first_name, last_name; attended more than 7 events refers to COUNT(link_to_event) > 7",
      "SQL": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member GROUP BY T2.link_to_member HAVING COUNT(T2.link_to_event) > 7",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["member", "attendance"],
        "columns": [
          "member.first_name",
          "member.last_name",
          "member.member_id",
          "attendance.link_to_member",
          "attendance.link_to_event"
        ],
        "output_schema": ["text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains member information, including names\">member</table>",
        "<table purpose=\"Records event attendance for members\">attendance</table>",
        "<column purpose=\"Part of full name, used in output\">member.first_name</column>",
        "<column purpose=\"Part of full name, used in output\">member.last_name</column>",
        "<column purpose=\"join: attendance.link_to_member\">member.member_id</column>",
        "<column purpose=\"join: member.member_id\">attendance.link_to_member</column>",
        "<column purpose=\"calculate: 'attended more than 7 events'\">attendance.link_to_event</column>",
        "<output_schema purpose=\"first name of students\">text</output_schema>",
        "<output_schema purpose=\"last name of students\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'name of students'--><table>member</table>",
        "<!--Required for 'attended more than 7 events'--><table>attendance</table>",
        "<!--first name for full name--><column>member.first_name</column>",
        "<!--last name for full name--><column>member.last_name</column>",
        "<!--join: attendance.link_to_member--><column>member.member_id</column>",
        "<!--join: member.member_id--><column>attendance.link_to_member</column>",
        "<!--count events attended--><column>attendance.link_to_event</column>",
        "<!--full name of students--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1387,
      "db_id": "student_club",
      "question": "Which student has been entrusted to manage the budget for the Yearly Kickoff?",
      "evidence": "name of students means the full name; full name refers to first_name, last_name;'Yearly Kickoff' is an event name;",
      "SQL": "SELECT T4.first_name, T4.last_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget INNER JOIN member AS T4 ON T3.link_to_member = T4.member_id WHERE T1.event_name = 'Yearly Kickoff'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["event", "budget", "expense", "member"],
        "columns": [
          "member.first_name",
          "member.last_name",
          "event.event_id",
          "budget.link_to_event",
          "budget.budget_id",
          "expense.link_to_budget",
          "expense.link_to_member",
          "member.member_id",
          "event.event_name"
        ],
        "output_schema": ["text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to find the 'Yearly Kickoff' event\">event</table>",
        "<table purpose=\"Required to link event to expenses\">budget</table>",
        "<table purpose=\"Required to link budget to member\">expense</table>",
        "<table purpose=\"Required to get student's name\">member</table>",
        "<column purpose=\"output: part of student's full name\">member.first_name</column>",
        "<column purpose=\"output: part of student's full name\">member.last_name</column>",
        "<column purpose=\"join: event to budget\">event.event_id</column>",
        "<column purpose=\"join: event to budget\">budget.link_to_event</column>",
        "<column purpose=\"join: budget to expense\">budget.budget_id</column>",
        "<column purpose=\"join: budget to expense\">expense.link_to_budget</column>",
        "<column purpose=\"join: expense to member\">expense.link_to_member</column>",
        "<column purpose=\"join: expense to member\">member.member_id</column>",
        "<column purpose=\"filter: 'Yearly Kickoff'\">event.event_name</column>",
        "<output_schema purpose=\"student's first name\">text</output_schema>",
        "<output_schema purpose=\"student's last name\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Yearly Kickoff' event--><table>event</table>",
        "<!--Required for budget management--><table>budget</table>",
        "<!--Required for student information--><table>member</table>",
        "<!--Required to link budget to event--><table>expense</table>",
        "<!--Filter: 'Yearly Kickoff'--><column>event.event_name</column>",
        "<!--Link event to budget--><column>event.event_id</column>",
        "<!--Link event to budget--><column>budget.link_to_event</column>",
        "<!--Link budget to expense--><column>budget.budget_id</column>",
        "<!--Link expense to member--><column>expense.link_to_budget</column>",
        "<!--Link expense to member--><column>expense.link_to_member</column>",
        "<!--Student's first name--><column>member.first_name</column>",
        "<!--Student's last name--><column>member.last_name</column>",
        "<!--Student's full name--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1389,
      "db_id": "student_club",
      "question": "Which event has the lowest cost?",
      "evidence": "event refers to event_name; lowest cost means MIN(cost)",
      "SQL": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget ORDER BY T3.cost LIMIT 1",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["event", "budget", "expense"],
        "columns": [
          "event.event_name",
          "event.event_id",
          "budget.link_to_event",
          "budget.budget_id",
          "expense.link_to_budget",
          "expense.cost"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'Which event'\">event</table>",
        "<table purpose=\"Required to link event to expense\">budget</table>",
        "<table purpose=\"Required for 'lowest cost'\">expense</table>",
        "<column purpose=\"output: 'Which event'\">event.event_name</column>",
        "<column purpose=\"join: budget.link_to_event\">event.event_id</column>",
        "<column purpose=\"join: event.event_id\">budget.link_to_event</column>",
        "<column purpose=\"join: expense.link_to_budget\">budget.budget_id</column>",
        "<column purpose=\"join: budget.budget_id\">expense.link_to_budget</column>",
        "<column purpose=\"calculate: 'lowest cost'\">expense.cost</column>",
        "<output_schema purpose=\"event name with lowest cost\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'event' and 'event_name'--><table>event</table>",
        "<!--Required for 'cost'--><table>expense</table>",
        "<!--Join event and expense tables--><table>budget</table>",
        "<!--Event name for output--><column>event.event_name</column>",
        "<!--Join event and budget tables--><column>event.event_id</column>",
        "<!--Join event and budget tables--><column>budget.link_to_event</column>",
        "<!--Join budget and expense tables--><column>budget.budget_id</column>",
        "<!--Join budget and expense tables--><column>expense.link_to_budget</column>",
        "<!--Calculate 'lowest cost'--><column>expense.cost</column>",
        "<!--Event with lowest cost--><output_schema>text</output_schema>",
        "<!--Lowest cost value--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1390,
      "db_id": "student_club",
      "question": "Based on the total cost for all event, what is the percentage of cost for Yearly Kickoff event?",
      "evidence": "percentage = DIVIDE(SUM(cost where event_name = 'Yearly Kickoff'), SUM(cost)) * 100",
      "SQL": "SELECT CAST(SUM(CASE WHEN T1.event_name = 'Yearly Kickoff' THEN T3.cost ELSE 0 END) AS REAL) * 100 / SUM(T3.cost) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["event", "budget", "expense"],
        "columns": [
          "event.event_name",
          "expense.cost",
          "event.event_id",
          "budget.link_to_event",
          "budget.budget_id",
          "expense.link_to_budget"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for event details and filtering\">event</table>",
        "<table purpose=\"Required to link events with expenses\">budget</table>",
        "<table purpose=\"Required for cost information\">expense</table>",
        "<column purpose=\"filter: 'Yearly Kickoff event'\">event.event_name</column>",
        "<column purpose=\"calculate: 'total cost for all event' and 'cost for Yearly Kickoff event'\">expense.cost</column>",
        "<column purpose=\"join: event with budget\">event.event_id</column>",
        "<column purpose=\"join: event with budget\">budget.link_to_event</column>",
        "<column purpose=\"join: budget with expense\">budget.budget_id</column>",
        "<column purpose=\"join: budget with expense\">expense.link_to_budget</column>",
        "<output_schema purpose=\"percentage of cost for Yearly Kickoff event\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'total cost for all event'--><table>expense</table>",
        "<!--Required for 'event_name'--><table>event</table>",
        "<!--Required to join expense and event tables--><table>budget</table>",
        "<!--Join: expense to budget--><column>expense.link_to_budget</column>",
        "<!--Join: budget to event--><column>budget.link_to_event</column>",
        "<!--Join: budget to event--><column>event.event_id</column>",
        "<!--Filter: 'Yearly Kickoff event'--><column>event.event_name</column>",
        "<!--Calculate: 'total cost'--><column>expense.cost</column>",
        "<!--Percentage of cost for Yearly Kickoff event--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1392,
      "db_id": "student_club",
      "question": "Indicate the top source of funds received in September 2019 based on their amount.",
      "evidence": "top source funds refers to MAX(source); September 2019 means date_received BETWEEN '2019-09-01' and '2019-09-30'",
      "SQL": "SELECT source FROM income WHERE date_received BETWEEN '2019-09-01' and '2019-09-30' ORDER BY source DESC LIMIT 1",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["income"],
        "columns": ["income.source", "income.date_received"],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'source of funds received'\">income</table>",
        "<column purpose=\"output: 'top source of funds'\">income.source</column>",
        "<column purpose=\"filter: 'in September 2019'\">income.date_received</column>",
        "<error>income.amount is missing, which is needed to determine the 'top source' based on amount</error>",
        "<output_schema purpose=\"top source of funds\">text</output_schema>",
        "<warning>The proposed SQL query orders by source DESC, which doesn't match the requirement to find the top source based on amount</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'funds received'--><table>income</table>",
        "<!--filter: 'in September 2019'--><column>income.date_received</column>",
        "<!--calculate: 'top source of funds'--><column>income.source</column>",
        "<!--calculate: 'based on their amount'--><column>income.amount</column>",
        "<!--top source of funds--><output_schema>text</output_schema>",
        "<!--amount for verification--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1394,
      "db_id": "student_club",
      "question": "How many members of the Student_Club have major in 'Physics Teaching'?",
      "evidence": "'Physics Teaching' is the major_name;",
      "SQL": "SELECT COUNT(T2.member_id) FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T1.major_name = 'Physics Teaching'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["major", "member"],
        "columns": [
          "member.member_id",
          "major.major_id",
          "member.link_to_major",
          "major.major_name"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to get major information\">major</table>",
        "<table purpose=\"Required to get member information\">member</table>",
        "<column purpose=\"calculate: count of members\">member.member_id</column>",
        "<column purpose=\"join: member.link_to_major\">major.major_id</column>",
        "<column purpose=\"join: major.major_id\">member.link_to_major</column>",
        "<column purpose=\"filter: 'Physics Teaching'\">major.major_name</column>",
        "<output_schema purpose=\"count of members with 'Physics Teaching' major\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for member count--><table>member</table>",
        "<!--Required for major information--><table>major</table>",
        "<!--Join member to major--><column>member.link_to_major</column>",
        "<!--Join major to member--><column>major.major_id</column>",
        "<!--Filter for 'Physics Teaching'--><column>major.major_name</column>",
        "<!--Count of members with 'Physics Teaching' major--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1398,
      "db_id": "student_club",
      "question": "Name the event with the highest amount spent on advertisement.",
      "evidence": "Name of event refers to event_name; highest amount spent on advertisement refers to MAX(spent) where category = 'Advertisement'",
      "SQL": "SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Advertisement' ORDER BY T1.spent DESC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["budget", "event"],
        "columns": [
          "event.event_name",
          "budget.link_to_event",
          "event.event_id",
          "budget.category",
          "budget.spent"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'amount spent on advertisement'\">budget</table>",
        "<table purpose=\"Required for 'Name the event'\">event</table>",
        "<column purpose=\"output: 'Name the event'\">event.event_name</column>",
        "<column purpose=\"join: event.event_id\">budget.link_to_event</column>",
        "<column purpose=\"join: budget.link_to_event\">event.event_id</column>",
        "<column purpose=\"filter: 'spent on advertisement'\">budget.category</column>",
        "<column purpose=\"calculate: 'highest amount spent'\">budget.spent</column>",
        "<output_schema purpose=\"Name of the event\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Name the event'--><table>event</table>",
        "<!--Required for 'highest amount spent on advertisement'--><table>budget</table>",
        "<!--Name of event--><column>event.event_name</column>",
        "<!--Join event and budget tables--><column>event.event_id</column>",
        "<!--Join event and budget tables--><column>budget.link_to_event</column>",
        "<!--Filter for advertisement category--><column>budget.category</column>",
        "<!--Calculate highest amount spent--><column>budget.spent</column>",
        "<!--Name of the event--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1399,
      "db_id": "student_club",
      "question": "Did Maya Mclean attend the 'Women's Soccer' event?",
      "evidence": "Maya Mclean is the full name; full name refers to first_name, last_name; 'Women's Soccer' is an event_name",
      "SQL": "SELECT CASE WHEN T3.event_name = 'Women''s Soccer' THEN 'YES' END AS result FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T1.first_name = 'Maya' AND T1.last_name = 'Mclean'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["member", "attendance", "event"],
        "columns": [
          "event.event_name",
          "member.member_id",
          "attendance.link_to_member",
          "attendance.link_to_event",
          "event.event_id",
          "member.first_name",
          "member.last_name"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to get member information\">member</table>",
        "<table purpose=\"Required to link members to events\">attendance</table>",
        "<table purpose=\"Required to get event information\">event</table>",
        "<column purpose=\"filter: 'Women's Soccer' event\">event.event_name</column>",
        "<column purpose=\"join: attendance.link_to_member\">member.member_id</column>",
        "<column purpose=\"join: member.member_id\">attendance.link_to_member</column>",
        "<column purpose=\"join: event.event_id\">attendance.link_to_event</column>",
        "<column purpose=\"join: attendance.link_to_event\">event.event_id</column>",
        "<column purpose=\"filter: 'Maya'\">member.first_name</column>",
        "<column purpose=\"filter: 'Mclean'\">member.last_name</column>",
        "<output_schema purpose=\"Result of whether Maya Mclean attended the 'Women's Soccer' event\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Maya Mclean'--><table>member</table>",
        "<!--Required for 'Women's Soccer' event--><table>event</table>",
        "<!--Required to link member and event--><table>attendance</table>",
        "<!--filter: 'Maya' first name--><column>member.first_name</column>",
        "<!--filter: 'Mclean' last name--><column>member.last_name</column>",
        "<!--join: member.member_id--><column>attendance.link_to_member</column>",
        "<!--join: attendance.link_to_event--><column>event.event_id</column>",
        "<!--filter: 'Women's Soccer' event--><column>event.event_name</column>",
        "<!--Did Maya Mclean attend the 'Women's Soccer' event?--><output_schema>boolean</output_schema>"
      ]
    },
    {
      "question_id": 1401,
      "db_id": "student_club",
      "question": "Indicate the cost of posters for 'September Speaker' event.",
      "evidence": "'Posters' is the expense description; 'September Speaker' is an event name",
      "SQL": "SELECT T3.cost FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'September Speaker' AND T3.expense_description = 'Posters'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["event", "budget", "expense"],
        "columns": [
          "expense.cost",
          "event.event_id",
          "budget.link_to_event",
          "budget.budget_id",
          "expense.link_to_budget",
          "expense.expense_description",
          "event.event_name"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to find the 'September Speaker' event\">event</table>",
        "<table purpose=\"Required to link event to expense\">budget</table>",
        "<table purpose=\"Required to find the cost of 'Posters'\">expense</table>",
        "<column purpose=\"calculate: 'cost of posters'\">expense.cost</column>",
        "<column purpose=\"join: budget.link_to_event\">event.event_id</column>",
        "<column purpose=\"join: event.event_id\">budget.link_to_event</column>",
        "<column purpose=\"join: expense.link_to_budget\">budget.budget_id</column>",
        "<column purpose=\"join: budget.budget_id\">expense.link_to_budget</column>",
        "<column purpose=\"filter: 'Posters' is the expense description\">expense.expense_description</column>",
        "<column purpose=\"filter: ''September Speaker' is an event name\">event.event_name</column>",
        "<output_schema purpose=\"cost of posters\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'September Speaker' event--><table>event</table>",
        "<!--Required for expense details--><table>expense</table>",
        "<!--Required to link expense to event--><table>budget</table>",
        "<!--Filter: 'September Speaker' event--><column>event.event_name</column>",
        "<!--Join: event to budget--><column>event.event_id</column>",
        "<!--Join: budget to event--><column>budget.link_to_event</column>",
        "<!--Join: budget to expense--><column>budget.budget_id</column>",
        "<!--Join: expense to budget--><column>expense.link_to_budget</column>",
        "<!--Filter: 'Posters' expense description--><column>expense.expense_description</column>",
        "<!--Cost of posters--><column>expense.cost</column>",
        "<!--Cost of posters for 'September Speaker' event--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1403,
      "db_id": "student_club",
      "question": "Indicate the name of the closed event whose cost has exceeded the budget the most.",
      "evidence": "closed events refers to event_name where status = 'Closed'; exceed the budget the most refers to MIN(remaining) where remaining < 0",
      "SQL": "SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T2.event_id = T1.link_to_event WHERE T1.event_status = 'Closed' AND T1.remaining < 0 ORDER BY T1.remaining LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["budget", "event"],
        "columns": [
          "event.event_name",
          "budget.link_to_event",
          "event.event_id",
          "budget.event_status",
          "budget.remaining"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for budget information and status\">budget</table>",
        "<table purpose=\"Required for event name\">event</table>",
        "<column purpose=\"output: 'name of the closed event'\">event.event_name</column>",
        "<column purpose=\"join: event.event_id\">budget.link_to_event</column>",
        "<column purpose=\"join: budget.link_to_event\">event.event_id</column>",
        "<column purpose=\"filter: 'closed event'\">budget.event_status</column>",
        "<column purpose=\"filter and sort: 'cost has exceeded the budget the most'\">budget.remaining</column>",
        "<output_schema purpose=\"event name is a text field\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'closed event'--><table>event</table>",
        "<!--Required for 'cost has exceeded the budget'--><table>budget</table>",
        "<!--filter: 'closed events'--><column>event.status</column>",
        "<!--join: budget.link_to_event--><column>event.event_id</column>",
        "<!--join: event.event_id--><column>budget.link_to_event</column>",
        "<!--calculate: 'exceeded the budget the most'--><column>budget.remaining</column>",
        "<!--'name of the closed event'--><column>event.event_name</column>",
        "<!--name of the closed event--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1404,
      "db_id": "student_club",
      "question": "Identify the type of expenses and their total value approved for 'October Meeting' event.",
      "evidence": "total value refers to SUM(cost); 'October Meeting' is an event name;",
      "SQL": "SELECT T1.type, SUM(T3.cost) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'October Meeting'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["event", "budget", "expense"],
        "columns": [
          "event.type",
          "expense.cost",
          "event.event_id",
          "budget.link_to_event",
          "budget.budget_id",
          "expense.link_to_budget",
          "event.event_name"
        ],
        "output_schema": ["text", "real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'October Meeting' event details\">event</table>",
        "<table purpose=\"Required to link event to expenses\">budget</table>",
        "<table purpose=\"Required for expense details\">expense</table>",
        "<column purpose=\"filter: 'October Meeting' event\">event.event_name</column>",
        "<column purpose=\"join: event to budget\">event.event_id</column>",
        "<column purpose=\"join: event to budget\">budget.link_to_event</column>",
        "<column purpose=\"join: budget to expense\">budget.budget_id</column>",
        "<column purpose=\"join: budget to expense\">expense.link_to_budget</column>",
        "<column purpose=\"calculate: 'total value'\">expense.cost</column>",
        "<error>event.type is not needed for this query. The question asks for the type of expenses, not the type of event.</error>",
        "<error>expense.category should be included to show \"type of expenses\"</error>",
        "<output_schema purpose=\"type of expenses\">text</output_schema>",
        "<output_schema purpose=\"total value of expenses\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'October Meeting' event--><table>event</table>",
        "<!--Required for expense details--><table>expense</table>",
        "<!--Required to link expenses to events--><table>budget</table>",
        "<!--Filter: 'October Meeting' event--><column>event.event_name</column>",
        "<!--Join: event to budget--><column>event.event_id</column>",
        "<!--Join: budget to event--><column>budget.link_to_event</column>",
        "<!--Join: budget to expense--><column>budget.budget_id</column>",
        "<!--Join: expense to budget--><column>expense.link_to_budget</column>",
        "<!--Filter: approved expenses--><column>expense.approved</column>",
        "<!--Calculate: 'total value'--><column>expense.cost</column>",
        "<!--Identify: 'type of expenses'--><column>budget.category</column>",
        "<!--Type of expenses--><output_schema>text</output_schema>",
        "<!--Total value of approved expenses--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1405,
      "db_id": "student_club",
      "question": "Calculate the amount budgeted for 'April Speaker' event. List all the budgeted categories for said event in an ascending order based on their amount budgeted.",
      "evidence": "'April Speaker' is an event name; amount budgeted refers to SUM(amount); budget categories refers to category",
      "SQL": "SELECT T2.category, SUM(T2.amount) FROM event AS T1 JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'April Speaker' GROUP BY T2.category ORDER BY SUM(T2.amount) ASC",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["event", "budget"],
        "columns": [
          "budget.category",
          "budget.amount",
          "event.event_id",
          "budget.link_to_event",
          "event.event_name"
        ],
        "output_schema": ["text", "integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for filtering 'April Speaker' event\">event</table>",
        "<table purpose=\"Required for budget information\">budget</table>",
        "<column purpose=\"output: 'List all the budgeted categories'\">budget.category</column>",
        "<column purpose=\"calculate: 'amount budgeted'\">budget.amount</column>",
        "<column purpose=\"join: budget.link_to_event\">event.event_id</column>",
        "<column purpose=\"join: event.event_id\">budget.link_to_event</column>",
        "<column purpose=\"filter: 'April Speaker' event\">event.event_name</column>",
        "<output_schema purpose=\"budget categories\">text</output_schema>",
        "<output_schema purpose=\"amount budgeted\">integer</output_schema>",
        "<warning>The output schema for the amount budgeted should be 'real' instead of 'integer', as SUM() of a real column results in a real value.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'April Speaker' event details--><table>event</table>",
        "<!--Required for budget information--><table>budget</table>",
        "<!--Join event and budget tables--><column>event.event_id</column>",
        "<!--Join event and budget tables--><column>budget.link_to_event</column>",
        "<!--Filter for 'April Speaker' event--><column>event.event_name</column>",
        "<!--Calculate amount budgeted--><column>budget.amount</column>",
        "<!--List budget categories--><column>budget.category</column>",
        "<!--Total amount budgeted for the event--><output_schema>real</output_schema>",
        "<!--Budget categories for the event--><output_schema>text</output_schema>",
        "<!--Amount budgeted per category--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1409,
      "db_id": "student_club",
      "question": "Mention the total expense used on 8/20/2019.",
      "evidence": "total expense refers SUM(cost) where expense_date = '2019-08-20'",
      "SQL": "SELECT SUM(cost) FROM expense WHERE expense_date = '2019-08-20'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["expense"],
        "columns": ["expense.cost", "expense.expense_date"],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'total expense'\">expense</table>",
        "<column purpose=\"calculate: 'total expense' (SUM)\">expense.cost</column>",
        "<column purpose=\"filter: 'on 8/20/2019'\">expense.expense_date</column>",
        "<output_schema purpose=\"total expense (SUM of cost)\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'total expense'--><table>expense</table>",
        "<!--filter: 'on 8/20/2019'--><column>expense.expense_date</column>",
        "<!--calculate: 'total expense'--><column>expense.cost</column>",
        "<!--total expense used on 8/20/2019--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1410,
      "db_id": "student_club",
      "question": "List out the full name and total cost that member id \"rec4BLdZHS2Blfp4v\" incurred?",
      "evidence": "full name refers to first_name, last name",
      "SQL": "SELECT T1.first_name, T1.last_name, SUM(T2.cost) FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.member_id = 'rec4BLdZHS2Blfp4v'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["member", "expense"],
        "columns": [
          "member.first_name",
          "member.last_name",
          "expense.cost",
          "member.member_id",
          "expense.link_to_member"
        ],
        "output_schema": ["text", "text", "real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for member details\">member</table>",
        "<table purpose=\"Required for expense details\">expense</table>",
        "<column purpose=\"output: part of 'full name'\">member.first_name</column>",
        "<column purpose=\"output: part of 'full name'\">member.last_name</column>",
        "<column purpose=\"calculate: 'total cost'\">expense.cost</column>",
        "<column purpose=\"filter: specific member, join: with expense table\">member.member_id</column>",
        "<column purpose=\"join: with member table\">expense.link_to_member</column>",
        "<output_schema purpose=\"first name of the member\">text</output_schema>",
        "<output_schema purpose=\"last name of the member\">text</output_schema>",
        "<output_schema purpose=\"total cost incurred by the member\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for member details--><table>member</table>",
        "<!--Required for expense details--><table>expense</table>",
        "<!--Filter by member ID--><column>member.member_id</column>",
        "<!--Join member and expense tables--><column>expense.link_to_member</column>",
        "<!--Get first name for full name--><column>member.first_name</column>",
        "<!--Get last name for full name--><column>member.last_name</column>",
        "<!--Calculate total cost--><column>expense.cost</column>",
        "<!--Output full name--><output_schema>text</output_schema>",
        "<!--Output total cost--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1411,
      "db_id": "student_club",
      "question": "State what kind of expenses that Sacha Harrison incurred?",
      "evidence": "kind of expenses refers to expense_description; Sacha Harrison is the full name; full name refers to first_name, last_name;",
      "SQL": "SELECT T2.expense_description FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.first_name = 'Sacha' AND T1.last_name = 'Harrison'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["member", "expense"],
        "columns": [
          "expense.expense_description",
          "member.member_id",
          "expense.link_to_member",
          "member.first_name",
          "member.last_name"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to get member information\">member</table>",
        "<table purpose=\"Required to get expense information\">expense</table>",
        "<column purpose=\"calculate: 'kind of expenses'\">expense.expense_description</column>",
        "<column purpose=\"join: expense.link_to_member\">member.member_id</column>",
        "<column purpose=\"join: member.member_id\">expense.link_to_member</column>",
        "<column purpose=\"filter: 'Sacha Harrison'\">member.first_name</column>",
        "<column purpose=\"filter: 'Sacha Harrison'\">member.last_name</column>",
        "<output_schema purpose=\"expense description is of type text\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'expenses that Sacha Harrison incurred'--><table>expense</table>",
        "<!--Required for 'Sacha Harrison is the full name'--><table>member</table>",
        "<!--join: expense.link_to_member--><column>member.member_id</column>",
        "<!--join: member.member_id--><column>expense.link_to_member</column>",
        "<!--filter: 'Sacha Harrison'--><column>member.first_name</column>",
        "<!--filter: 'Sacha Harrison'--><column>member.last_name</column>",
        "<!--'kind of expenses refers to expense_description'--><column>expense.expense_description</column>",
        "<!--kind of expenses incurred--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1422,
      "db_id": "student_club",
      "question": "State the category of events were held at MU 215.",
      "evidence": "'MU 215' is the location of event; ",
      "SQL": "SELECT DISTINCT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["event", "budget"],
        "columns": [
          "budget.category",
          "event.event_id",
          "budget.link_to_event",
          "event.location"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for event location information\">event</table>",
        "<table purpose=\"Required for event category information\">budget</table>",
        "<column purpose=\"output: 'category of events'\">budget.category</column>",
        "<column purpose=\"join: event.event_id = budget.link_to_event\">event.event_id</column>",
        "<column purpose=\"join: event.event_id = budget.link_to_event\">budget.link_to_event</column>",
        "<column purpose=\"filter: 'held at MU 215'\">event.location</column>",
        "<output_schema purpose=\"category of events\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for event information--><table>event</table>",
        "<!--filter: 'MU 215' is the location of event--><column>event.location</column>",
        "<!--'category of events'--><column>event.type</column>",
        "<!--category of events held at MU 215--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1426,
      "db_id": "student_club",
      "question": "List the last name of members with a major in environmental engineering and include its department and college name.",
      "evidence": "'Environmental Engineering' is the major_name;",
      "SQL": "SELECT T2.last_name, T1.department, T1.college FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.position = 'Member' AND T1.major_name = 'Environmental Engineering'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["major", "member"],
        "columns": [
          "member.last_name",
          "major.department",
          "major.college",
          "major.major_id",
          "member.link_to_major",
          "member.position",
          "major.major_name"
        ],
        "output_schema": ["text", "text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for major information\">major</table>",
        "<table purpose=\"Required for member information\">member</table>",
        "<column purpose=\"output: 'List the last name of members'\">member.last_name</column>",
        "<column purpose=\"output: 'include its department'\">major.department</column>",
        "<column purpose=\"output: 'include its ... college name'\">major.college</column>",
        "<column purpose=\"join: member.link_to_major\">major.major_id</column>",
        "<column purpose=\"join: major.major_id\">member.link_to_major</column>",
        "<column warning=\"This column is not needed for the given question\">member.position</column>",
        "<column purpose=\"filter: ''Environmental Engineering' is the major_name'\">major.major_name</column>",
        "<output_schema purpose=\"last name of members\">text</output_schema>",
        "<output_schema purpose=\"department name\">text</output_schema>",
        "<output_schema purpose=\"college name\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for member information--><table>member</table>",
        "<!--Required for major information--><table>major</table>",
        "<!--Join member and major tables--><column>member.link_to_major</column>",
        "<!--Join member and major tables--><column>major.major_id</column>",
        "<!--Filter for 'Environmental Engineering'--><column>major.major_name</column>",
        "<!--Output: last name of members--><column>member.last_name</column>",
        "<!--Output: department of the major--><column>major.department</column>",
        "<!--Output: college of the major--><column>major.college</column>",
        "<!--Last name of members--><output_schema>text</output_schema>",
        "<!--Department of Environmental Engineering--><output_schema>text</output_schema>",
        "<!--College of Environmental Engineering--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1427,
      "db_id": "student_club",
      "question": "What are the budget category of the events located at MU 215 and a guest speaker type with a 0 budget spent?",
      "evidence": "budget category refers to category; events located at refers to location; type = 'Guest Speaker'; 0 budget spent refers to spent = 0; ",
      "SQL": "SELECT DISTINCT T2.category, T1.type FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215' AND T2.spent = 0 AND T1.type = 'Guest Speaker'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["event", "budget"],
        "columns": [
          "budget.category",
          "event.type",
          "event.event_id",
          "budget.link_to_event",
          "budget.spent",
          "event.location"
        ],
        "output_schema": ["text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for event details such as location and type\">event</table>",
        "<table purpose=\"Required for budget information\">budget</table>",
        "<column purpose=\"output: 'budget category'\">budget.category</column>",
        "<column purpose=\"filter: 'guest speaker type'\">event.type</column>",
        "<column purpose=\"join: event.event_id\">event.event_id</column>",
        "<column purpose=\"join: budget.link_to_event\">budget.link_to_event</column>",
        "<column purpose=\"filter: '0 budget spent'\">budget.spent</column>",
        "<column purpose=\"filter: 'events located at MU 215'\">event.location</column>",
        "<output_schema purpose=\"budget category\">text</output_schema>",
        "<output_schema purpose=\"event type (for verification)\">text</output_schema>",
        "<warning>The output schema for event.type may not be necessary as it's used as a filter condition and not part of the requested output.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'events located at MU 215'--><table>event</table>",
        "<!--Required for budget information--><table>budget</table>",
        "<!--filter: 'events located at MU 215'--><column>event.location</column>",
        "<!--filter: 'type = Guest Speaker'--><column>event.type</column>",
        "<!--join: budget.link_to_event--><column>event.event_id</column>",
        "<!--join: event.event_id--><column>budget.link_to_event</column>",
        "<!--filter: '0 budget spent'--><column>budget.spent</column>",
        "<!--output: 'budget category'--><column>budget.category</column>",
        "<!--budget category of events--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1432,
      "db_id": "student_club",
      "question": "Among the members with t-shirt size of medium, what is the percentage of the amount 50 received by the Student_Club?",
      "evidence": "t_shirt_size = 'Medium' where position = 'Member'; percentage = DIVIDE(COUNT(amount = 50), COUNT(member_id)) * 100",
      "SQL": "SELECT CAST(SUM(CASE WHEN T2.amount = 50 THEN 1.0 ELSE 0 END) AS REAL) * 100 / COUNT(T2.income_id) FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.position = 'Member' AND T1.t_shirt_size = 'Medium'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["member", "income"],
        "columns": [
          "income.amount",
          "income.income_id",
          "member.member_id",
          "income.link_to_member",
          "member.position",
          "member.t_shirt_size"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains member information for filtering and joining\">member</table>",
        "<table purpose=\"Contains income information for calculation\">income</table>",
        "<column purpose=\"filter: 'amount 50', calculate: percentage\">income.amount</column>",
        "<column purpose=\"calculate: total count for percentage\">income.income_id</column>",
        "<column purpose=\"join: income.link_to_member\">member.member_id</column>",
        "<column purpose=\"join: member.member_id\">income.link_to_member</column>",
        "<column purpose=\"filter: 'position = 'Member''\">member.position</column>",
        "<column purpose=\"filter: 't-shirt size of medium'\">member.t_shirt_size</column>",
        "<output_schema purpose=\"percentage calculation result\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for member information--><table>member</table>",
        "<!--Required for income information--><table>income</table>",
        "<!--Filter: 't-shirt size of medium'--><column>member.t_shirt_size</column>",
        "<!--Filter: 'position = 'Member''--><column>member.position</column>",
        "<!--Join: income.link_to_member--><column>member.member_id</column>",
        "<!--Join: member.member_id--><column>income.link_to_member</column>",
        "<!--Filter and count: 'amount 50'--><column>income.amount</column>",
        "<!--Percentage of amount 50 received--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1435,
      "db_id": "student_club",
      "question": "List the names of closed event as \"game\" that was closed from 3/15/2019 to 3/20/2020.",
      "evidence": "name of events refers event_name; game event that was closed refers to type = 'Game' where status = 'Closed'; event_date BETWEEN '2019-03-15' and '2020-03-20'; ",
      "SQL": "SELECT DISTINCT event_name FROM event WHERE type = 'Game' AND date(SUBSTR(event_date, 1, 10)) BETWEEN '2019-03-15' AND '2020-03-20' AND status = 'Closed'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["event"],
        "columns": [
          "event.event_name",
          "event.status",
          "event.type",
          "event.event_date"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for listing closed game events\">event</table>",
        "<column purpose=\"output: 'List the names of closed event'\">event.event_name</column>",
        "<column purpose=\"filter: 'closed event', 'status = Closed'\">event.status</column>",
        "<column purpose=\"filter: 'game event', 'type = Game'\">event.type</column>",
        "<column purpose=\"filter: 'from 3/15/2019 to 3/20/2020'\">event.event_date</column>",
        "<output_schema purpose=\"event names are text\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'names of closed event as \"game\"'--><table>event</table>",
        "<!--filter: 'game event'--><column>event.type</column>",
        "<!--filter: 'that was closed'--><column>event.status</column>",
        "<!--filter: 'from 3/15/2019 to 3/20/2020'--><column>event.event_date</column>",
        "<!--output: 'List the names of closed event'--><column>event.event_name</column>",
        "<!--List the names of closed event--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1457,
      "db_id": "student_club",
      "question": "Give the full name and contact number of members who had to spend more than average on each expense.",
      "evidence": "full name refers to first_name, last_name; contact number refers to phone; had spent more than average on each expense refers to cost > AVG(cost)",
      "SQL": "SELECT DISTINCT T3.first_name, T3.last_name, T3.phone FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T3.member_id = T1.link_to_member WHERE T1.cost > ( SELECT AVG(T1.cost) FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T3.member_id = T1.link_to_member )",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["member", "expense", "budget"],
        "columns": [
          "expense.cost",
          "expense.link_to_member",
          "expense.link_to_budget",
          "budget.budget_id",
          "member.member_id",
          "member.first_name",
          "member.last_name",
          "member.phone"
        ],
        "output_schema": ["text", "text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for member details\">member</table>",
        "<table purpose=\"Required for expense information\">expense</table>",
        "<table purpose=\"Required for linking expenses to budgets\">budget</table>",
        "<column purpose=\"calculate: 'spent more than average on each expense'\">expense.cost</column>",
        "<column purpose=\"join: member.member_id\">expense.link_to_member</column>",
        "<column purpose=\"join: budget.budget_id\">expense.link_to_budget</column>",
        "<column purpose=\"join: expense.link_to_budget\">budget.budget_id</column>",
        "<column purpose=\"join: expense.link_to_member\">member.member_id</column>",
        "<column purpose=\"output: 'full name'\">member.first_name</column>",
        "<column purpose=\"output: 'full name'\">member.last_name</column>",
        "<column purpose=\"output: 'contact number'\">member.phone</column>",
        "<output_schema purpose=\"first name\">text</output_schema>",
        "<output_schema purpose=\"last name\">text</output_schema>",
        "<output_schema purpose=\"phone number\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for member details--><table>member</table>",
        "<!--Required for expense details--><table>expense</table>",
        "<!--Required for 'full name'--><column>member.first_name</column>",
        "<!--Required for 'full name'--><column>member.last_name</column>",
        "<!--Required for 'contact number'--><column>member.phone</column>",
        "<!--Required to join member and expense tables--><column>member.member_id</column>",
        "<!--Required to join member and expense tables--><column>expense.link_to_member</column>",
        "<!--Required to calculate 'spent more than average on each expense'--><column>expense.cost</column>",
        "<!--Output: full name--><output_schema>text</output_schema>",
        "<!--Output: contact number--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1460,
      "db_id": "student_club",
      "question": "Write the full name of the member who spent money for water, veggie tray and supplies and include the cost of it.",
      "evidence": "full name refers to first_name, last name; spent money for refers expense description; expense_description = 'Water, Veggie tray, supplies'",
      "SQL": "SELECT T2.first_name, T2.last_name, T1.cost FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T1.expense_description = 'Water, Veggie tray, supplies'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["expense", "member"],
        "columns": [
          "member.first_name",
          "member.last_name",
          "expense.cost",
          "expense.link_to_member",
          "member.member_id",
          "expense.expense_description"
        ],
        "output_schema": ["text", "text", "real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains expense information, including description and cost\">expense</table>",
        "<table purpose=\"Contains member information, including names\">member</table>",
        "<column purpose=\"Part of 'full name' in the question\">member.first_name</column>",
        "<column purpose=\"Part of 'full name' in the question\">member.last_name</column>",
        "<column purpose=\"'cost of it' in the question\">expense.cost</column>",
        "<column purpose=\"join: expense.link_to_member\">expense.link_to_member</column>",
        "<column purpose=\"join: member.member_id\">member.member_id</column>",
        "<column purpose=\"filter: 'Water, Veggie tray, supplies'\">expense.expense_description</column>",
        "<output_schema purpose=\"first name of the member\">text</output_schema>",
        "<output_schema purpose=\"last name of the member\">text</output_schema>",
        "<output_schema purpose=\"cost of the expense\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for member details--><table>member</table>",
        "<!--Required for expense details--><table>expense</table>",
        "<!--join: expense.link_to_member--><column>member.member_id</column>",
        "<!--join: member.member_id--><column>expense.link_to_member</column>",
        "<!--part of full name--><column>member.first_name</column>",
        "<!--part of full name--><column>member.last_name</column>",
        "<!--filter: 'Water, Veggie tray, supplies'--><column>expense.expense_description</column>",
        "<!--'cost of it'--><column>expense.cost</column>",
        "<!--full name of the member--><output_schema>text</output_schema>",
        "<!--cost of the expense--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1464,
      "db_id": "student_club",
      "question": "Write the full names of students who received funds on the date of 9/9/2019 and include the amount received.",
      "evidence": "full name refers to first_name, last_name, amount of funds received refers to amount, received funds on date refers to date_received",
      "SQL": "SELECT DISTINCT T3.first_name, T3.last_name, T4.amount FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T3.member_id = T2.link_to_member INNER JOIN income AS T4 ON T4.link_to_member = T3.member_id WHERE T4.date_received = '2019-09-09'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["event", "attendance", "member", "income"],
        "columns": [
          "member.first_name",
          "member.last_name",
          "income.amount",
          "event.event_id",
          "attendance.link_to_event",
          "attendance.link_to_member",
          "member.member_id",
          "income.link_to_member",
          "income.date_received"
        ],
        "output_schema": ["text", "text", "integer"]
      },
      "sql_refs_annotated": [
        "<table error=\"This table is not necessary for the query\">event</table>",
        "<table error=\"This table is not necessary for the query\">attendance</table>",
        "<table purpose=\"Required for 'full names of students'\">member</table>",
        "<table purpose=\"Required for 'received funds' and 'amount received'\">income</table>",
        "<column purpose=\"calculate: part of 'full names of students'\">member.first_name</column>",
        "<column purpose=\"calculate: part of 'full names of students'\">member.last_name</column>",
        "<column purpose=\"calculate: 'amount received'\">income.amount</column>",
        "<column error=\"This column is not necessary for the query\">event.event_id</column>",
        "<column error=\"This column is not necessary for the query\">attendance.link_to_event</column>",
        "<column error=\"This column is not necessary for the query\">attendance.link_to_member</column>",
        "<column purpose=\"join: income.link_to_member\">member.member_id</column>",
        "<column purpose=\"join: member.member_id\">income.link_to_member</column>",
        "<column purpose=\"filter: 'received funds on the date of 9/9/2019'\">income.date_received</column>",
        "<output_schema purpose=\"first name of student\">text</output_schema>",
        "<output_schema purpose=\"last name of student\">text</output_schema>",
        "<output_schema purpose=\"amount of funds received\">integer</output_schema>",
        "<error>The query does not require the event and attendance tables. These can be removed along with their associated columns.</error>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'received funds on date' and 'amount received'--><table>income</table>",
        "<!--Required for 'full names of students'--><table>member</table>",
        "<!--filter: 'received funds on date of 9/9/2019'--><column>income.date_received</column>",
        "<!--'amount received'--><column>income.amount</column>",
        "<!--join: member.member_id--><column>income.link_to_member</column>",
        "<!--join: income.link_to_member--><column>member.member_id</column>",
        "<!--'full names of students': first name--><column>member.first_name</column>",
        "<!--'full names of students': last name--><column>member.last_name</column>",
        "<!--'full names of students'--><output_schema>text</output_schema>",
        "<!--'amount received'--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1149,
      "db_id": "thrombosis_prediction",
      "question": "Are there more in-patient or outpatient who were male? What is the deviation in percentage?",
      "evidence": "male refers to SEX = 'M'; in-patient refers to Admission = '+'; outpatient refers to Admission = '-'; percentage = DIVIDE(COUNT(ID) where SEX = 'M' and Admission = '+', COUNT(ID) where SEX\u00a0 = 'M' and Admission = '-')",
      "SQL": "SELECT CAST(SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) FROM Patient WHERE SEX = 'M'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Patient"],
        "columns": ["Patient.Admission", "Patient.SEX"],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains patient admission and sex information\">Patient</table>",
        "<column purpose=\"filter: in-patient ('+') vs outpatient ('-')\">Patient.Admission</column>",
        "<column purpose=\"filter: male patients ('M')\">Patient.SEX</column>",
        "<output_schema purpose=\"percentage deviation between in-patient and outpatient male patients\">real</output_schema>",
        "<error>Patient.ID is missing, which is needed for counting patients</error>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient information--><table>Patient</table>",
        "<!--Filter for male patients--><column>Patient.SEX</column>",
        "<!--Determine in-patient or outpatient status--><column>Patient.Admission</column>",
        "<!--Count patients--><column>Patient.ID</column>",
        "<!--Number of male in-patients--><output_schema>integer</output_schema>",
        "<!--Number of male outpatients--><output_schema>integer</output_schema>",
        "<!--Percentage deviation (in-patients / outpatients)--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1150,
      "db_id": "thrombosis_prediction",
      "question": "What is the percentage of female patient were born after 1930?",
      "evidence": "female refers to Sex = 'F'; patient who were born after 1930 refers to year(Birthday) > '1930'; calculation = DIVIDE(COUNT(ID) where year(Birthday) > '1930' and SEX = 'F'), (COUNT(ID) where SEX = 'F')",
      "SQL": "SELECT CAST(SUM(CASE WHEN STRFTIME('%Y', Birthday) > '1930' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient WHERE SEX = 'F'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Patient"],
        "columns": ["Patient.Birthday", "Patient.SEX"],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains patient demographic information including sex and birthday\">Patient</table>",
        "<column purpose=\"filter: 'born after 1930', calculate: percentage of patients born after 1930\">Patient.Birthday</column>",
        "<column purpose=\"filter: 'female patient'\">Patient.SEX</column>",
        "<output_schema purpose=\"percentage of female patients born after 1930\">real</output_schema>",
        "<warning>Patient.ID is missing, which is needed for accurate counting of patients</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient information--><table>Patient</table>",
        "<!--Filter: 'female refers to Sex = 'F''--><column>Patient.SEX</column>",
        "<!--Filter: 'patient who were born after 1930 refers to year(Birthday) > '1930''--><column>Patient.Birthday</column>",
        "<!--Count: 'COUNT(ID)'--><column>Patient.ID</column>",
        "<!--Percentage of female patients born after 1930--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1152,
      "db_id": "thrombosis_prediction",
      "question": "What is the ratio of outpatient to inpatient followed up treatment among all the 'SLE' diagnosed patient?",
      "evidence": "'SLE' diagnosed patient means Diagnosis = 'SLE'; inpatient refers to Admission = '+'; outpatient refers to Admission = '-'; calculation =  DIVIDE(COUNT(ID) where Diagnosis = 'SLE' and Admission = '+', COUNT(ID) where Diagnosis = 'SLE' and Admission = '-')",
      "SQL": "SELECT SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END) / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) FROM Patient WHERE Diagnosis = 'SLE'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Patient"],
        "columns": ["Patient.Admission", "Patient.Diagnosis"],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information, including 'SLE' diagnosis and admission status\">Patient</table>",
        "<column purpose=\"filter: inpatient ('+') vs outpatient ('-') status\">Patient.Admission</column>",
        "<column purpose=\"filter: 'SLE' diagnosed patients\">Patient.Diagnosis</column>",
        "<output_schema purpose=\"ratio of outpatient to inpatient for 'SLE' patients\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'SLE' diagnosed patients--><table>Patient</table>",
        "<!--Filter for 'SLE' diagnosed patients--><column>Patient.Diagnosis</column>",
        "<!--Determine inpatient/outpatient status--><column>Patient.Admission</column>",
        "<!--Count patients for ratio calculation--><column>Patient.ID</column>",
        "<!--Ratio of outpatient to inpatient--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1153,
      "db_id": "thrombosis_prediction",
      "question": "What is the disease patient '30609' diagnosed with. List all the date of laboratory tests done for this patient.",
      "evidence": "'30609' is the Patient ID; disease means Diagnosis",
      "SQL": "SELECT T1.Diagnosis, T2.Date FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.ID = 30609",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["Patient", "Laboratory"],
        "columns": [
          "Patient.Diagnosis",
          "Laboratory.Date",
          "Patient.ID",
          "Laboratory.ID"
        ],
        "output_schema": ["text", "date"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient diagnosis\">Patient</table>",
        "<table purpose=\"Required for laboratory test dates\">Laboratory</table>",
        "<column purpose=\"retrieve: 'disease patient '30609' diagnosed with'\">Patient.Diagnosis</column>",
        "<column purpose=\"retrieve: 'date of laboratory tests'\">Laboratory.Date</column>",
        "<column purpose=\"filter: 'patient '30609''\">Patient.ID</column>",
        "<column purpose=\"join: Patient.ID\">Laboratory.ID</column>",
        "<output_schema purpose=\"disease diagnosis\">text</output_schema>",
        "<output_schema purpose=\"date of laboratory tests\">date</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient diagnosis--><table>Patient</table>",
        "<!--Required for laboratory test dates--><table>Laboratory</table>",
        "<!--Filter: 'patient '30609''--><column>Patient.ID</column>",
        "<!--Get: 'disease patient '30609' diagnosed with'--><column>Patient.Diagnosis</column>",
        "<!--Filter: 'patient '30609''--><column>Laboratory.ID</column>",
        "<!--Get: 'date of laboratory tests'--><column>Laboratory.Date</column>",
        "<!--Disease diagnosis--><output_schema>text</output_schema>",
        "<!--List of laboratory test dates--><output_schema>date[]</output_schema>"
      ]
    },
    {
      "question_id": 1155,
      "db_id": "thrombosis_prediction",
      "question": "List the patient ID, sex and birthday of patient with LDH beyond normal range.",
      "evidence": "LDH beyond normal range refers to LDH > '500';",
      "SQL": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH > 500",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["Patient", "Laboratory"],
        "columns": [
          "Patient.ID",
          "Patient.SEX",
          "Patient.Birthday",
          "Laboratory.ID",
          "Laboratory.LDH"
        ],
        "output_schema": ["integer", "text", "date"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information\">Patient</table>",
        "<table purpose=\"Required for LDH test results\">Laboratory</table>",
        "<column purpose=\"join: Laboratory.ID, output: 'List the patient ID'\">Patient.ID</column>",
        "<column purpose=\"output: 'List the sex'\">Patient.SEX</column>",
        "<column purpose=\"output: 'List the birthday'\">Patient.Birthday</column>",
        "<column purpose=\"join: Patient.ID\">Laboratory.ID</column>",
        "<column purpose=\"filter: 'LDH beyond normal range refers to LDH > 500'\">Laboratory.LDH</column>",
        "<output_schema purpose=\"patient ID\">integer</output_schema>",
        "<output_schema purpose=\"sex\">text</output_schema>",
        "<output_schema purpose=\"birthday\">date</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient information--><table>Patient</table>",
        "<!--Required for LDH values--><table>Laboratory</table>",
        "<!--Patient ID for output and join--><column>Patient.ID</column>",
        "<!--Patient sex for output--><column>Patient.SEX</column>",
        "<!--Patient birthday for output--><column>Patient.Birthday</column>",
        "<!--Join Laboratory and Patient tables--><column>Laboratory.ID</column>",
        "<!--Filter LDH values--><column>Laboratory.LDH</column>",
        "<!--Patient ID in output--><output_schema>integer</output_schema>",
        "<!--Patient sex in output--><output_schema>text</output_schema>",
        "<!--Patient birthday in output--><output_schema>date</output_schema>"
      ]
    },
    {
      "question_id": 1156,
      "db_id": "thrombosis_prediction",
      "question": "State the ID and age of patient with positive degree of coagulation.",
      "evidence": "age refers to SUBTRACT(year(current_timestamp), year(Birthday)); positive degree of coagulation refers to RVVT = '+';",
      "SQL": "SELECT DISTINCT T1.ID, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.RVVT = '+'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Patient", "Examination"],
        "columns": [
          "Patient.ID",
          "Patient.Birthday",
          "Examination.ID",
          "Examination.RVVT"
        ],
        "output_schema": ["integer", "integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information\">Patient</table>",
        "<table purpose=\"Required for coagulation information\">Examination</table>",
        "<column purpose=\"join: Patient.ID, output: 'ID of patient'\">Patient.ID</column>",
        "<column purpose=\"calculate: 'age of patient'\">Patient.Birthday</column>",
        "<column purpose=\"join: Examination.ID\">Examination.ID</column>",
        "<column purpose=\"filter: 'positive degree of coagulation'\">Examination.RVVT</column>",
        "<output_schema purpose=\"ID of patient\">integer</output_schema>",
        "<output_schema purpose=\"age of patient\">integer</output_schema>",
        "<warning>The age calculation in the SQL query uses STRFTIME, which is specific to SQLite. The proposal should mention this or provide a more generic age calculation method.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'ID' and 'Birthday'--><table>Patient</table>",
        "<!--Required for 'positive degree of coagulation'--><table>Examination</table>",
        "<!--'ID of patient'--><column>Patient.ID</column>",
        "<!--Calculate 'age'--><column>Patient.Birthday</column>",
        "<!--Join Patient and Examination tables--><column>Examination.ID</column>",
        "<!--Filter 'positive degree of coagulation'--><column>Examination.RVVT</column>",
        "<!--Output: ID of patient--><output_schema>integer</output_schema>",
        "<!--Output: age of patient--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1157,
      "db_id": "thrombosis_prediction",
      "question": "For patients with severe degree of thrombosis, list their ID, sex and disease the patient is diagnosed with.",
      "evidence": "severe degree of thrombosis refers to thrombosis = 2; disease refers to diagnosis;",
      "SQL": "SELECT DISTINCT T1.ID, T1.SEX, T1.Diagnosis FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.Thrombosis = 2",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["Patient", "Examination"],
        "columns": [
          "Patient.ID",
          "Patient.SEX",
          "Patient.Diagnosis",
          "Examination.ID",
          "Examination.Thrombosis"
        ],
        "output_schema": ["integer", "text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information\">Patient</table>",
        "<table purpose=\"Required for thrombosis information\">Examination</table>",
        "<column purpose=\"join: Patient.ID, output: 'list their ID'\">Patient.ID</column>",
        "<column purpose=\"output: 'list their sex'\">Patient.SEX</column>",
        "<column purpose=\"output: 'disease the patient is diagnosed with'\">Patient.Diagnosis</column>",
        "<column purpose=\"join: Examination.ID\">Examination.ID</column>",
        "<column purpose=\"filter: 'severe degree of thrombosis refers to thrombosis = 2'\">Examination.Thrombosis</column>",
        "<output_schema purpose=\"ID of patients with severe thrombosis\">integer</output_schema>",
        "<output_schema purpose=\"sex of patients with severe thrombosis\">text</output_schema>",
        "<output_schema purpose=\"diagnosis of patients with severe thrombosis\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'patients with severe degree of thrombosis'--><table>Examination</table>",
        "<!--Required for patient details--><table>Patient</table>",
        "<!--filter: 'severe degree of thrombosis'--><column>Examination.Thrombosis</column>",
        "<!--join: Patient.ID--><column>Examination.ID</column>",
        "<!--join: Examination.ID--><column>Patient.ID</column>",
        "<!--output: 'list their ID'--><column>Patient.ID</column>",
        "<!--output: 'sex'--><column>Patient.SEX</column>",
        "<!--output: 'disease the patient is diagnosed with'--><column>Patient.Diagnosis</column>",
        "<!--patient ID--><output_schema>integer</output_schema>",
        "<!--patient sex--><output_schema>text</output_schema>",
        "<!--patient diagnosis--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1162,
      "db_id": "thrombosis_prediction",
      "question": "How many female patients who came at the hospital in 1997 was immediately followed at the outpatient clinic?",
      "evidence": "female refers to sex = 'F'; came at the hospital in 1997 refers to year(Description) = '1997'; immediately followed at the outpatient clinic refers to Admission = '-'",
      "SQL": "SELECT COUNT(*) FROM Patient WHERE STRFTIME('%Y', Description) = '1997' AND SEX = 'F' AND Admission = '-'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Patient"],
        "columns": ["Patient.Admission", "Patient.SEX", "Patient.Description"],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains patient information including sex, admission status, and visit dates\">Patient</table>",
        "<column purpose=\"filter: 'immediately followed at the outpatient clinic refers to Admission = '-''\">Patient.Admission</column>",
        "<column purpose=\"filter: 'female refers to sex = 'F''\">Patient.SEX</column>",
        "<column purpose=\"filter: 'came at the hospital in 1997 refers to year(Description) = '1997''\">Patient.Description</column>",
        "<output_schema purpose=\"Count of female patients meeting the specified criteria\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient information--><table>Patient</table>",
        "<!--filter: 'female patients'--><column>Patient.SEX</column>",
        "<!--filter: 'came at the hospital in 1997'--><column>Patient.Description</column>",
        "<!--filter: 'immediately followed at the outpatient clinic'--><column>Patient.Admission</column>",
        "<!--count of patients meeting criteria--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1164,
      "db_id": "thrombosis_prediction",
      "question": "How many of the patients with the most serious thrombosis cases examined in 1997 are women?",
      "evidence": "the most serious thrombosis refers to Thrombosis = '1' (the most severe one); women refers to sex = 'F'",
      "SQL": "SELECT  COUNT(*) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F' AND STRFTIME('%Y', T2.\"Examination Date\") = '1997' AND T2.Thrombosis = 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Patient", "Examination"],
        "columns": [
          "Patient.ID",
          "Examination.ID",
          "Examination.Thrombosis",
          "Examination.Examination Date",
          "Patient.SEX"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information, including sex\">Patient</table>",
        "<table purpose=\"Required for examination data, including thrombosis severity and examination date\">Examination</table>",
        "<column purpose=\"join: Patient.ID with Examination.ID\">Patient.ID</column>",
        "<column purpose=\"join: Examination.ID with Patient.ID\">Examination.ID</column>",
        "<column purpose=\"filter: 'the most serious thrombosis refers to Thrombosis = '1' (the most severe one)'\">Examination.Thrombosis</column>",
        "<column purpose=\"filter: 'examined in 1997'\">Examination.Examination Date</column>",
        "<column purpose=\"filter: 'women refers to sex = 'F''\">Patient.SEX</column>",
        "<output_schema purpose=\"count of patients meeting the criteria\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'patients with the most serious thrombosis cases'--><table>Examination</table>",
        "<!--Required for patient gender information--><table>Patient</table>",
        "<!--filter: 'examined in 1997'--><column>Examination.\"Examination Date\"</column>",
        "<!--filter: 'the most serious thrombosis'--><column>Examination.Thrombosis</column>",
        "<!--join: Patient.ID--><column>Examination.ID</column>",
        "<!--join: Examination.ID--><column>Patient.ID</column>",
        "<!--filter: 'women'--><column>Patient.SEX</column>",
        "<!--count of women with most serious thrombosis in 1997--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1166,
      "db_id": "thrombosis_prediction",
      "question": "What are the symptoms observed by the youngest patient to ever did a medical examination? Identify their diagnosis.",
      "evidence": "The larger the birthday value, the younger the person is, and vice versa; symptoms observed refers to the symptoms is not NULL",
      "SQL": "SELECT T2.Symptoms, T1.Diagnosis FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.Symptoms IS NOT NULL ORDER BY T1.Birthday DESC LIMIT 1",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["Patient", "Examination"],
        "columns": [
          "Examination.Symptoms",
          "Patient.Diagnosis",
          "Patient.ID",
          "Examination.ID",
          "Patient.Birthday"
        ],
        "output_schema": ["text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information and birthday\">Patient</table>",
        "<table purpose=\"Required for symptoms and examination data\">Examination</table>",
        "<column purpose=\"filter: 'symptoms observed refers to the symptoms is not NULL'\">Examination.Symptoms</column>",
        "<column purpose=\"Identify their diagnosis\">Patient.Diagnosis</column>",
        "<column purpose=\"join: Patient.ID\">Patient.ID</column>",
        "<column purpose=\"join: Examination.ID\">Examination.ID</column>",
        "<column purpose=\"filter: 'youngest patient'\">Patient.Birthday</column>",
        "<output_schema purpose=\"symptoms observed\">text</output_schema>",
        "<output_schema purpose=\"Identify their diagnosis\">text</output_schema>",
        "<warning>The proposal is missing an explicit mention of the NOT NULL condition for Examination.Symptoms, which is crucial for the query.</warning>",
        "<warning>The proposal doesn't explicitly mention the need to order by Birthday in descending order to find the youngest patient, which is important for the query.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient age and examination data--><table>Patient</table>",
        "<!--Required for symptoms and diagnosis--><table>Examination</table>",
        "<!--Join Patient and Examination tables--><column>Patient.ID</column>",
        "<!--Join Patient and Examination tables--><column>Examination.ID</column>",
        "<!--Find youngest patient--><column>Patient.Birthday</column>",
        "<!--Get symptoms--><column>Examination.Symptoms</column>",
        "<!--Get diagnosis--><column>Examination.Diagnosis</column>",
        "<!--Symptoms observed--><output_schema>text</output_schema>",
        "<!--Diagnosis of the youngest patient--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1168,
      "db_id": "thrombosis_prediction",
      "question": "The oldest SJS patient's medical laboratory work was completed on what date, and what age was the patient when they initially arrived at the hospital?",
      "evidence": "The larger the birthday value, the younger the person is, and vice versa; 'SJS' refers to diagnosis; (SUBTRACT(year(\"First Date\")), year(Birthday)); age of the patients when they initially arrived at the hospital refers to year(Birthday)",
      "SQL": "SELECT T1.Date, STRFTIME('%Y', T2.\"First Date\") - STRFTIME('%Y', T2.Birthday),T2.Birthday FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T2.Diagnosis = 'SJS' AND T2.Birthday IS NOT NULL ORDER BY T2.Birthday ASC LIMIT 1",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["Laboratory", "Patient"],
        "columns": [
          "Laboratory.Date",
          "Patient.First Date",
          "Patient.Birthday",
          "Laboratory.ID",
          "Patient.ID",
          "Patient.Diagnosis"
        ],
        "output_schema": ["text", "integer", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains laboratory test dates for patients\">Laboratory</table>",
        "<table purpose=\"Contains patient information including diagnosis and birth date\">Patient</table>",
        "<column purpose=\"To find the date of medical laboratory work\">Laboratory.Date</column>",
        "<column purpose=\"To calculate the age when the patient first arrived at the hospital\">Patient.First Date</column>",
        "<column purpose=\"To identify the oldest SJS patient and calculate age\">Patient.Birthday</column>",
        "<column purpose=\"join: Patient.ID\">Laboratory.ID</column>",
        "<column purpose=\"join: Laboratory.ID\">Patient.ID</column>",
        "<column purpose=\"filter: 'SJS' refers to diagnosis\">Patient.Diagnosis</column>",
        "<output_schema purpose=\"Date of medical laboratory work\">text</output_schema>",
        "<output_schema purpose=\"Age when patient first arrived at the hospital\">integer</output_schema>",
        "<output_schema purpose=\"Patient's birthday\">text</output_schema>",
        "<warning>The output schema for Laboratory.Date and Patient.Birthday should be 'date' instead of 'text' for more accurate date handling.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'SJS patient'--><table>Patient</table>",
        "<!--Required for 'medical laboratory work'--><table>Laboratory</table>",
        "<!--Filter: 'SJS patient'--><column>Patient.Diagnosis</column>",
        "<!--Join: Patient.ID--><column>Laboratory.ID</column>",
        "<!--Join: Laboratory.ID--><column>Patient.ID</column>",
        "<!--Find: 'oldest patient'--><column>Patient.Birthday</column>",
        "<!--Calculate: 'age when initially arrived at the hospital'--><column>Patient.\"First Date\"</column>",
        "<!--Find: 'medical laboratory work was completed on what date'--><column>Laboratory.Date</column>",
        "<!--Date of oldest SJS patient's medical laboratory work--><output_schema>date</output_schema>",
        "<!--Age of oldest SJS patient when initially arrived at the hospital--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1169,
      "db_id": "thrombosis_prediction",
      "question": "What is the ratio of male to female patients among all those with abnormal uric acid counts?",
      "evidence": "male refers to SEX = 'M'; female refers to SEX = 'F'; abnormal uric acid refers to UA < = '8.0' where SEX = 'M', UA < = '6.5' where SEX = 'F'; calculation = DIVIDE(SUM(UA <= '8.0' and SEX = 'M'), SUM(UA <= '6.5 and SEX = 'F'))",
      "SQL": "SELECT CAST(SUM(CASE WHEN T2.UA <= 8.0 AND T1.SEX = 'M' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T2.UA <= 6.5 AND T1.SEX = 'F' THEN 1 ELSE 0 END) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["Patient", "Laboratory"],
        "columns": [
          "Patient.SEX",
          "Laboratory.UA",
          "Patient.ID",
          "Laboratory.ID"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient sex information\">Patient</table>",
        "<table purpose=\"Required for uric acid (UA) measurements\">Laboratory</table>",
        "<column purpose=\"filter: 'male refers to SEX = 'M'; female refers to SEX = 'F''\">Patient.SEX</column>",
        "<column purpose=\"filter: 'abnormal uric acid refers to UA &lt;= '8.0' where SEX = 'M', UA &lt;= '6.5' where SEX = 'F''\">Laboratory.UA</column>",
        "<column purpose=\"join: Patient.ID\">Patient.ID</column>",
        "<column purpose=\"join: Laboratory.ID\">Laboratory.ID</column>",
        "<output_schema purpose=\"ratio of male to female patients with abnormal uric acid counts\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient sex information--><table>Patient</table>",
        "<!--Required for uric acid (UA) measurements--><table>Laboratory</table>",
        "<!--Join Patient and Laboratory tables--><column>Patient.ID</column>",
        "<!--Join Patient and Laboratory tables--><column>Laboratory.ID</column>",
        "<!--Filter for male patients--><column>Patient.SEX</column>",
        "<!--Filter for female patients--><column>Patient.SEX</column>",
        "<!--Calculate abnormal uric acid for both sexes--><column>Laboratory.UA</column>",
        "<!--Ratio of male to female patients with abnormal uric acid--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1171,
      "db_id": "thrombosis_prediction",
      "question": "How many underage patients were examined during the course of the three-year period from 1990 to 1993?",
      "evidence": "underage patients refers to year(Birthday) < 18; three-year period from 1990 to 1993 refers to year(\"Examination Date\") between '1990' and '1993'",
      "SQL": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T2.\"Examination Date\") BETWEEN '1990' AND '1993' AND STRFTIME('%Y', T2.\"Examination Date\") - STRFTIME('%Y', T1.Birthday) < 18",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["Patient", "Examination"],
        "columns": [
          "Patient.ID",
          "Examination.ID",
          "Examination.Examination Date",
          "Patient.Birthday"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information, including Birthday\">Patient</table>",
        "<table purpose=\"Required for examination information, including Examination Date\">Examination</table>",
        "<column purpose=\"join: Patient.ID with Examination.ID\">Patient.ID</column>",
        "<column purpose=\"join: Examination.ID with Patient.ID\">Examination.ID</column>",
        "<column purpose=\"filter: 'three-year period from 1990 to 1993'\">Examination.\"Examination Date\"</column>",
        "<column purpose=\"calculate: 'underage patients'\">Patient.Birthday</column>",
        "<output_schema purpose=\"count of underage patients examined during the specified period\">integer</output_schema>",
        "<warning>The proposal doesn't explicitly mention the need for a COUNT() function, which is necessary to answer \"How many underage patients...\"</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient information--><table>Patient</table>",
        "<!--Required for examination dates--><table>Examination</table>",
        "<!--Required to calculate age--><column>Patient.Birthday</column>",
        "<!--Required to filter examination period--><column>Examination.\"Examination Date\"</column>",
        "<!--Required to join Patient and Examination tables--><column>Patient.ID</column>",
        "<!--Required to join Patient and Examination tables--><column>Examination.ID</column>",
        "<!--Count of underage patients examined between 1990 and 1993--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1175,
      "db_id": "thrombosis_prediction",
      "question": "How old was the patient who had the highest hemoglobin count at the time of the examination, and what is the doctor's diagnosis?",
      "evidence": "How old the patient refers to SUBTRACT(year(\"Examination Date\"), year(Birthday)); the highest hemoglobin count refers to MAX(HGB)",
      "SQL": "SELECT STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday), T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID ORDER BY T2.HGB DESC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Patient", "Laboratory"],
        "columns": [
          "Laboratory.Date",
          "Patient.Birthday",
          "Patient.Diagnosis",
          "Patient.ID",
          "Laboratory.ID",
          "Laboratory.HGB"
        ],
        "output_schema": ["integer", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information (Birthday and Diagnosis)\">Patient</table>",
        "<table purpose=\"Required for laboratory test results (HGB)\">Laboratory</table>",
        "<column purpose=\"calculate: age at examination\">Laboratory.Date</column>",
        "<column purpose=\"calculate: age at examination\">Patient.Birthday</column>",
        "<column purpose=\"output: doctor's diagnosis\">Patient.Diagnosis</column>",
        "<column purpose=\"join: Patient.ID\">Patient.ID</column>",
        "<column purpose=\"join: Laboratory.ID\">Laboratory.ID</column>",
        "<column purpose=\"filter: highest hemoglobin count\">Laboratory.HGB</column>",
        "<output_schema purpose=\"age of the patient\">integer</output_schema>",
        "<output_schema purpose=\"doctor's diagnosis\">text</output_schema>",
        "<error>The proposal is missing the Examination table, which is required to get the \"Examination Date\" as specified in the question.</error>",
        "<error>The proposal should include the Examination.ID column for joining with Patient.ID.</error>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient age calculation--><table>Patient</table>",
        "<!--Required for hemoglobin count and examination date--><table>Laboratory</table>",
        "<!--Required for doctor's diagnosis--><table>Examination</table>",
        "<!--Calculate patient age: SUBTRACT(year(\"Examination Date\"), year(Birthday))--><column>Patient.Birthday</column>",
        "<!--Calculate patient age: SUBTRACT(year(\"Examination Date\"), year(Birthday))--><column>Laboratory.Date</column>",
        "<!--Find highest hemoglobin count: MAX(HGB)--><column>Laboratory.HGB</column>",
        "<!--Join Laboratory and Patient tables--><column>Laboratory.ID</column>",
        "<!--Join Laboratory and Patient tables--><column>Patient.ID</column>",
        "<!--Join Examination and Patient tables--><column>Examination.ID</column>",
        "<!--Get doctor's diagnosis--><column>Examination.Diagnosis</column>",
        "<!--Patient age at time of examination--><output_schema>integer</output_schema>",
        "<!--Doctor's diagnosis--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1179,
      "db_id": "thrombosis_prediction",
      "question": "For the patient who was diagnosed with SLE on 1994/2/19, what was his/her anti-Cardiolipin antibody concentration status on 1993/11/12?",
      "evidence": "diagnosed with SLE refers to Diagnosis = 'SLE'; 1994/2/19 refers to Description = '1994-02-19'; anti-Cardiolipin refers to aCL IgM; 1993/11/12 refers to Examination Date = '1993/11/12'",
      "SQL": "SELECT \"aCL IgA\", \"aCL IgG\", \"aCL IgM\" FROM Examination WHERE ID IN ( SELECT ID FROM Patient WHERE Diagnosis = 'SLE' AND Description = '1994-02-19' ) AND \"Examination Date\" = '1993-11-12'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Examination", "Patient"],
        "columns": [
          "Patient.ID",
          "Patient.Description",
          "Patient.Diagnosis",
          "Examination.aCL IgA",
          "Examination.aCL IgG",
          "Examination.aCL IgM",
          "Examination.Examination Date",
          "Examination.ID"
        ],
        "output_schema": ["integer", "real", "real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains anti-Cardiolipin antibody concentration data\">Examination</table>",
        "<table purpose=\"Contains patient diagnosis and description date\">Patient</table>",
        "<column purpose=\"join: Examination.ID\">Patient.ID</column>",
        "<column purpose=\"filter: '1994/2/19 refers to Description = '1994-02-19''\">Patient.Description</column>",
        "<column purpose=\"filter: 'diagnosed with SLE refers to Diagnosis = 'SLE''\">Patient.Diagnosis</column>",
        "<column purpose=\"output: part of 'anti-Cardiolipin antibody concentration status'\">Examination.aCL IgA</column>",
        "<column purpose=\"output: part of 'anti-Cardiolipin antibody concentration status'\">Examination.aCL IgG</column>",
        "<column purpose=\"output: 'anti-Cardiolipin refers to aCL IgM'\">Examination.aCL IgM</column>",
        "<column purpose=\"filter: '1993/11/12 refers to Examination Date = '1993/11/12''\">Examination.Examination Date</column>",
        "<column purpose=\"join: Patient.ID\">Examination.ID</column>",
        "<output_schema purpose=\"aCL IgA result\">integer</output_schema>",
        "<output_schema purpose=\"aCL IgG result\">real</output_schema>",
        "<output_schema purpose=\"aCL IgM result\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient diagnosis and description date--><table>Patient</table>",
        "<!--Required for anti-Cardiolipin antibody concentration and examination date--><table>Examination</table>",
        "<!--Filter: 'diagnosed with SLE'--><column>Patient.Diagnosis</column>",
        "<!--Filter: 'on 1994/2/19'--><column>Patient.Description</column>",
        "<!--Join: Patient.ID--><column>Patient.ID</column>",
        "<!--Join: Examination.ID--><column>Examination.ID</column>",
        "<!--Filter: 'on 1993/11/12'--><column>Examination.\"Examination Date\"</column>",
        "<!--Retrieve: 'anti-Cardiolipin antibody concentration'--><column>Examination.\"aCL IgM\"</column>",
        "<!--anti-Cardiolipin antibody concentration status--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1185,
      "db_id": "thrombosis_prediction",
      "question": "For the patient who was born on 1959/2/18, what is the decrease rate for his/her total cholesterol from November to December in 1981?",
      "evidence": "born on 1959/2/18 refers to Birthday = '1959-02-18'; calculation = DIVISION(SUBTRACT(SUM(Birthday = '1959-02-18' and Date like '1981-11-%' THEN \"T-CHO\"), SUM(Birthday = '1959-02-18' and Date like '1981-12-%' THEN \"T-CHO\")), SUM(Birthday = '1959-02-18' and Date like '1981-12-%' THEN \"T-CHO\"))",
      "SQL": "SELECT CAST((SUM(CASE WHEN T2.Date LIKE '1981-11-%' THEN T2.\"T-CHO\" ELSE 0 END) - SUM(CASE WHEN T2.Date LIKE '1981-12-%' THEN T2.\"T-CHO\" ELSE 0 END)) AS REAL) / SUM(CASE WHEN T2.Date LIKE '1981-12-%' THEN T2.\"T-CHO\" ELSE 0 END) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Birthday = '1959-02-18'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["Patient", "Laboratory"],
        "columns": [
          "Laboratory.Date",
          "Laboratory.T-CHO",
          "Patient.ID",
          "Laboratory.ID",
          "Patient.Birthday"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information\">Patient</table>",
        "<table purpose=\"Required for laboratory test results\">Laboratory</table>",
        "<column purpose=\"filter: 'from November to December in 1981'\">Laboratory.Date</column>",
        "<column purpose=\"calculate: 'decrease rate for his/her total cholesterol'\">Laboratory.\"T-CHO\"</column>",
        "<column purpose=\"join: Laboratory.ID\">Patient.ID</column>",
        "<column purpose=\"join: Patient.ID\">Laboratory.ID</column>",
        "<column purpose=\"filter: 'patient who was born on 1959/2/18'\">Patient.Birthday</column>",
        "<output_schema purpose=\"decrease rate calculation result\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient identification--><table>Patient</table>",
        "<!--Required for laboratory test results--><table>Laboratory</table>",
        "<!--Filter: 'born on 1959/2/18'--><column>Patient.Birthday</column>",
        "<!--Join: Patient.ID--><column>Laboratory.ID</column>",
        "<!--Join: Laboratory.ID--><column>Patient.ID</column>",
        "<!--Filter: 'from November to December in 1981'--><column>Laboratory.Date</column>",
        "<!--Calculate: 'total cholesterol'--><column>Laboratory.\"T-CHO\"</column>",
        "<!--Decrease rate of total cholesterol--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1187,
      "db_id": "thrombosis_prediction",
      "question": "How many patients who were examined between 1987/7/6 and 1996/1/31 had a GPT level greater than 30 and an ALB level less than 4? List them by their ID.",
      "evidence": "examined between 1987/7/6 and 1996/1/31 refers to Date BETWEEN '1987-07-06' AND '1996-01-31'; GPT level greater than 30 refers to GPT > 30; ALB level less than 4 ALB < 4",
      "SQL": "SELECT DISTINCT ID FROM Laboratory WHERE Date BETWEEN '1987-07-06' AND '1996-01-31' AND GPT > 30 AND ALB < 4",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Laboratory"],
        "columns": [
          "Laboratory.ID",
          "Laboratory.ALB",
          "Laboratory.Date",
          "Laboratory.GPT"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient laboratory test data\">Laboratory</table>",
        "<column purpose=\"output: List patients by their ID\">Laboratory.ID</column>",
        "<column purpose=\"filter: ALB level less than 4\">Laboratory.ALB</column>",
        "<column purpose=\"filter: examined between 1987/7/6 and 1996/1/31\">Laboratory.Date</column>",
        "<column purpose=\"filter: GPT level greater than 30\">Laboratory.GPT</column>",
        "<output_schema purpose=\"List patients by their ID\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient information--><table>Patient</table>",
        "<!--Required for laboratory test results--><table>Laboratory</table>",
        "<!--Join Patient and Laboratory tables--><column>Patient.ID</column>",
        "<!--Join Patient and Laboratory tables--><column>Laboratory.ID</column>",
        "<!--Filter date range: 'examined between 1987/7/6 and 1996/1/31'--><column>Laboratory.Date</column>",
        "<!--Filter: 'GPT level greater than 30'--><column>Laboratory.GPT</column>",
        "<!--Filter: 'ALB level less than 4'--><column>Laboratory.ALB</column>",
        "<!--List patients 'by their ID'--><output_schema>integer</output_schema>",
        "<!--Count of patients meeting criteria--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1189,
      "db_id": "thrombosis_prediction",
      "question": "What number of patients with a degree of thrombosis level 2 and ANA pattern of only S, have a level of anti-Cardiolip in antibody (IgM) 20% higher than average?",
      "evidence": "thrombosis level 2 refers to Thrombosis = 2; ANA pattern of only S refers to ANA = 'S'; average anti-Cardiolip in antibody (IgM) refers to AVG(\"aCL IgM\"); calculation = MULTIPLY(AVG + AVG, 0.2)",
      "SQL": "SELECT COUNT(*) FROM Examination WHERE Thrombosis = 2 AND \"ANA Pattern\" = 'S' AND \"aCL IgM\" > (SELECT AVG(\"aCL IgM\") * 1.2 FROM Examination WHERE Thrombosis = 2 AND \"ANA Pattern\" = 'S')",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["Examination", "Examination"],
        "columns": [
          "Examination.aCL IgM",
          "Examination.ANA Pattern",
          "Examination.Thrombosis"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for all data related to the question\">Examination</table>",
        "<table warning=\"Duplicate table reference\">Examination</table>",
        "<column purpose=\"calculate: '20% higher than average', filter: 'level of anti-Cardiolip in antibody (IgM)'\">Examination.aCL IgM</column>",
        "<column purpose=\"filter: 'ANA pattern of only S'\">Examination.ANA Pattern</column>",
        "<column purpose=\"filter: 'degree of thrombosis level 2'\">Examination.Thrombosis</column>",
        "<output_schema purpose=\"count of patients meeting the criteria\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'degree of thrombosis level 2'--><table>Examination</table>",
        "<!--Required for 'ANA pattern of only S'--><table>Examination</table>",
        "<!--Required for 'anti-Cardiolip in antibody (IgM)'--><table>Examination</table>",
        "<!--Filter: 'degree of thrombosis level 2'--><column>Examination.Thrombosis</column>",
        "<!--Filter: 'ANA pattern of only S'--><column>Examination.\"ANA Pattern\"</column>",
        "<!--Calculate: 'level of anti-Cardiolip in antibody (IgM)'--><column>Examination.\"aCL IgM\"</column>",
        "<!--Count of patients meeting criteria--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1192,
      "db_id": "thrombosis_prediction",
      "question": "List all patients who were followed up at the outpatient clinic who underwent a laboratory test in October 1991 and had a total blood bilirubin level within the normal range.",
      "evidence": "followed up at the outpatient clinic refers to Admission = '-'; laboratory test in April 1981 refers to Date like '1991-10%'; blood bilirubin level within the normal range refers to T-BIL < 2.0; ",
      "SQL": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Admission = '-' AND T2.\"T-BIL\" < 2.0 AND T2.Date LIKE '1991-10-%'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["Patient", "Laboratory"],
        "columns": [
          "Patient.ID",
          "Laboratory.ID",
          "Laboratory.Date",
          "Laboratory.T-BIL",
          "Patient.Admission"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information and outpatient status\">Patient</table>",
        "<table purpose=\"Required for laboratory test results\">Laboratory</table>",
        "<column purpose=\"join: Laboratory.ID, output: 'List all patients'\">Patient.ID</column>",
        "<column purpose=\"join: Patient.ID\">Laboratory.ID</column>",
        "<column purpose=\"filter: 'laboratory test in October 1991'\">Laboratory.Date</column>",
        "<column purpose=\"filter: 'total blood bilirubin level within the normal range'\">Laboratory.T-BIL</column>",
        "<column purpose=\"filter: 'followed up at the outpatient clinic'\">Patient.Admission</column>",
        "<output_schema purpose=\"patient IDs\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient information and outpatient status--><table>Patient</table>",
        "<!--Required for laboratory test data--><table>Laboratory</table>",
        "<!--Filter: \"followed up at the outpatient clinic\"--><column>Patient.Admission</column>",
        "<!--Join: Patient.ID--><column>Patient.ID</column>",
        "<!--Join: Laboratory.ID--><column>Laboratory.ID</column>",
        "<!--Filter: \"laboratory test in October 1991\"--><column>Laboratory.Date</column>",
        "<!--Filter: \"blood bilirubin level within the normal range\"--><column>Laboratory.\"T-BIL\"</column>",
        "<!--List all patients--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1195,
      "db_id": "thrombosis_prediction",
      "question": "What is the average blood albumin level for female patients with a PLT greater than 400 who have been diagnosed with SLE?",
      "evidence": "average blood albumin level refers to AVG(ALB); female refers to SEX = 'F'; PLT greater than 400 refers to PLT > 400; diagnosed with SLE refers to Diagnosis= 'SLE'",
      "SQL": "SELECT AVG(T2.ALB) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.PLT > 400 AND T1.Diagnosis = 'SLE' AND T1.SEX = 'F'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Patient", "Laboratory"],
        "columns": [
          "Laboratory.ALB",
          "Patient.ID",
          "Laboratory.ID",
          "Laboratory.PLT",
          "Patient.Diagnosis",
          "Patient.SEX"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information (sex and diagnosis)\">Patient</table>",
        "<table purpose=\"Required for laboratory test results (albumin and platelet count)\">Laboratory</table>",
        "<column purpose=\"calculate: 'average blood albumin level'\">Laboratory.ALB</column>",
        "<column purpose=\"join: Patient.ID\">Patient.ID</column>",
        "<column purpose=\"join: Laboratory.ID\">Laboratory.ID</column>",
        "<column purpose=\"filter: 'PLT greater than 400'\">Laboratory.PLT</column>",
        "<column purpose=\"filter: 'diagnosed with SLE'\">Patient.Diagnosis</column>",
        "<column purpose=\"filter: 'female patients'\">Patient.SEX</column>",
        "<output_schema purpose=\"average blood albumin level\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient sex and diagnosis--><table>Patient</table>",
        "<!--Required for laboratory test results--><table>Laboratory</table>",
        "<!--Filter: 'female patients'--><column>Patient.SEX</column>",
        "<!--Filter: 'diagnosed with SLE'--><column>Patient.Diagnosis</column>",
        "<!--Join: Patient.ID--><column>Laboratory.ID</column>",
        "<!--Filter: 'PLT greater than 400'--><column>Laboratory.PLT</column>",
        "<!--Calculate: 'average blood albumin level'--><column>Laboratory.ALB</column>",
        "<!--Join: Laboratory.ID--><column>Patient.ID</column>",
        "<!--Average blood albumin level for specified patients--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1198,
      "db_id": "thrombosis_prediction",
      "question": "How many female patients were given an APS diagnosis?",
      "evidence": "female refers to SEX = 'F'; APS diagnosis refers to Diagnosis='APS'",
      "SQL": "SELECT COUNT(ID) FROM Patient WHERE SEX = 'F' AND Diagnosis = 'APS'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["Patient"],
        "columns": ["Patient.ID", "Patient.Diagnosis", "Patient.SEX"],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information, including sex and diagnosis\">Patient</table>",
        "<column purpose=\"Used for counting unique patients\">Patient.ID</column>",
        "<column purpose=\"filter: 'APS diagnosis'\">Patient.Diagnosis</column>",
        "<column purpose=\"filter: 'female patients'\">Patient.SEX</column>",
        "<output_schema purpose=\"Count of female patients with APS diagnosis\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient information--><table>Patient</table>",
        "<!--Required for diagnosis information--><table>Examination</table>",
        "<!--filter: 'female patients'--><column>Patient.SEX</column>",
        "<!--filter: 'APS diagnosis'--><column>Examination.Diagnosis</column>",
        "<!--join: Patient.ID--><column>Patient.ID</column>",
        "<!--join: Examination.ID--><column>Examination.ID</column>",
        "<!--count of female patients with APS diagnosis--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1201,
      "db_id": "thrombosis_prediction",
      "question": "What percentage of patients who were born in 1980 and were diagnosed with RA are women?",
      "evidence": "born in 1980 refers to YEAR(BIRTHDAY) = '1980'; 'RA' refers to Diagnosis='RA' ; women refers to SEX = 'F'; calculation = DIVIDE(SUM(SEX = 'F'), COUNT(SEX)) * 100",
      "SQL": "SELECT CAST(SUM(CASE WHEN SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) FROM Patient WHERE Diagnosis = 'RA' AND STRFTIME('%Y', Birthday) = '1980'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Patient"],
        "columns": [
          "Patient.SEX",
          "Patient.ID",
          "Patient.Diagnosis",
          "Patient.Birthday"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information, including sex, diagnosis, and birthday\">Patient</table>",
        "<column purpose=\"filter: 'women refers to SEX = 'F''; calculate: percentage of women\">Patient.SEX</column>",
        "<column purpose=\"count: total number of patients for percentage calculation\">Patient.ID</column>",
        "<column purpose=\"filter: ''RA' refers to Diagnosis='RA''\">Patient.Diagnosis</column>",
        "<column purpose=\"filter: 'born in 1980 refers to YEAR(BIRTHDAY) = '1980''\">Patient.Birthday</column>",
        "<output_schema purpose=\"percentage calculation result\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient information--><table>Patient</table>",
        "<!--Filter: \"born in 1980\"--><column>Patient.Birthday</column>",
        "<!--Filter: \"diagnosed with RA\"--><column>Patient.Diagnosis</column>",
        "<!--Filter: \"women\"--><column>Patient.SEX</column>",
        "<!--Percentage of patients who meet criteria--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1205,
      "db_id": "thrombosis_prediction",
      "question": "Was the patient with the number 57266's uric acid within a normal range?",
      "evidence": "uric acid within a normal range refers to UA > 8.0 and SEX = 'M'OR UA > 6.5 and SEX = 'F'",
      "SQL": "SELECT CASE WHEN (T1.SEX = 'F' AND T2.UA > 6.5) OR (T1.SEX = 'M' AND T2.UA > 8.0) THEN true ELSE false END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.ID = 57266",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Patient", "Laboratory"],
        "columns": [
          "Patient.SEX",
          "Laboratory.UA",
          "Patient.ID",
          "Laboratory.ID"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient sex information\">Patient</table>",
        "<table purpose=\"Required for uric acid (UA) information\">Laboratory</table>",
        "<column purpose=\"filter: 'SEX = M or SEX = F' for normal range determination\">Patient.SEX</column>",
        "<column purpose=\"calculate: 'uric acid within a normal range'\">Laboratory.UA</column>",
        "<column purpose=\"filter: 'patient with the number 57266', join: Laboratory.ID\">Patient.ID</column>",
        "<column purpose=\"join: Patient.ID\">Laboratory.ID</column>",
        "<output_schema error=\"The output should be a boolean (true/false) indicating whether the UA is within normal range, not an integer\">boolean</output_schema>",
        "<warning>The proposal is missing a date column from the Laboratory table. Since a patient may have multiple UA measurements over time, you might want to consider the most recent measurement or specify a date range.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient information--><table>Patient</table>",
        "<!--Required for laboratory test results--><table>Laboratory</table>",
        "<!--Filter for specific patient--><column>Patient.ID</column>",
        "<!--Join Patient and Laboratory tables--><column>Laboratory.ID</column>",
        "<!--Required for determining normal range--><column>Patient.SEX</column>",
        "<!--Required for uric acid value--><column>Laboratory.UA</column>",
        "<!--Result of whether uric acid is within normal range--><output_schema>boolean</output_schema>"
      ]
    },
    {
      "question_id": 1208,
      "db_id": "thrombosis_prediction",
      "question": "Provide IDs for male patients with ALT glutamic pylvic transaminase (GPT) that have history of ALT glutamic pylvic transaminase (GPT) exceed the normal range.",
      "evidence": "male refers to SEX = 'M'; ALT glutamic pylvic transaminase (GPT) exceed the normal range refers to GPT > = 60",
      "SQL": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND T2.GPT >= 60",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Patient", "Laboratory"],
        "columns": [
          "Patient.ID",
          "Laboratory.ID",
          "Laboratory.GPT",
          "Patient.SEX"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information and sex filter\">Patient</table>",
        "<table purpose=\"Required for GPT test results\">Laboratory</table>",
        "<column purpose=\"join: Patient.ID, output: 'Provide IDs for male patients'\">Patient.ID</column>",
        "<column purpose=\"join: Laboratory.ID\">Laboratory.ID</column>",
        "<column purpose=\"filter: 'ALT glutamic pylvic transaminase (GPT) exceed the normal range'\">Laboratory.GPT</column>",
        "<column purpose=\"filter: 'male patients'\">Patient.SEX</column>",
        "<output_schema purpose=\"IDs for male patients with GPT exceeding normal range\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient information and sex filter--><table>Patient</table>",
        "<!--Required for GPT values--><table>Laboratory</table>",
        "<!--Filter for male patients--><column>Patient.SEX</column>",
        "<!--Join Patient and Laboratory tables--><column>Patient.ID</column>",
        "<!--Join Patient and Laboratory tables--><column>Laboratory.ID</column>",
        "<!--Check GPT values--><column>Laboratory.GPT</column>",
        "<!--Output patient IDs--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1209,
      "db_id": "thrombosis_prediction",
      "question": "Please provide the diagnosis of patients with ALT glutamic pylvic transaminase beyond the normal range by ascending order of their date of birth.",
      "evidence": "ALT glutamic pylvic transaminase beyond the normal range refers to GPT > 60; The larger the birthday value, the younger the person is, and vice versa; ",
      "SQL": "SELECT DISTINCT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GPT > 60 ORDER BY T1.Birthday ASC",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Patient", "Laboratory"],
        "columns": [
          "Patient.Diagnosis",
          "Patient.ID",
          "Laboratory.ID",
          "Laboratory.GPT",
          "Patient.Birthday"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient diagnosis and birthday information\">Patient</table>",
        "<table purpose=\"Required for GPT (ALT glutamic pyruvic transaminase) values\">Laboratory</table>",
        "<column purpose=\"output: 'diagnosis of patients'\">Patient.Diagnosis</column>",
        "<column purpose=\"join: Patient.ID\">Patient.ID</column>",
        "<column purpose=\"join: Laboratory.ID\">Laboratory.ID</column>",
        "<column purpose=\"filter: 'ALT glutamic pylvic transaminase beyond the normal range'\">Laboratory.GPT</column>",
        "<column purpose=\"sort: 'by ascending order of their date of birth'\">Patient.Birthday</column>",
        "<output_schema purpose=\"diagnosis of patients\">text</output_schema>",
        "<warning>Consider using DISTINCT on Patient.Diagnosis to avoid duplicate diagnoses for the same patient</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient diagnosis--><table>Patient</table>",
        "<!--Required for ALT glutamic pylvic transaminase (GPT) data--><table>Laboratory</table>",
        "<!--Join Patient and Laboratory tables--><column>Patient.ID</column>",
        "<!--Join Patient and Laboratory tables--><column>Laboratory.ID</column>",
        "<!--Filter: \"ALT glutamic pylvic transaminase beyond the normal range\"--><column>Laboratory.GPT</column>",
        "<!--Sort: \"by ascending order of their date of birth\"--><column>Patient.Birthday</column>",
        "<!--Output: \"diagnosis of patients\"--><column>Patient.Diagnosis</column>",
        "<!--Output: patient's date of birth for sorting--><output_schema>date</output_schema>",
        "<!--Output: patient's diagnosis--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1220,
      "db_id": "thrombosis_prediction",
      "question": "Provide all ID, sex and birthday of patients whose urea nitrogen (UN) just within the borderline of passing?",
      "evidence": "urea nitrogen (UN) just within the borderline of passing refers to UN = 29; ",
      "SQL": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.UN = 29",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["Patient", "Laboratory"],
        "columns": [
          "Patient.ID",
          "Patient.SEX",
          "Patient.Birthday",
          "Laboratory.ID",
          "Laboratory.UN"
        ],
        "output_schema": ["integer", "text", "date"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information\">Patient</table>",
        "<table purpose=\"Required for urea nitrogen (UN) data\">Laboratory</table>",
        "<column purpose=\"join: Laboratory.ID, output: 'Provide all ID'\">Patient.ID</column>",
        "<column purpose=\"output: 'Provide all sex'\">Patient.SEX</column>",
        "<column purpose=\"output: 'Provide all birthday'\">Patient.Birthday</column>",
        "<column purpose=\"join: Patient.ID\">Laboratory.ID</column>",
        "<column purpose=\"filter: 'UN = 29'\">Laboratory.UN</column>",
        "<output_schema purpose=\"ID of patients\">integer</output_schema>",
        "<output_schema purpose=\"sex of patients\">text</output_schema>",
        "<output_schema purpose=\"birthday of patients\">date</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient information--><table>Patient</table>",
        "<!--Required for laboratory test results--><table>Laboratory</table>",
        "<!--Needed for output and joining--><column>Patient.ID</column>",
        "<!--Needed for output--><column>Patient.SEX</column>",
        "<!--Needed for output--><column>Patient.Birthday</column>",
        "<!--Needed for joining with Patient table--><column>Laboratory.ID</column>",
        "<!--Required to filter UN values--><column>Laboratory.UN</column>",
        "<!--Patient ID for output--><output_schema>integer</output_schema>",
        "<!--Patient sex for output--><output_schema>text</output_schema>",
        "<!--Patient birthday for output--><output_schema>date</output_schema>"
      ]
    },
    {
      "question_id": 1225,
      "db_id": "thrombosis_prediction",
      "question": "List and group all patients by sex for total bilirubin (T-BIL) level not within the normal range.",
      "evidence": "List refers to GROUP_CONCAT(DISTINCT ID); total bilirubin (T-BIL) not within normal range refers to T-BIL > = 2.0",
      "SQL": "SELECT T1.ID,T1.SEX FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.\"T-BIL\" >= 2.0 GROUP BY T1.SEX,T1.ID",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Patient", "Laboratory"],
        "columns": [
          "Patient.ID",
          "Patient.SEX",
          "Laboratory.ID",
          "Laboratory.T-BIL"
        ],
        "output_schema": ["integer", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"To get patient information, including sex\">Patient</table>",
        "<table purpose=\"To get laboratory test results, including T-BIL\">Laboratory</table>",
        "<column purpose=\"join: Patient and Laboratory tables\">Patient.ID</column>",
        "<column purpose=\"group by: 'group all patients by sex'\">Patient.SEX</column>",
        "<column purpose=\"join: Patient and Laboratory tables\">Laboratory.ID</column>",
        "<column purpose=\"filter: 'T-BIL >= 2.0'\">Laboratory.\"T-BIL\"</column>",
        "<output_schema purpose=\"List of patient IDs (GROUP_CONCAT)\">text</output_schema>",
        "<output_schema purpose=\"Patient sex\">text</output_schema>",
        "<flag>The output schema 'integer' is not needed as the question asks for a list of patient IDs (which would be text due to GROUP_CONCAT) and sex (which is text).</flag>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient sex--><table>Patient</table>",
        "<!--Required for T-BIL measurements--><table>Laboratory</table>",
        "<!--Group by sex--><column>Patient.SEX</column>",
        "<!--Join Patient and Laboratory tables--><column>Patient.ID</column>",
        "<!--Join Patient and Laboratory tables--><column>Laboratory.ID</column>",
        "<!--Filter T-BIL not within normal range--><column>Laboratory.\"T-BIL\"</column>",
        "<!--List patient IDs--><column>Laboratory.ID</column>",
        "<!--Group patients by sex--><output_schema>text</output_schema>",
        "<!--List of patient IDs--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1227,
      "db_id": "thrombosis_prediction",
      "question": "What is the average age of the male patient with high cholesterol?",
      "evidence": "average age = DIVIDE(SUM(SUBTRACT(YEAR(NOW()), YEAR(birthday))), COUNT(ID)); male patient refers to sex = 'M'; high cholesterol refers to \"T-CHO\" > = 250;",
      "SQL": "SELECT AVG(STRFTIME('%Y', date('NOW')) - STRFTIME('%Y', T1.Birthday)) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.\"T-CHO\" >= 250 AND T1.SEX = 'M'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Patient", "Laboratory"],
        "columns": [
          "Patient.Birthday",
          "Patient.ID",
          "Laboratory.ID",
          "Laboratory.T-CHO",
          "Patient.SEX"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information, including birthday and sex\">Patient</table>",
        "<table purpose=\"Required for cholesterol information\">Laboratory</table>",
        "<column purpose=\"calculate: average age\">Patient.Birthday</column>",
        "<column purpose=\"join: Patient.ID\">Patient.ID</column>",
        "<column purpose=\"join: Laboratory.ID\">Laboratory.ID</column>",
        "<column purpose=\"filter: high cholesterol ('T-CHO' >= 250)\">Laboratory.T-CHO</column>",
        "<column purpose=\"filter: male patient (SEX = 'M')\">Patient.SEX</column>",
        "<output_schema purpose=\"average age of male patients with high cholesterol\">real</output_schema>",
        "<warning>The Laboratory.Date column might be useful to ensure the most recent cholesterol measurement is used for each patient, as multiple measurements may exist.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient information--><table>Patient</table>",
        "<!--Required for cholesterol information--><table>Laboratory</table>",
        "<!--filter: 'male patient'--><column>Patient.SEX</column>",
        "<!--calculate: 'average age'--><column>Patient.Birthday</column>",
        "<!--join: Patient.ID--><column>Laboratory.ID</column>",
        "<!--join: Laboratory.ID--><column>Patient.ID</column>",
        "<!--filter: 'high cholesterol'--><column>Laboratory.\"T-CHO\"</column>",
        "<!--average age of male patients with high cholesterol--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1229,
      "db_id": "thrombosis_prediction",
      "question": "For all patients with triglyceride (TG) level beyond the normal range, how many are age more than 50 years?",
      "evidence": "triglyceride (TG) level beyond the normal range refers to TG > = 200; more than 50 years of age = SUBTRACT(year(current_timestamp), year(Birthday)) > 50; Should consider DISTINCT in the final result;",
      "SQL": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TG >= 200 AND STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) > 50",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Patient", "Laboratory"],
        "columns": [
          "Patient.ID",
          "Laboratory.ID",
          "Laboratory.TG",
          "Patient.Birthday"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information and age calculation\">Patient</table>",
        "<table purpose=\"Required for triglyceride (TG) level information\">Laboratory</table>",
        "<column purpose=\"join: Patient.ID, filter: DISTINCT patients\">Patient.ID</column>",
        "<column purpose=\"join: Laboratory.ID\">Laboratory.ID</column>",
        "<column purpose=\"filter: 'triglyceride (TG) level beyond the normal range'\">Laboratory.TG</column>",
        "<column purpose=\"calculate: 'more than 50 years of age'\">Patient.Birthday</column>",
        "<output_schema purpose=\"count of distinct patients meeting the criteria\">integer</output_schema>",
        "<warning>Consider adding CURRENT_TIMESTAMP or CURRENT_DATE to calculate the age</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for triglyceride level--><table>Laboratory</table>",
        "<!--Required for patient age--><table>Patient</table>",
        "<!--Filter: 'triglyceride (TG) level beyond the normal range'--><column>Laboratory.TG</column>",
        "<!--Join: Laboratory.ID--><column>Laboratory.ID</column>",
        "<!--Join: Patient.ID--><column>Patient.ID</column>",
        "<!--Calculate: 'age more than 50 years'--><column>Patient.Birthday</column>",
        "<!--Count of patients meeting criteria--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1231,
      "db_id": "thrombosis_prediction",
      "question": "For patient born between 1936-1956, how many male patients have creatinine phosphokinase beyond the normal range?",
      "evidence": "born between 1936-1956 refers to year(Birthday) BETWEEN '1936' AND '1956'; male patients refers to sex = 'M'; creatinine phosphokinase beyond the normal range refers to CPK > = 250; Should consider DISTINCT in the final result;",
      "SQL": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) BETWEEN '1936' AND '1956' AND T1.SEX = 'M' AND T2.CPK >= 250",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["Patient", "Laboratory"],
        "columns": [
          "Patient.ID",
          "Laboratory.ID",
          "Laboratory.CPK",
          "Patient.SEX",
          "Patient.Birthday"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information\">Patient</table>",
        "<table purpose=\"Required for laboratory test results\">Laboratory</table>",
        "<column purpose=\"join: Patient.ID, filter: DISTINCT patients\">Patient.ID</column>",
        "<column purpose=\"join: Laboratory.ID\">Laboratory.ID</column>",
        "<column purpose=\"filter: 'creatinine phosphokinase beyond the normal range'\">Laboratory.CPK</column>",
        "<column purpose=\"filter: 'male patients'\">Patient.SEX</column>",
        "<column purpose=\"filter: 'born between 1936-1956'\">Patient.Birthday</column>",
        "<output_schema purpose=\"count of distinct patients meeting the criteria\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient birth date--><table>Patient</table>",
        "<!--Required for laboratory test results--><table>Laboratory</table>",
        "<!--Filter: \"born between 1936-1956\"--><column>Patient.Birthday</column>",
        "<!--Filter: \"male patients\"--><column>Patient.SEX</column>",
        "<!--Join: Patient.ID--><column>Patient.ID</column>",
        "<!--Join: Laboratory.ID--><column>Laboratory.ID</column>",
        "<!--Filter: \"creatinine phosphokinase beyond the normal range\"--><column>Laboratory.CPK</column>",
        "<!--Count of distinct patients meeting criteria--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1232,
      "db_id": "thrombosis_prediction",
      "question": "Provide ID, sex and age of patient who has blood glucose (GLU) not within normal range but with total cholesterol(T-CHO) within normal range.",
      "evidence": "age = SUBTRACT(year(current_timestamp), year(Birthday)); blood glucose (GLU) not within normal range refers to GLU > = 180; total cholesterol(T-CHO) within normal range refers to \"T-CHO\" < 250; ",
      "SQL": "SELECT DISTINCT T1.ID, T1.SEX , STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GLU >= 180 AND T2.\"T-CHO\" < 250",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["Patient", "Laboratory"],
        "columns": [
          "Patient.ID",
          "Patient.SEX",
          "Patient.Birthday",
          "Laboratory.ID",
          "Laboratory.GLU",
          "Laboratory.T-CHO"
        ],
        "output_schema": ["integer", "text", "integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information\">Patient</table>",
        "<table purpose=\"Required for laboratory test results\">Laboratory</table>",
        "<column purpose=\"join: Laboratory.ID, output: 'Provide ID'\">Patient.ID</column>",
        "<column purpose=\"output: 'sex of patient'\">Patient.SEX</column>",
        "<column purpose=\"calculate: 'age of patient'\">Patient.Birthday</column>",
        "<column purpose=\"join: Patient.ID\">Laboratory.ID</column>",
        "<column purpose=\"filter: 'blood glucose (GLU) not within normal range'\">Laboratory.GLU</column>",
        "<column purpose=\"filter: 'total cholesterol(T-CHO) within normal range'\">Laboratory.\"T-CHO\"</column>",
        "<output_schema purpose=\"ID of patient\">integer</output_schema>",
        "<output_schema purpose=\"sex of patient\">text</output_schema>",
        "<output_schema purpose=\"age of patient\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient information--><table>Patient</table>",
        "<!--Required for laboratory test results--><table>Laboratory</table>",
        "<!--Patient identifier, needed for output and joining--><column>Patient.ID</column>",
        "<!--Required for output--><column>Patient.SEX</column>",
        "<!--Required to calculate age--><column>Patient.Birthday</column>",
        "<!--Join condition between Patient and Laboratory--><column>Laboratory.ID</column>",
        "<!--Filter condition for blood glucose--><column>Laboratory.GLU</column>",
        "<!--Filter condition for total cholesterol--><column>Laboratory.\"T-CHO\"</column>",
        "<!--Patient ID for output--><output_schema>integer</output_schema>",
        "<!--Patient sex for output--><output_schema>text</output_schema>",
        "<!--Patient age for output--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1235,
      "db_id": "thrombosis_prediction",
      "question": "What are the patient's diagnosis for those who has lower red blood blood cell? State their ID and age.",
      "evidence": "patient's diagnosis refers to Diagnosis; lower red blood cell refers to RBC < 3.5; age = SUBTRACT(year(current_timestamp), year(Birthday)); ",
      "SQL": "SELECT DISTINCT T1.Diagnosis, T1.ID , STRFTIME('%Y', CURRENT_TIMESTAMP) -STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RBC < 3.5",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Patient", "Laboratory"],
        "columns": [
          "Patient.Diagnosis",
          "Patient.ID",
          "Patient.Birthday",
          "Laboratory.ID",
          "Laboratory.RBC"
        ],
        "output_schema": ["text", "integer", "integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient diagnosis and demographic information\">Patient</table>",
        "<table purpose=\"Required for laboratory test results, including RBC\">Laboratory</table>",
        "<column purpose=\"output: 'patient's diagnosis'\">Patient.Diagnosis</column>",
        "<column purpose=\"output: 'State their ID', join: Laboratory.ID\">Patient.ID</column>",
        "<column purpose=\"calculate: 'age = SUBTRACT(year(current_timestamp), year(Birthday))'\">Patient.Birthday</column>",
        "<column purpose=\"join: Patient.ID\">Laboratory.ID</column>",
        "<column purpose=\"filter: 'lower red blood cell refers to RBC &lt; 3.5'\">Laboratory.RBC</column>",
        "<output_schema purpose=\"patient's diagnosis\">text</output_schema>",
        "<output_schema purpose=\"patient ID\">integer</output_schema>",
        "<output_schema purpose=\"patient age\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient information--><table>Patient</table>",
        "<!--Required for laboratory test results--><table>Laboratory</table>",
        "<!--Join Patient and Laboratory tables--><column>Patient.ID</column>",
        "<!--Join Patient and Laboratory tables--><column>Laboratory.ID</column>",
        "<!--Filter for lower red blood cell count--><column>Laboratory.RBC</column>",
        "<!--Calculate age--><column>Patient.Birthday</column>",
        "<!--Get patient's diagnosis--><column>Patient.Diagnosis</column>",
        "<!--Output patient ID--><output_schema>integer</output_schema>",
        "<!--Output patient age--><output_schema>integer</output_schema>",
        "<!--Output patient diagnosis--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1238,
      "db_id": "thrombosis_prediction",
      "question": "Among the patients who were diagnosed with SLE, who is the oldest with normal hemoglobin level. Provide the ID and sex.",
      "evidence": "diagnosed with SLE refers to Diagnosis = 'SLE'; The larger the birthday value, the younger the person is, and vice versa; normal hemoglobin level refers to 10 < HGB < 17;",
      "SQL": "SELECT T1.ID, T1.SEX FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'SLE' AND T2.HGB > 10 AND T2.HGB < 17 ORDER BY T1.Birthday ASC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Patient", "Laboratory"],
        "columns": [
          "Patient.ID",
          "Patient.SEX",
          "Laboratory.ID",
          "Laboratory.HGB",
          "Patient.Diagnosis",
          "Patient.Birthday"
        ],
        "output_schema": ["integer", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information and SLE diagnosis\">Patient</table>",
        "<table purpose=\"Required for hemoglobin level\">Laboratory</table>",
        "<column purpose=\"join: Patient.ID, output: 'Provide the ID'\">Patient.ID</column>",
        "<column purpose=\"output: 'Provide the sex'\">Patient.SEX</column>",
        "<column purpose=\"join: Laboratory.ID\">Laboratory.ID</column>",
        "<column purpose=\"filter: 'normal hemoglobin level refers to 10 &lt; HGB &lt; 17'\">Laboratory.HGB</column>",
        "<column purpose=\"filter: 'diagnosed with SLE refers to Diagnosis = 'SLE''\">Patient.Diagnosis</column>",
        "<column purpose=\"sort: 'who is the oldest'\">Patient.Birthday</column>",
        "<output_schema purpose=\"ID of the oldest patient with SLE and normal hemoglobin\">integer</output_schema>",
        "<output_schema purpose=\"Sex of the oldest patient with SLE and normal hemoglobin\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'diagnosed with SLE'--><table>Patient</table>",
        "<!--Required for hemoglobin level--><table>Laboratory</table>",
        "<!--Filter: 'diagnosed with SLE'--><column>Patient.Diagnosis</column>",
        "<!--Filter: 'oldest'--><column>Patient.Birthday</column>",
        "<!--Filter: 'normal hemoglobin level'--><column>Laboratory.HGB</column>",
        "<!--Join: Patient.ID--><column>Laboratory.ID</column>",
        "<!--Output: 'Provide the ID'--><column>Patient.ID</column>",
        "<!--Output: 'and sex'--><column>Patient.SEX</column>",
        "<!--Patient ID--><output_schema>integer</output_schema>",
        "<!--Patient sex--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1239,
      "db_id": "thrombosis_prediction",
      "question": "Name the ID and age of patient with two or more laboratory examinations which show their hematoclit level exceeded the normal range.",
      "evidence": "age = SUBTRACT(year(current_timestamp), year(Birthday)); patient with two or more laboratory examinations refers to COUNT(ID) > 2; hematoclit level exceeded the normal range refers to HCT > = 52;",
      "SQL": "SELECT DISTINCT T1.ID, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.ID IN ( SELECT ID FROM Laboratory WHERE HCT >= 52 GROUP BY ID HAVING COUNT(ID) >= 2 )",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["Patient", "Laboratory", "Laboratory"],
        "columns": [
          "Laboratory.ID",
          "Laboratory.HCT",
          "Patient.ID",
          "Patient.Birthday"
        ],
        "output_schema": ["integer", "integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information\">Patient</table>",
        "<table purpose=\"Required for laboratory examination data\">Laboratory</table>",
        "<table warning=\"Duplicate table reference. One instance of Laboratory is sufficient.\">Laboratory</table>",
        "<column purpose=\"join: Patient.ID, filter: 'two or more laboratory examinations'\">Laboratory.ID</column>",
        "<column purpose=\"filter: 'hematoclit level exceeded the normal range'\">Laboratory.HCT</column>",
        "<column purpose=\"join: Laboratory.ID, output: 'Name the ID'\">Patient.ID</column>",
        "<column purpose=\"calculate: 'age of patient'\">Patient.Birthday</column>",
        "<output_schema purpose=\"patient ID\">integer</output_schema>",
        "<output_schema purpose=\"age of patient\">integer</output_schema>",
        "<error>Missing CURRENT_TIMESTAMP or equivalent for age calculation</error>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient information--><table>Patient</table>",
        "<!--Required for laboratory test results--><table>Laboratory</table>",
        "<!--Join Patient and Laboratory tables--><column>Patient.ID</column>",
        "<!--Join Patient and Laboratory tables--><column>Laboratory.ID</column>",
        "<!--Calculate age--><column>Patient.Birthday</column>",
        "<!--Filter hematocrit level--><column>Laboratory.HCT</column>",
        "<!--Count laboratory examinations--><column>Laboratory.Date</column>",
        "<!--Output patient ID--><output_schema>integer</output_schema>",
        "<!--Output patient age--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1241,
      "db_id": "thrombosis_prediction",
      "question": "For patients with abnormal platelet level, state the number of patients with lower than normal range. How is it compare to the number of patients with higher than normal range?",
      "evidence": "abnormal platelet level refers to PLT <= 100 or PLT >= 400; platelet level lower than normal range refers to PLT < 100; calculation = SUBTRACT(SUM(PLT < 100), SUM(PLT > 400)); platelet level higher than normal range refers to PLT > 400;",
      "SQL": "SELECT SUM(CASE WHEN T2.PLT <= 100 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.PLT >= 400 THEN 1 ELSE 0 END) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["Patient", "Laboratory"],
        "columns": ["Laboratory.PLT", "Patient.ID", "Laboratory.ID"],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information\">Patient</table>",
        "<table purpose=\"Contains platelet level (PLT) data\">Laboratory</table>",
        "<column purpose=\"filter: 'abnormal platelet level', calculate: 'number of patients with lower/higher than normal range'\">Laboratory.PLT</column>",
        "<column purpose=\"join: Patient.ID\">Patient.ID</column>",
        "<column purpose=\"join: Laboratory.ID\">Laboratory.ID</column>",
        "<output_schema purpose=\"result of calculation (SUBTRACT)\">integer</output_schema>",
        "<warning>The proposed tables and columns are correct, but the SQL query doesn't match the question exactly. The question asks for a comparison between two counts, while the query calculates the difference.</warning>",
        "<warning>The proposal doesn't explicitly mention the need for DISTINCT patient counts, which might be important for accurate results.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for platelet level data--><table>Laboratory</table>",
        "<!--Required to count unique patients--><column>Laboratory.ID</column>",
        "<!--Required for platelet level analysis--><column>Laboratory.PLT</column>",
        "<!--Number of patients with lower than normal platelet level--><output_schema>integer</output_schema>",
        "<!--Number of patients with higher than normal platelet level--><output_schema>integer</output_schema>",
        "<!--Difference between lower and higher counts--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1242,
      "db_id": "thrombosis_prediction",
      "question": "For laboratory examinations take in 1984, list all patients below 50 years old with normal platelet level.",
      "evidence": "laboratory examinations take in 1984 refers to YEAR(Date) = '1984'; below 50 years old = SUBTRACT(year(current_timestamp), year(Birthday)) < 50; normal platelet level refers to PLT between 100 and 400; ",
      "SQL": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.PLT BETWEEN 100 AND 400 AND STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday) < 50 AND STRFTIME('%Y', T2.Date) = '1984'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["Patient", "Laboratory"],
        "columns": [
          "Patient.ID",
          "Laboratory.ID",
          "Laboratory.PLT",
          "Laboratory.Date",
          "Patient.Birthday"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information and age calculation\">Patient</table>",
        "<table purpose=\"Required for laboratory examination data\">Laboratory</table>",
        "<column purpose=\"join: Patient.ID, output: list all patients\">Patient.ID</column>",
        "<column purpose=\"join: Laboratory.ID\">Laboratory.ID</column>",
        "<column purpose=\"filter: normal platelet level (between 100 and 400)\">Laboratory.PLT</column>",
        "<column purpose=\"filter: examinations taken in 1984, calculate: patient age\">Laboratory.Date</column>",
        "<column purpose=\"calculate: patient age (below 50 years old)\">Patient.Birthday</column>",
        "<output_schema purpose=\"list all patients (IDs)\">integer</output_schema>",
        "<warning>The proposal is missing DISTINCT in the output schema, which is used in the SQL query to avoid duplicate patient IDs.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for laboratory examinations--><table>Laboratory</table>",
        "<!--Required for patient age calculation--><table>Patient</table>",
        "<!--Filter: laboratory examinations taken in 1984--><column>Laboratory.Date</column>",
        "<!--Join: Laboratory.ID to Patient.ID--><column>Laboratory.ID</column>",
        "<!--Join: Patient.ID to Laboratory.ID--><column>Patient.ID</column>",
        "<!--Calculate: patient age--><column>Patient.Birthday</column>",
        "<!--Filter: normal platelet level--><column>Laboratory.PLT</column>",
        "<!--Output: list all patients--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1243,
      "db_id": "thrombosis_prediction",
      "question": "For all patients who are older than 55 years old, what is the percentage of female who has abnormal prothrombin time (PT)?",
      "evidence": "older than 55 years old = SUBTRACT(year(current_timestamp), year(Birthday)) > 55; abnormal prothrombin time (PT) refers to PT > = 14; percentage = DIVIDE(SUM(PT > = 14 AND SEX = 'F'), SUM(PT > = 14)) * 100; female refers to sex = 'F'; ",
      "SQL": "SELECT CAST(SUM(CASE WHEN T2.PT >= 14 AND T1.SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(CASE WHEN T2.PT >= 14 THEN 1 ELSE 0 END) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) > 55",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["Patient", "Laboratory"],
        "columns": [
          "Patient.SEX",
          "Laboratory.PT",
          "Patient.ID",
          "Laboratory.ID",
          "Patient.Birthday"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient demographics and age calculation\">Patient</table>",
        "<table purpose=\"Required for prothrombin time (PT) data\">Laboratory</table>",
        "<column purpose=\"filter: 'female', calculate: percentage of female patients\">Patient.SEX</column>",
        "<column purpose=\"filter: 'abnormal prothrombin time (PT)'\">Laboratory.PT</column>",
        "<column purpose=\"join: Patient.ID\">Patient.ID</column>",
        "<column purpose=\"join: Laboratory.ID\">Laboratory.ID</column>",
        "<column purpose=\"filter: 'older than 55 years old'\">Patient.Birthday</column>",
        "<output_schema purpose=\"percentage calculation result\">real</output_schema>",
        "<warning>The current timestamp (CURRENT_TIMESTAMP) is not included in the proposal, but it's needed to calculate the patient's age.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient age calculation--><table>Patient</table>",
        "<!--Required for PT and sex information--><table>Laboratory</table>",
        "<!--Calculate age: 'older than 55 years old'--><column>Patient.Birthday</column>",
        "<!--Filter: 'female'--><column>Patient.SEX</column>",
        "<!--Join: Patient.ID--><column>Laboratory.ID</column>",
        "<!--Calculate: 'abnormal prothrombin time (PT)'--><column>Laboratory.PT</column>",
        "<!--Percentage of female patients with abnormal PT--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1247,
      "db_id": "thrombosis_prediction",
      "question": "Among the male patients who have a normal level of white blood cells, how many of them have an abnormal fibrinogen level?",
      "evidence": "male patients refers to Sex = 'M'; normal level of white blood cells refers to WBC > 3.5 and WBC <9.0; abnormal fibrinogen level refers to FG < = 150 or FG > = 450; Don't compute repetitive ones.",
      "SQL": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.FG <= 150 OR T2.FG >= 450 AND T2.WBC > 3.5 AND T2.WBC < 9.0 AND T1.SEX = 'M'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["Patient", "Laboratory"],
        "columns": [
          "Patient.ID",
          "Laboratory.ID",
          "Laboratory.FG",
          "Laboratory.WBC",
          "Patient.SEX"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information and sex filter\">Patient</table>",
        "<table purpose=\"Required for laboratory test results\">Laboratory</table>",
        "<column purpose=\"join: Patient.ID, filter: distinct count\">Patient.ID</column>",
        "<column purpose=\"join: Laboratory.ID\">Laboratory.ID</column>",
        "<column purpose=\"filter: abnormal fibrinogen level\">Laboratory.FG</column>",
        "<column purpose=\"filter: normal level of white blood cells\">Laboratory.WBC</column>",
        "<column purpose=\"filter: male patients\">Patient.SEX</column>",
        "<output_schema purpose=\"count of distinct patients\">integer</output_schema>",
        "<warning>The SQL query's WHERE clause has a logical error. The conditions for FG should be grouped together with parentheses to ensure correct filtering of abnormal fibrinogen levels.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient sex--><table>Patient</table>",
        "<!--Required for WBC and FG levels--><table>Laboratory</table>",
        "<!--Filter: 'male patients'--><column>Patient.SEX</column>",
        "<!--Join: Patient.ID--><column>Patient.ID</column>",
        "<!--Join: Laboratory.ID--><column>Laboratory.ID</column>",
        "<!--Filter: 'normal level of white blood cells'--><column>Laboratory.WBC</column>",
        "<!--Filter: 'abnormal fibrinogen level'--><column>Laboratory.FG</column>",
        "<!--Count of patients meeting criteria--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1251,
      "db_id": "thrombosis_prediction",
      "question": "How many patients with an Ig G higher than normal?",
      "evidence": "Ig G higher than normal refers to IGG >= 2000; Should consider DISTINCT in the final result;",
      "SQL": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T2.IGG >= 2000",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["Patient", "Laboratory", "Examination"],
        "columns": [
          "Patient.ID",
          "Laboratory.ID",
          "Laboratory.IGG",
          "Examination.ID"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information\">Patient</table>",
        "<table purpose=\"Required for IGG values\">Laboratory</table>",
        "<table warning=\"The Examination table is not necessary for this query\">Examination</table>",
        "<column purpose=\"join: Patient.ID, Laboratory.ID; calculate: distinct count\">Patient.ID</column>",
        "<column purpose=\"join: Patient.ID, Laboratory.ID\">Laboratory.ID</column>",
        "<column purpose=\"filter: 'IGG >= 2000'\">Laboratory.IGG</column>",
        "<column warning=\"The Examination.ID is not necessary for this query\">Examination.ID</column>",
        "<output_schema purpose=\"count of distinct patients\">integer</output_schema>",
        "<error>The query should not include the Examination table as it's not needed to answer the question</error>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient count and IGG values--><table>Laboratory</table>",
        "<!--Filter: 'IGG higher than normal'--><column>Laboratory.IGG</column>",
        "<!--Ensure distinct patient count--><column>Laboratory.ID</column>",
        "<!--Count of patients with IGG higher than normal--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1252,
      "db_id": "thrombosis_prediction",
      "question": "Among the patients with a normal Ig G level, how many of them have symptoms?",
      "evidence": "normal Ig G level refers to IGG > 900 and IGG < 2000; have symptoms refers to Symptoms IS NOT NULL;",
      "SQL": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T2.IGG BETWEEN 900 AND 2000 AND T3.Symptoms IS NOT NULL",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Patient", "Laboratory", "Examination"],
        "columns": [
          "Patient.ID",
          "Laboratory.ID",
          "Laboratory.IGG",
          "Examination.ID",
          "Examination.Symptoms"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information\">Patient</table>",
        "<table purpose=\"Required for IGG levels\">Laboratory</table>",
        "<table purpose=\"Required for symptom information\">Examination</table>",
        "<column purpose=\"join: Patient.ID with Laboratory.ID and Examination.ID\">Patient.ID</column>",
        "<column purpose=\"join: Laboratory.ID with Patient.ID and Examination.ID\">Laboratory.ID</column>",
        "<column purpose=\"filter: 'normal Ig G level refers to IGG &gt; 900 and IGG &lt; 2000'\">Laboratory.IGG</column>",
        "<column purpose=\"join: Examination.ID with Patient.ID and Laboratory.ID\">Examination.ID</column>",
        "<column purpose=\"filter: 'have symptoms refers to Symptoms IS NOT NULL'\">Examination.Symptoms</column>",
        "<output_schema purpose=\"count of patients meeting the criteria\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'patients with a normal Ig G level'--><table>Laboratory</table>",
        "<!--Required for 'have symptoms'--><table>Examination</table>",
        "<!--filter: 'normal Ig G level'--><column>Laboratory.IGG</column>",
        "<!--filter: 'have symptoms'--><column>Examination.Symptoms</column>",
        "<!--join: Laboratory.ID--><column>Examination.ID</column>",
        "<!--join: Examination.ID--><column>Laboratory.ID</column>",
        "<!--count of patients with normal IGG and symptoms--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1254,
      "db_id": "thrombosis_prediction",
      "question": "How many patients with a normal Ig A level came to the hospital after 1990/1/1?",
      "evidence": "normal Ig A level refers to IGA > 80 AND IGA < 500; came to the hospital after 1990/1/1 refers to YEAR(\"First Date\") > = 1990;",
      "SQL": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGA BETWEEN 80 AND 500 AND  strftime('%Y',  T1.\"First Date\") > '1990'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Patient", "Laboratory"],
        "columns": [
          "Patient.ID",
          "Laboratory.ID",
          "Laboratory.IGA",
          "Patient.First Date"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information and 'First Date'\">Patient</table>",
        "<table purpose=\"Required for IgA level information\">Laboratory</table>",
        "<column purpose=\"join: Patient.ID with Laboratory.ID\">Patient.ID</column>",
        "<column purpose=\"join: Laboratory.ID with Patient.ID\">Laboratory.ID</column>",
        "<column purpose=\"filter: 'normal Ig A level refers to IGA &gt; 80 AND IGA &lt; 500'\">Laboratory.IGA</column>",
        "<column purpose=\"filter: 'came to the hospital after 1990/1/1'\">Patient.First Date</column>",
        "<output_schema purpose=\"count of patients meeting the criteria\">integer</output_schema>",
        "<warning>The proposal is missing a COUNT(*) or COUNT(DISTINCT Patient.ID) in the output schema to match the \"How many patients\" part of the question.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient information--><table>Patient</table>",
        "<!--Required for IgA levels--><table>Laboratory</table>",
        "<!--Filter: 'came to the hospital after 1990/1/1'--><column>Patient.\"First Date\"</column>",
        "<!--Join: Laboratory.ID--><column>Patient.ID</column>",
        "<!--Join: Patient.ID--><column>Laboratory.ID</column>",
        "<!--Filter: 'normal Ig A level'--><column>Laboratory.IGA</column>",
        "<!--Count of patients--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1255,
      "db_id": "thrombosis_prediction",
      "question": "For the patients with an abnormal Ig M level, what is the most common disease they are diagnosed with?",
      "evidence": "abnormal Ig M level refers to IGM <=40 OR IGM >= 400; most common disease refers to MAX(COUNT(Diagnosis));",
      "SQL": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGM NOT BETWEEN 40 AND 400 GROUP BY T1.Diagnosis ORDER BY COUNT(T1.Diagnosis) DESC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Patient", "Laboratory"],
        "columns": [
          "Patient.Diagnosis",
          "Patient.ID",
          "Laboratory.ID",
          "Laboratory.IGM"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient diagnosis information\">Patient</table>",
        "<table purpose=\"Required for IGM level information\">Laboratory</table>",
        "<column purpose=\"filter: 'most common disease', calculate: MAX(COUNT(Diagnosis))\">Patient.Diagnosis</column>",
        "<column purpose=\"join: Patient.ID\">Patient.ID</column>",
        "<column purpose=\"join: Laboratory.ID\">Laboratory.ID</column>",
        "<column purpose=\"filter: 'abnormal Ig M level'\">Laboratory.IGM</column>",
        "<output_schema purpose=\"most common disease diagnosis\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'patients with an abnormal Ig M level'--><table>Laboratory</table>",
        "<!--Required for 'disease they are diagnosed with'--><table>Patient</table>",
        "<!--filter: 'abnormal Ig M level'--><column>Laboratory.IGM</column>",
        "<!--join: Laboratory.ID--><column>Patient.ID</column>",
        "<!--join: Patient.ID--><column>Laboratory.ID</column>",
        "<!--'disease they are diagnosed with'--><column>Patient.Diagnosis</column>",
        "<!--'most common disease'--><output_schema>text</output_schema>",
        "<!--'MAX(COUNT(Diagnosis))'--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1256,
      "db_id": "thrombosis_prediction",
      "question": "How many patients with a abnormal C-reactive protein don't have their data recorded?",
      "evidence": "abnormal C-reactive protein refers to CRP ='+'; don't have data recorded refers to Description IS NULL;",
      "SQL": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.CRP = '+' ) AND T1.Description IS NULL",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Patient", "Laboratory"],
        "columns": [
          "Patient.ID",
          "Laboratory.ID",
          "Laboratory.CRP",
          "Patient.Description"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information and Description field\">Patient</table>",
        "<table purpose=\"Required for CRP data\">Laboratory</table>",
        "<column purpose=\"join: Patient.ID with Laboratory.ID\">Patient.ID</column>",
        "<column purpose=\"join: Laboratory.ID with Patient.ID\">Laboratory.ID</column>",
        "<column purpose=\"filter: 'abnormal C-reactive protein refers to CRP ='+''\">Laboratory.CRP</column>",
        "<column purpose=\"filter: 'don't have data recorded refers to Description IS NULL'\">Patient.Description</column>",
        "<output_schema purpose=\"count of patients meeting the criteria\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient data--><table>Patient</table>",
        "<!--Required for CRP data--><table>Laboratory</table>",
        "<!--Join Patient and Laboratory tables--><column>Patient.ID</column>",
        "<!--Join Patient and Laboratory tables--><column>Laboratory.ID</column>",
        "<!--Filter for abnormal CRP--><column>Laboratory.CRP</column>",
        "<!--Check if data is not recorded--><column>Patient.Description</column>",
        "<!--Count of patients--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1257,
      "db_id": "thrombosis_prediction",
      "question": "Among the patients whose creatinine level is abnormal, how many of them aren't 70 yet?",
      "evidence": "creatinine level is abnormal refers to CRE >= 1.5; aren't 70 yet refers to SUBTRACT((YEAR(CURDATE()), YEAR(Birthday))) < 70; ",
      "SQL": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE >= 1.5 AND STRFTIME('%Y', Date('now')) - STRFTIME('%Y', T1.Birthday) < 70",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["Patient", "Laboratory"],
        "columns": [
          "Patient.ID",
          "Laboratory.ID",
          "Laboratory.CRE",
          "Patient.Birthday"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information and age calculation\">Patient</table>",
        "<table purpose=\"Required for creatinine level data\">Laboratory</table>",
        "<column purpose=\"join: Patient.ID, filter: distinct patients\">Patient.ID</column>",
        "<column purpose=\"join: Laboratory.ID\">Laboratory.ID</column>",
        "<column purpose=\"filter: 'creatinine level is abnormal refers to CRE >= 1.5'\">Laboratory.CRE</column>",
        "<column purpose=\"calculate: 'aren't 70 yet refers to SUBTRACT((YEAR(CURDATE()), YEAR(Birthday))) &lt; 70'\">Patient.Birthday</column>",
        "<output_schema purpose=\"count of patients meeting the criteria\">integer</output_schema>",
        "<warning>The SQL query uses STRFTIME function which is specific to SQLite. If you're using a different database system, you might need to adjust the date calculation.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for creatinine level--><table>Laboratory</table>",
        "<!--Required for patient age calculation--><table>Patient</table>",
        "<!--Filter: 'creatinine level is abnormal'--><column>Laboratory.CRE</column>",
        "<!--Join: Laboratory.ID--><column>Laboratory.ID</column>",
        "<!--Join: Patient.ID--><column>Patient.ID</column>",
        "<!--Calculate: 'aren't 70 yet'--><column>Patient.Birthday</column>",
        "<!--Count of patients meeting criteria--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1265,
      "db_id": "thrombosis_prediction",
      "question": "How many patients have a normal level of anti-ribonuclear protein and have been admitted to the hospital?",
      "evidence": "normal level of anti-ribonuclear protein refers to RNP = '-', '+-'; And'-' means 'negative'; '+-' refers to '0'; admitted to the hospital refers to Admission = '+'; Should consider DISTINCT in the final result;",
      "SQL": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP = 'negative' OR T2.RNP = '0' AND T1.Admission = '+'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Patient", "Laboratory"],
        "columns": [
          "Patient.ID",
          "Laboratory.ID",
          "Laboratory.RNP",
          "Patient.Admission"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information and admission status\">Patient</table>",
        "<table purpose=\"Required for RNP test results\">Laboratory</table>",
        "<column purpose=\"join: Patient.ID, calculate: distinct count\">Patient.ID</column>",
        "<column purpose=\"join: Laboratory.ID\">Laboratory.ID</column>",
        "<column purpose=\"filter: normal level of anti-ribonuclear protein\">Laboratory.RNP</column>",
        "<column purpose=\"filter: admitted to the hospital\">Patient.Admission</column>",
        "<output_schema purpose=\"count of distinct patients\">integer</output_schema>",
        "<warning>The proposed SQL query has a potential logic error in the WHERE clause. The current structure `WHERE T2.RNP = 'negative' OR T2.RNP = '0' AND T1.Admission = '+'` might not correctly filter for both RNP and Admission conditions as intended. Consider using parentheses to group the OR conditions.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'patients' and 'admitted to the hospital'--><table>Patient</table>",
        "<!--Required for 'normal level of anti-ribonuclear protein'--><table>Laboratory</table>",
        "<!--join: Patient.ID--><column>Laboratory.ID</column>",
        "<!--join: Laboratory.ID--><column>Patient.ID</column>",
        "<!--filter: 'admitted to the hospital'--><column>Patient.Admission</column>",
        "<!--filter: 'normal level of anti-ribonuclear protein'--><column>Laboratory.RNP</column>",
        "<!--count of patients--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1267,
      "db_id": "thrombosis_prediction",
      "question": "Among the patients with normal anti-SM, how many of them does not have thrombosis?",
      "evidence": "normal anti-SM refers to SM IN('-', '+-'); SM = 'negative' means '-'; SM = '0' means '+-'; SM = '1' means '+'; does not have thrombosis refers to Thrombosis = 0;",
      "SQL": "SELECT COUNT(T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SM IN ('negative','0') AND T1.Thrombosis = 0",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Examination", "Laboratory"],
        "columns": [
          "Examination.ID",
          "Laboratory.ID",
          "Laboratory.SM",
          "Examination.Thrombosis"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for thrombosis information\">Examination</table>",
        "<table purpose=\"Required for anti-SM information\">Laboratory</table>",
        "<column purpose=\"join: Examination.ID with Laboratory.ID\">Examination.ID</column>",
        "<column purpose=\"join: Laboratory.ID with Examination.ID\">Laboratory.ID</column>",
        "<column purpose=\"filter: 'normal anti-SM'\">Laboratory.SM</column>",
        "<column purpose=\"filter: 'does not have thrombosis'\">Examination.Thrombosis</column>",
        "<output_schema purpose=\"count of patients meeting the criteria\">integer</output_schema>",
        "<warning>The proposal doesn't explicitly mention the COUNT() function, but it's implied by the question asking \"how many\"</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'patients with normal anti-SM'--><table>Laboratory</table>",
        "<!--Required for 'does not have thrombosis'--><table>Examination</table>",
        "<!--filter: 'normal anti-SM'--><column>Laboratory.SM</column>",
        "<!--filter: 'does not have thrombosis'--><column>Examination.Thrombosis</column>",
        "<!--join: Laboratory.ID--><column>Examination.ID</column>",
        "<!--join: Examination.ID--><column>Laboratory.ID</column>",
        "<!--count of patients--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1270,
      "db_id": "thrombosis_prediction",
      "question": "Among the patients who has a normal anti-scl70, how many of them are female and does not have any symptom?",
      "evidence": "normal anti-scl70 refers to SC170 IN('negative', '0'); female refers to Sex = 'F'; does not have any symptom refers to symptoms IS NULL; Should consider DISTINCT in the final result;",
      "SQL": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE (T2.SC170 = 'negative' OR T2.SC170 = '0') AND T1.SEX = 'F' AND T3.Symptoms IS NULL",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["Patient", "Laboratory", "Examination"],
        "columns": [
          "Patient.ID",
          "Laboratory.ID",
          "Laboratory.SC170",
          "Examination.ID",
          "Examination.Symptoms",
          "Patient.SEX"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information and sex\">Patient</table>",
        "<table purpose=\"Required for anti-scl70 (SC170) data\">Laboratory</table>",
        "<table purpose=\"Required for symptom information\">Examination</table>",
        "<column purpose=\"join: Patient.ID, Laboratory.ID, Examination.ID; calculate: DISTINCT count\">Patient.ID</column>",
        "<column purpose=\"join: Patient.ID, Laboratory.ID, Examination.ID\">Laboratory.ID</column>",
        "<column purpose=\"filter: normal anti-scl70\">Laboratory.SC170</column>",
        "<column purpose=\"join: Patient.ID, Laboratory.ID, Examination.ID\">Examination.ID</column>",
        "<column purpose=\"filter: does not have any symptom\">Examination.Symptoms</column>",
        "<column purpose=\"filter: female patients\">Patient.SEX</column>",
        "<output_schema purpose=\"count of distinct patients\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for anti-scl70 information--><table>Laboratory</table>",
        "<!--Required for patient sex and symptoms--><table>Patient</table>",
        "<!--Required for symptoms--><table>Examination</table>",
        "<!--Filter: 'normal anti-scl70'--><column>Laboratory.SC170</column>",
        "<!--Join: Laboratory.ID--><column>Patient.ID</column>",
        "<!--Join: Patient.ID--><column>Examination.ID</column>",
        "<!--Filter: 'female'--><column>Patient.SEX</column>",
        "<!--Filter: 'does not have any symptom'--><column>Examination.Symptoms</column>",
        "<!--Count of distinct patients--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1275,
      "db_id": "thrombosis_prediction",
      "question": "Among the patients who has a normal level of anti-centromere and a normal level of anti-SSB, how many of them are male?",
      "evidence": "normal level of anti-centromere refers to CENTROMEA IN('-', '+-'); normal level of anti-SSB refers to SSB IN('-', '+-'); male refers to Sex = 'M'; Should consider DISTINCT in the final result;",
      "SQL": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CENTROMEA IN ('negative', '0') AND T2.SSB IN ('negative', '0') AND T1.SEX = 'M'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Patient", "Laboratory"],
        "columns": [
          "Patient.ID",
          "Laboratory.ID",
          "Laboratory.CENTROMEA",
          "Laboratory.SSB",
          "Patient.SEX"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information and sex\">Patient</table>",
        "<table purpose=\"Required for laboratory test results\">Laboratory</table>",
        "<column purpose=\"join: Patient.ID, Laboratory.ID; calculate: DISTINCT count\">Patient.ID</column>",
        "<column purpose=\"join: Patient.ID, Laboratory.ID\">Laboratory.ID</column>",
        "<column purpose=\"filter: normal level of anti-centromere\">Laboratory.CENTROMEA</column>",
        "<column purpose=\"filter: normal level of anti-SSB\">Laboratory.SSB</column>",
        "<column purpose=\"filter: male patients\">Patient.SEX</column>",
        "<output_schema purpose=\"count of distinct patients\">integer</output_schema>",
        "<warning>The SQL query uses 'negative' and '0' for CENTROMEA and SSB, but the question specifies '-' and '+-' as normal levels. This discrepancy should be addressed.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for patient information--><table>Patient</table>",
        "<!--Required for laboratory test results--><table>Laboratory</table>",
        "<!--Join Patient and Laboratory tables--><column>Patient.ID</column>",
        "<!--Join Patient and Laboratory tables--><column>Laboratory.ID</column>",
        "<!--Filter for male patients--><column>Patient.SEX</column>",
        "<!--Filter for normal level of anti-centromere--><column>Laboratory.CENTROMEA</column>",
        "<!--Filter for normal level of anti-SSB--><column>Laboratory.SSB</column>",
        "<!--Count distinct patients--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1281,
      "db_id": "thrombosis_prediction",
      "question": "Among the patients who have an abnormal level of glutamic oxaloacetic transaminase, when was the youngest of them born?",
      "evidence": "abnormal level of glutamic oxaloacetic transaminase refers to GOT > = 60; The larger the birthday value, the younger the person is, and vice versa;",
      "SQL": "SELECT T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT >= 60 ORDER BY T1.Birthday DESC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Patient", "Laboratory"],
        "columns": [
          "Patient.Birthday",
          "Patient.ID",
          "Laboratory.ID",
          "Laboratory.GOT"
        ],
        "output_schema": ["date"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient information, including birthday\">Patient</table>",
        "<table purpose=\"Required for laboratory test results, including GOT\">Laboratory</table>",
        "<column purpose=\"filter: 'youngest of them born', output: 'when was the youngest of them born'\">Patient.Birthday</column>",
        "<column purpose=\"join: Patient.ID\">Patient.ID</column>",
        "<column purpose=\"join: Laboratory.ID\">Laboratory.ID</column>",
        "<column purpose=\"filter: 'abnormal level of glutamic oxaloacetic transaminase refers to GOT >= 60'\">Laboratory.GOT</column>",
        "<output_schema purpose=\"birthday of the youngest patient with abnormal GOT\">date</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'abnormal level of glutamic oxaloacetic transaminase'--><table>Laboratory</table>",
        "<!--Required for patient's birthday--><table>Patient</table>",
        "<!--filter: 'abnormal level of glutamic oxaloacetic transaminase'--><column>Laboratory.GOT</column>",
        "<!--join: Laboratory.ID--><column>Patient.ID</column>",
        "<!--join: Patient.ID--><column>Laboratory.ID</column>",
        "<!--find: 'youngest of them born'--><column>Patient.Birthday</column>",
        "<!--youngest patient's birthday--><output_schema>date</output_schema>"
      ]
    },
    {
      "question_id": 1302,
      "db_id": "thrombosis_prediction",
      "question": "For the patients with a normal range of creatinine phosphokinase, how many of them have a positive measure of degree of coagulation?",
      "evidence": "normal range of creatinine phosphokinase refers to CPK < 250; positive measure of degree of coagulation refers to KCT = '+' or RVVT = '+' or LAC = '+' ;",
      "SQL": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.CPK < 250 AND (T3.KCT = '+' OR T3.RVVT = '+' OR T3.LAC = '+')",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["Patient", "Laboratory", "Examination"],
        "columns": [
          "Patient.ID",
          "Laboratory.ID",
          "Laboratory.CPK",
          "Examination.ID",
          "Examination.KCT",
          "Examination.LAC",
          "Examination.RVVT"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for patient identification\">Patient</table>",
        "<table purpose=\"Required for creatinine phosphokinase (CPK) data\">Laboratory</table>",
        "<table purpose=\"Required for coagulation measure data (KCT, RVVT, LAC)\">Examination</table>",
        "<column purpose=\"join: Patient.ID, Laboratory.ID, Examination.ID\">Patient.ID</column>",
        "<column purpose=\"join: Patient.ID, Laboratory.ID, Examination.ID\">Laboratory.ID</column>",
        "<column purpose=\"filter: 'normal range of creatinine phosphokinase refers to CPK &lt; 250'\">Laboratory.CPK</column>",
        "<column purpose=\"join: Patient.ID, Laboratory.ID, Examination.ID\">Examination.ID</column>",
        "<column purpose=\"filter: 'positive measure of degree of coagulation refers to KCT = '+'\">Examination.KCT</column>",
        "<column purpose=\"filter: 'positive measure of degree of coagulation refers to LAC = '+'\">Examination.LAC</column>",
        "<column purpose=\"filter: 'positive measure of degree of coagulation refers to RVVT = '+'\">Examination.RVVT</column>",
        "<output_schema purpose=\"count of patients meeting the criteria\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'creatinine phosphokinase' data--><table>Laboratory</table>",
        "<!--Required for 'measure of degree of coagulation' data--><table>Examination</table>",
        "<!--Required to join Laboratory and Examination tables--><table>Patient</table>",
        "<!--Filter: 'normal range of creatinine phosphokinase'--><column>Laboratory.CPK</column>",
        "<!--Filter: 'positive measure of degree of coagulation'--><column>Examination.KCT</column>",
        "<!--Filter: 'positive measure of degree of coagulation'--><column>Examination.RVVT</column>",
        "<!--Filter: 'positive measure of degree of coagulation'--><column>Examination.LAC</column>",
        "<!--Join Laboratory and Patient tables--><column>Laboratory.ID</column>",
        "<!--Join Laboratory and Patient tables--><column>Patient.ID</column>",
        "<!--Join Examination and Patient tables--><column>Examination.ID</column>",
        "<!--Count of patients meeting the criteria--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1025,
      "db_id": "european_football_2",
      "question": "Give the name of the league had the most goals in the 2016 season?",
      "evidence": "league that had the most goals refers to MAX(SUM(home_team_goal, away_team_goal)); 2016 season refers to season = '2015/2016';",
      "SQL": "SELECT t2.name FROM Match AS t1 INNER JOIN League AS t2 ON t1.league_id = t2.id WHERE t1.season = '2015/2016' GROUP BY t2.name ORDER BY SUM(t1.home_team_goal + t1.away_team_goal) DESC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Match", "League"],
        "columns": [
          "League.name",
          "Match.league_id",
          "League.id",
          "Match.season",
          "Match.home_team_goal",
          "Match.away_team_goal"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains match data including goals and season information\">Match</table>",
        "<table purpose=\"Contains league information\">League</table>",
        "<column purpose=\"Output: name of the league with most goals\">League.name</column>",
        "<column purpose=\"Join: Match.league_id with League.id\">Match.league_id</column>",
        "<column purpose=\"Join: League.id with Match.league_id\">League.id</column>",
        "<column purpose=\"Filter: '2016 season refers to season = '2015/2016''\">Match.season</column>",
        "<column purpose=\"Calculate: part of 'most goals'\">Match.home_team_goal</column>",
        "<column purpose=\"Calculate: part of 'most goals'\">Match.away_team_goal</column>",
        "<output_schema purpose=\"Name of the league is text\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for league information--><table>League</table>",
        "<!--Required for match information--><table>Match</table>",
        "<!--Join League and Match tables--><column>League.id</column>",
        "<!--Join League and Match tables--><column>Match.league_id</column>",
        "<!--Filter for 2016 season--><column>Match.season</column>",
        "<!--Calculate total goals--><column>Match.home_team_goal</column>",
        "<!--Calculate total goals--><column>Match.away_team_goal</column>",
        "<!--League name for output--><column>League.name</column>",
        "<!--Name of the league with most goals--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1028,
      "db_id": "european_football_2",
      "question": "In Scotland Premier League, which away team won the most during the 2010 season?",
      "evidence": "Final result should return the Team.team_long_name; Scotland Premier League refers to League.name = 'Scotland Premier League'; away team refers to away_team_api_id; away team that won the most refers to MAX(SUBTRACT(away_team_goal, home_team_goal) > 0); 2010 season refers to season = '2009/2010'; won the most refers to MAX(COUNT(*));",
      "SQL": "SELECT teamInfo.team_long_name FROM League AS leagueData INNER JOIN Match AS matchData ON leagueData.id = matchData.league_id INNER JOIN Team AS teamInfo ON matchData.away_team_api_id = teamInfo.team_api_id WHERE leagueData.name = 'Scotland Premier League' AND matchData.season = '2009/2010' AND matchData.away_team_goal - matchData.home_team_goal > 0 GROUP BY matchData.away_team_api_id ORDER BY COUNT(*) DESC LIMIT 1",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["League", "Match", "Team"],
        "columns": [
          "Team.team_long_name",
          "League.id",
          "Match.league_id",
          "Match.away_team_goal",
          "Match.home_team_goal",
          "Match.season",
          "Match.away_team_api_id",
          "Team.team_api_id",
          "League.name"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"To identify the league (Scotland Premier League)\">League</table>",
        "<table purpose=\"To get match data including goals and season\">Match</table>",
        "<table purpose=\"To get team names\">Team</table>",
        "<column purpose=\"Output: name of the winning away team\">Team.team_long_name</column>",
        "<column purpose=\"Join: League with Match\">League.id</column>",
        "<column purpose=\"Join: League with Match\">Match.league_id</column>",
        "<column purpose=\"Calculate: away team win (away_team_goal - home_team_goal > 0)\">Match.away_team_goal</column>",
        "<column purpose=\"Calculate: away team win (away_team_goal - home_team_goal > 0)\">Match.home_team_goal</column>",
        "<column purpose=\"Filter: 2010 season ('2009/2010')\">Match.season</column>",
        "<column purpose=\"Join: Match with Team, Group by: to count wins\">Match.away_team_api_id</column>",
        "<column purpose=\"Join: Match with Team\">Team.team_api_id</column>",
        "<column purpose=\"Filter: 'Scotland Premier League'\">League.name</column>",
        "<output_schema purpose=\"Return team name as text\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Scotland Premier League'--><table>League</table>",
        "<!--Required for match information--><table>Match</table>",
        "<!--Required for team name--><table>Team</table>",
        "<!--Filter: 'Scotland Premier League'--><column>League.name</column>",
        "<!--Join: Match.league_id--><column>League.id</column>",
        "<!--Join: League.id--><column>Match.league_id</column>",
        "<!--Filter: '2010 season'--><column>Match.season</column>",
        "<!--Calculate: 'away team won'--><column>Match.away_team_goal</column>",
        "<!--Calculate: 'away team won'--><column>Match.home_team_goal</column>",
        "<!--Identify: 'away team'--><column>Match.away_team_api_id</column>",
        "<!--Join: Match.away_team_api_id--><column>Team.team_api_id</column>",
        "<!--Output: team name--><column>Team.team_long_name</column>",
        "<!--Team name of away team that won the most--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1029,
      "db_id": "european_football_2",
      "question": "What are the speed in which attacks are put together of the top 4 teams with the highest build Up Play Speed?",
      "evidence": "speed in which attacks are put together refers to buildUpPlaySpeed;highest build up play speed refers to MAX(buildUpPlaySpeed)",
      "SQL": "SELECT t1.buildUpPlaySpeed FROM Team_Attributes AS t1 INNER JOIN Team AS t2 ON t1.team_api_id = t2.team_api_id ORDER BY t1.buildUpPlaySpeed ASC LIMIT 4",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Team_Attributes", "Team"],
        "columns": [
          "Team_Attributes.buildUpPlaySpeed",
          "Team_Attributes.team_api_id",
          "Team.team_api_id"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains the buildUpPlaySpeed attribute\">Team_Attributes</table>",
        "<table purpose=\"Needed to join with Team_Attributes and potentially get team names\">Team</table>",
        "<column purpose=\"calculate: 'speed in which attacks are put together', filter: 'highest build Up Play Speed'\">Team_Attributes.buildUpPlaySpeed</column>",
        "<column purpose=\"join: Team.team_api_id\">Team_Attributes.team_api_id</column>",
        "<column purpose=\"join: Team_Attributes.team_api_id\">Team.team_api_id</column>",
        "<output_schema purpose=\"buildUpPlaySpeed values\">integer</output_schema>",
        "<error>The SQL query is incorrect. It should use ORDER BY buildUpPlaySpeed DESC to get the highest values, and LIMIT 4 to get the top 4 teams.</error>",
        "<warning>The proposal doesn't include Team.team_long_name or Team.team_short_name, which might be useful for identifying the teams.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'buildUpPlaySpeed'--><table>Team_Attributes</table>",
        "<!--Calculate: 'speed in which attacks are put together'--><column>Team_Attributes.buildUpPlaySpeed</column>",
        "<!--Required to identify teams--><table>Team</table>",
        "<!--Join: Team.team_api_id--><column>Team_Attributes.team_api_id</column>",
        "<!--Join: Team_Attributes.team_api_id--><column>Team.team_api_id</column>",
        "<!--Identify teams--><column>Team.team_long_name</column>",
        "<!--Speed in which attacks are put together--><output_schema>integer</output_schema>",
        "<!--Team name--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1030,
      "db_id": "european_football_2",
      "question": "Give the name of the league had the most matches end as draw in the 2016 season?",
      "evidence": "most matches end as draw refers to MAX(SUM(home_team_goal = away_team_goal)); 2016 season refers to season = '2015/2016';",
      "SQL": "SELECT t2.name FROM Match AS t1 INNER JOIN League AS t2 ON t1.league_id = t2.id WHERE t1.season = '2015/2016' AND t1.home_team_goal = t1.away_team_goal GROUP BY t2.name ORDER BY COUNT(t1.id) DESC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Match", "League"],
        "columns": [
          "League.name",
          "Match.league_id",
          "League.id",
          "Match.away_team_goal",
          "Match.home_team_goal",
          "Match.season",
          "Match.id"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains match data, including scores and season information\">Match</table>",
        "<table purpose=\"Contains league information, including names\">League</table>",
        "<column purpose=\"Output: name of the league with most draws\">League.name</column>",
        "<column purpose=\"Join: Match.league_id with League.id\">Match.league_id</column>",
        "<column purpose=\"Join: League.id with Match.league_id\">League.id</column>",
        "<column purpose=\"Calculate: home_team_goal = away_team_goal for draws\">Match.away_team_goal</column>",
        "<column purpose=\"Calculate: home_team_goal = away_team_goal for draws\">Match.home_team_goal</column>",
        "<column purpose=\"Filter: season = '2015/2016'\">Match.season</column>",
        "<column purpose=\"Count matches for grouping\">Match.id</column>",
        "<output_schema purpose=\"Return the name of the league\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for match data--><table>Match</table>",
        "<!--Required for league names--><table>League</table>",
        "<!--Filter for 2016 season--><column>Match.season</column>",
        "<!--Calculate draws--><column>Match.home_team_goal</column>",
        "<!--Calculate draws--><column>Match.away_team_goal</column>",
        "<!--Join Match and League tables--><column>Match.league_id</column>",
        "<!--Join Match and League tables--><column>League.id</column>",
        "<!--Get league name--><column>League.name</column>",
        "<!--League name with most draws--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1031,
      "db_id": "european_football_2",
      "question": "At present, calculate for the player's age who have a sprint speed of no less than 97 between 2013 to 2015.",
      "evidence": "players age at present = SUBTRACT((DATETIME(), birthday)); sprint speed of no less than 97 refers to sprint_speed > = 97; between 2013 to 2015 refers to YEAR(date) > = '2013' AND YEAR(date) < = '2015'; ",
      "SQL": "SELECT DISTINCT DATETIME() - T2.birthday age FROM Player_Attributes AS t1 INNER JOIN Player AS t2 ON t1.player_api_id = t2.player_api_id WHERE STRFTIME('%Y',t1.\"date\") >= '2013' AND STRFTIME('%Y',t1.\"date\") <= '2015' AND t1.sprint_speed >= 97",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["Player_Attributes", "Player"],
        "columns": [
          "Player.birthday",
          "Player_Attributes.player_api_id",
          "Player.player_api_id",
          "Player_Attributes.sprint_speed",
          "Player_Attributes.date"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains player attributes including sprint speed\">Player_Attributes</table>",
        "<table purpose=\"Contains player information including birthday\">Player</table>",
        "<column purpose=\"calculate: player's age, join: Player_Attributes.player_api_id\">Player.birthday</column>",
        "<column purpose=\"join: Player.player_api_id\">Player_Attributes.player_api_id</column>",
        "<column purpose=\"join: Player_Attributes.player_api_id\">Player.player_api_id</column>",
        "<column purpose=\"filter: 'sprint speed of no less than 97'\">Player_Attributes.sprint_speed</column>",
        "<column purpose=\"filter: 'between 2013 to 2015'\">Player_Attributes.date</column>",
        "<output_schema purpose=\"player's age at present\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for player information--><table>Player</table>",
        "<!--Required for player attributes--><table>Player_Attributes</table>",
        "<!--Calculate player's age--><column>Player.birthday</column>",
        "<!--Filter by sprint speed--><column>Player_Attributes.sprint_speed</column>",
        "<!--Filter by date range--><column>Player_Attributes.date</column>",
        "<!--Join Player and Player_Attributes tables--><column>Player.player_api_id</column>",
        "<!--Join Player and Player_Attributes tables--><column>Player_Attributes.player_api_id</column>",
        "<!--Player's age at present--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1032,
      "db_id": "european_football_2",
      "question": "Give the name of the league with the highest matches of all time and how many matches were played in the said league.",
      "evidence": " league with highest matches of all time refers to MAX(COUNT(league_id));",
      "SQL": "SELECT t2.name, t1.max_count FROM League AS t2 JOIN (SELECT league_id, MAX(cnt) AS max_count FROM (SELECT league_id, COUNT(id) AS cnt FROM Match GROUP BY league_id) AS subquery) AS t1 ON t1.league_id = t2.id",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["League", "Match"],
        "columns": ["Match.league_id", "Match.id", "League.name", "League.id"],
        "output_schema": ["text", "integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for league information\">League</table>",
        "<table purpose=\"Required for match count\">Match</table>",
        "<column purpose=\"join: League.id, filter: 'highest matches of all time'\">Match.league_id</column>",
        "<column purpose=\"calculate: 'how many matches were played'\">Match.id</column>",
        "<column purpose=\"output: 'name of the league'\">League.name</column>",
        "<column purpose=\"join: Match.league_id\">League.id</column>",
        "<output_schema purpose=\"'name of the league'\">text</output_schema>",
        "<output_schema purpose=\"'how many matches were played'\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for league information--><table>League</table>",
        "<!--Required for match count--><table>Match</table>",
        "<!--Join League and Match tables--><column>League.id</column>",
        "<!--Join League and Match tables--><column>Match.league_id</column>",
        "<!--Get league name--><column>League.name</column>",
        "<!--Count matches per league--><column>Match.id</column>",
        "<!--League with highest matches of all time--><output_schema>text</output_schema>",
        "<!--Number of matches in the league with highest matches--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1035,
      "db_id": "european_football_2",
      "question": "Give the team_fifa_api_id of teams with more than 50 but less than 60 build-up play speed.",
      "evidence": "teams with more than 50 but less than 60 build-up play speed refers to buildUpPlaySpeed >50 AND buildUpPlaySpeed <60; ",
      "SQL": "SELECT DISTINCT team_fifa_api_id FROM Team_Attributes WHERE buildUpPlaySpeed > 50 AND buildUpPlaySpeed < 60",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["Team_Attributes"],
        "columns": [
          "Team_Attributes.team_fifa_api_id",
          "Team_Attributes.buildUpPlaySpeed"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains the required team attributes data\">Team_Attributes</table>",
        "<column purpose=\"join: Team.team_fifa_api_id, output: 'team_fifa_api_id of teams'\">Team_Attributes.team_fifa_api_id</column>",
        "<column purpose=\"filter: 'more than 50 but less than 60 build-up play speed'\">Team_Attributes.buildUpPlaySpeed</column>",
        "<output_schema purpose=\"team_fifa_api_id of teams\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'teams with more than 50 but less than 60 build-up play speed'--><table>Team_Attributes</table>",
        "<!--Filter: 'more than 50 but less than 60 build-up play speed'--><column>Team_Attributes.buildUpPlaySpeed</column>",
        "<!--Output: 'team_fifa_api_id of teams'--><column>Team_Attributes.team_fifa_api_id</column>",
        "<!--team_fifa_api_id of teams--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1036,
      "db_id": "european_football_2",
      "question": "List the long name of teams with above-average build-up play passing in 2012.",
      "evidence": "long name of teams refers to team_long_name; build-up play passing refers to buildUpPlayPassing; above-average build-up play passing = buildUpPlayPassing > DIVIDE(SUM(buildUpPlayPassing), COUNT(team_long_name) WHERE buildUpPlayPassing IS NOT NULL); in 2012 refers to strftime('%Y', date) = '2012'; ",
      "SQL": "SELECT DISTINCT t4.team_long_name FROM Team_Attributes AS t3 INNER JOIN Team AS t4 ON t3.team_api_id = t4.team_api_id WHERE SUBSTR(t3.\"date\", 1, 4) = '2012' AND t3.buildUpPlayPassing > ( SELECT CAST(SUM(t2.buildUpPlayPassing) AS REAL) / COUNT(t1.id) FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE STRFTIME('%Y',t2.\"date\") = '2012')",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["Team_Attributes", "Team", "Team", "Team_Attributes"],
        "columns": [
          "Team_Attributes.buildUpPlayPassing",
          "Team.id",
          "Team.team_api_id",
          "Team_Attributes.team_api_id",
          "Team_Attributes.date",
          "Team.team_long_name"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains team attributes including buildUpPlayPassing\">Team_Attributes</table>",
        "<table purpose=\"Contains team information including team_long_name\">Team</table>",
        "<table purpose=\"Used in subquery for average calculation\">Team</table>",
        "<table purpose=\"Used in subquery for average calculation\">Team_Attributes</table>",
        "<column purpose=\"calculate: 'above-average build-up play passing'\">Team_Attributes.buildUpPlayPassing</column>",
        "<column purpose=\"Used in subquery for average calculation\">Team.id</column>",
        "<column purpose=\"join: Team_Attributes.team_api_id\">Team.team_api_id</column>",
        "<column purpose=\"join: Team.team_api_id\">Team_Attributes.team_api_id</column>",
        "<column purpose=\"filter: 'in 2012'\">Team_Attributes.date</column>",
        "<column purpose=\"output: 'long name of teams'\">Team.team_long_name</column>",
        "<output_schema purpose=\"List of team long names\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for team long name--><table>Team</table>",
        "<!--Required for build-up play passing--><table>Team_Attributes</table>",
        "<!--Team long name--><column>Team.team_long_name</column>",
        "<!--Build-up play passing score--><column>Team_Attributes.buildUpPlayPassing</column>",
        "<!--Date for filtering year 2012--><column>Team_Attributes.date</column>",
        "<!--Join Team and Team_Attributes--><column>Team.team_api_id</column>",
        "<!--Join Team and Team_Attributes--><column>Team_Attributes.team_api_id</column>",
        "<!--List of team long names--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1037,
      "db_id": "european_football_2",
      "question": "Calculate the percentage of players who prefer left foot, who were born between 1987 and 1992.",
      "evidence": "players who prefer left foot refers to preferred_foot = 'left'; percentage of players who prefer left foot = DIVIDE(MULTIPLY((SUM(preferred_foot = 'left'), 100)), COUNT(player_fifa_api_id)); born between 1987 and 1992 refers to YEAR(birthday) BETWEEN '1987' AND '1992';",
      "SQL": "SELECT CAST(COUNT(CASE WHEN t2.preferred_foot = 'left' THEN t1.id ELSE NULL END) AS REAL) * 100 / COUNT(t1.id) percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t1.birthday, 1, 4) BETWEEN '1987' AND '1992'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["Player", "Player_Attributes"],
        "columns": [
          "Player_Attributes.preferred_foot",
          "Player.id",
          "Player.player_api_id",
          "Player_Attributes.player_api_id",
          "Player.birthday"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for player information\">Player</table>",
        "<table purpose=\"Required for player attributes, including preferred foot\">Player_Attributes</table>",
        "<column purpose=\"filter: 'players who prefer left foot'\">Player_Attributes.preferred_foot</column>",
        "<column purpose=\"calculate: count of players\">Player.id</column>",
        "<column purpose=\"join: Player.player_api_id\">Player.player_api_id</column>",
        "<column purpose=\"join: Player_Attributes.player_api_id\">Player_Attributes.player_api_id</column>",
        "<column purpose=\"filter: 'born between 1987 and 1992'\">Player.birthday</column>",
        "<output_schema purpose=\"percentage of players who prefer left foot\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for player attributes--><table>Player_Attributes</table>",
        "<!--Required for player birthday--><table>Player</table>",
        "<!--Filter: 'preferred_foot = 'left''--><column>Player_Attributes.preferred_foot</column>",
        "<!--Join: Player.player_fifa_api_id--><column>Player_Attributes.player_fifa_api_id</column>",
        "<!--Join: Player_Attributes.player_fifa_api_id--><column>Player.player_fifa_api_id</column>",
        "<!--Filter: 'born between 1987 and 1992'--><column>Player.birthday</column>",
        "<!--Percentage of players who prefer left foot--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1039,
      "db_id": "european_football_2",
      "question": "Find the average number of long-shot done by Ahmed Samir Farag.",
      "evidence": "average number of long shot = DIVIDE(SUM(long_shots), COUNT(player_fifa_api_id));",
      "SQL": "SELECT CAST(SUM(t2.long_shots) AS REAL) / COUNT(t2.\"date\") FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Ahmed Samir Farag'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["Player", "Player_Attributes"],
        "columns": [
          "Player_Attributes.long_shots",
          "Player_Attributes.date",
          "Player.player_api_id",
          "Player_Attributes.player_api_id",
          "Player.player_name"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to get player information\">Player</table>",
        "<table purpose=\"Required to get player attributes\">Player_Attributes</table>",
        "<column purpose=\"calculate: 'average number of long-shot'\">Player_Attributes.long_shots</column>",
        "<column purpose=\"count: number of records for the player\">Player_Attributes.date</column>",
        "<column purpose=\"join: Player.player_api_id\">Player.player_api_id</column>",
        "<column purpose=\"join: Player_Attributes.player_api_id\">Player_Attributes.player_api_id</column>",
        "<column purpose=\"filter: 'Ahmed Samir Farag'\">Player.player_name</column>",
        "<output_schema purpose=\"average number of long-shot\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for player information--><table>Player</table>",
        "<!--Required for player attributes--><table>Player_Attributes</table>",
        "<!--Join Player and Player_Attributes--><column>Player.player_fifa_api_id</column>",
        "<!--Join Player and Player_Attributes--><column>Player_Attributes.player_fifa_api_id</column>",
        "<!--Filter for Ahmed Samir Farag--><column>Player.player_name</column>",
        "<!--Calculate average long shots--><column>Player_Attributes.long_shots</column>",
        "<!--Average number of long shots--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1040,
      "db_id": "european_football_2",
      "question": "List the top 10 players' names whose heights are above 180 in descending order of average heading accuracy.",
      "evidence": "heights are above 180 refers to Player.height > 180; average heading accuracy = DIVIDE(SUM(heading_accuracy), COUNT(player_fifa_api_id));",
      "SQL": "SELECT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height > 180 GROUP BY t1.id ORDER BY CAST(SUM(t2.heading_accuracy) AS REAL) / COUNT(t2.\"player_fifa_api_id\") DESC LIMIT 10",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Player", "Player_Attributes"],
        "columns": [
          "Player.player_name",
          "Player.player_api_id",
          "Player_Attributes.player_api_id",
          "Player.height",
          "Player.id",
          "Player_Attributes.heading_accuracy",
          "Player_Attributes.player_fifa_api_id"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for player information, including name and height\">Player</table>",
        "<table purpose=\"Required for player attributes, including heading accuracy\">Player_Attributes</table>",
        "<column purpose=\"output: player names for the top 10\">Player.player_name</column>",
        "<column purpose=\"join: Player and Player_Attributes tables\">Player.player_api_id</column>",
        "<column purpose=\"join: Player and Player_Attributes tables\">Player_Attributes.player_api_id</column>",
        "<column purpose=\"filter: 'heights are above 180'\">Player.height</column>",
        "<column purpose=\"group by: to calculate average heading accuracy per player\">Player.id</column>",
        "<column purpose=\"calculate: average heading accuracy\">Player_Attributes.heading_accuracy</column>",
        "<column purpose=\"calculate: average heading accuracy (count distinct players)\">Player_Attributes.player_fifa_api_id</column>",
        "<output_schema purpose=\"List of player names\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for player information--><table>Player</table>",
        "<!--Required for player attributes--><table>Player_Attributes</table>",
        "<!--Filter: 'heights are above 180'--><column>Player.height</column>",
        "<!--Join: Player.player_fifa_api_id--><column>Player_Attributes.player_fifa_api_id</column>",
        "<!--Join: Player_Attributes.player_fifa_api_id--><column>Player.player_fifa_api_id</column>",
        "<!--Calculate: 'average heading accuracy'--><column>Player_Attributes.heading_accuracy</column>",
        "<!--Output: 'players' names'--><column>Player.player_name</column>",
        "<!--Output: player name--><output_schema>text</output_schema>",
        "<!--Output: average heading accuracy--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1042,
      "db_id": "european_football_2",
      "question": "List the name of leagues in which the average goals by the home team is higher than the away team in the 2009/2010 season.",
      "evidence": "name of league refers to League.name; average goals by the home team is higher than the away team = AVG(home_team_goal) > AVG(away_team_goal); AVG(xx_goal) = SUM(xx_goal) / COUNT(DISTINCT Match.id); 2009/2010 season refers to season = '2009/2010'",
      "SQL": "SELECT t1.name FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2009/2010' GROUP BY t1.name HAVING (CAST(SUM(t2.home_team_goal) AS REAL) / COUNT(DISTINCT t2.id)) - (CAST(SUM(t2.away_team_goal) AS REAL) / COUNT(DISTINCT t2.id)) > 0",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["League", "Match"],
        "columns": [
          "League.name",
          "League.id",
          "Match.league_id",
          "Match.season",
          "Match.home_team_goal",
          "Match.id",
          "Match.away_team_goal"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'name of leagues'\">League</table>",
        "<table purpose=\"Required for match data including goals and season\">Match</table>",
        "<column purpose=\"Output: 'name of leagues'\">League.name</column>",
        "<column purpose=\"join: Match.league_id\">League.id</column>",
        "<column purpose=\"join: League.id\">Match.league_id</column>",
        "<column purpose=\"filter: '2009/2010 season'\">Match.season</column>",
        "<column purpose=\"calculate: 'average goals by the home team'\">Match.home_team_goal</column>",
        "<column purpose=\"calculate: distinct match count for average\">Match.id</column>",
        "<column purpose=\"calculate: 'average goals by the away team'\">Match.away_team_goal</column>",
        "<output_schema purpose=\"List the name of leagues\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for league information--><table>League</table>",
        "<!--Required for match information--><table>Match</table>",
        "<!--Join League and Match tables--><column>League.id</column>",
        "<!--Join League and Match tables--><column>Match.league_id</column>",
        "<!--Name of league--><column>League.name</column>",
        "<!--Calculate average home team goals--><column>Match.home_team_goal</column>",
        "<!--Calculate average away team goals--><column>Match.away_team_goal</column>",
        "<!--Filter for 2009/2010 season--><column>Match.season</column>",
        "<!--Name of league--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1044,
      "db_id": "european_football_2",
      "question": "List the football players with a birthyear of 1970 and a birthmonth of October.",
      "evidence": "players with a birthyear of 1970 and a birthmonth of October refers to substr(birthday,1,7) AS 'year-month',WHERE year = '1970' AND month = '10';",
      "SQL": "SELECT player_name FROM Player WHERE SUBSTR(birthday, 1, 7) = '1970-10'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["Player"],
        "columns": ["Player.player_name", "Player.birthday"],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains player information including birthdays\">Player</table>",
        "<column purpose=\"Output: player names born in October 1970\">Player.player_name</column>",
        "<column purpose=\"Filter: birthdays in October 1970\">Player.birthday</column>",
        "<output_schema purpose=\"List of player names\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for player information--><table>Player</table>",
        "<!--Used to extract year and month from birthday--><column>Player.birthday</column>",
        "<!--Required for player identification--><column>Player.player_name</column>",
        "<!--Player name--><output_schema>text</output_schema>",
        "<!--Birth date (year-month)--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1048,
      "db_id": "european_football_2",
      "question": "What is the overall rating of the football player Gabriel Tamas in year 2011?",
      "evidence": "in year 2011 refers to strftime('%Y', date) = '2011';",
      "SQL": "SELECT t2.overall_rating FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Gabriel Tamas' AND strftime('%Y', t2.date) = '2011'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["Player", "Player_Attributes"],
        "columns": [
          "Player_Attributes.overall_rating",
          "Player.player_api_id",
          "Player_Attributes.player_api_id",
          "Player_Attributes.date",
          "Player.player_name"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains player information, including name\">Player</table>",
        "<table purpose=\"Contains player attributes, including overall rating\">Player_Attributes</table>",
        "<column purpose=\"calculate: 'overall rating of the football player'\">Player_Attributes.overall_rating</column>",
        "<column purpose=\"join: Player_Attributes.player_api_id\">Player.player_api_id</column>",
        "<column purpose=\"join: Player.player_api_id\">Player_Attributes.player_api_id</column>",
        "<column purpose=\"filter: 'in year 2011'\">Player_Attributes.date</column>",
        "<column purpose=\"filter: 'Gabriel Tamas'\">Player.player_name</column>",
        "<output_schema purpose=\"overall rating is an integer value\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'overall rating'--><table>Player_Attributes</table>",
        "<!--Required to join with Player table--><table>Player</table>",
        "<!--Filter: 'in year 2011'--><column>Player_Attributes.date</column>",
        "<!--Calculate: 'overall rating'--><column>Player_Attributes.overall_rating</column>",
        "<!--Join: Player.player_api_id--><column>Player_Attributes.player_api_id</column>",
        "<!--Join: Player_Attributes.player_api_id--><column>Player.player_api_id</column>",
        "<!--Filter: 'Gabriel Tamas'--><column>Player.player_name</column>",
        "<!--Overall rating of Gabriel Tamas in 2011--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1057,
      "db_id": "european_football_2",
      "question": "Calculate the average home team goal in the 2010/2011 season in the country of Poland.",
      "evidence": "average home team goal = AVG(home_team_goal)= SUM(home_team_goal) / COUNT(DISTINCT Match.id) WHERE name = 'Poland' and season = '2010/2011';",
      "SQL": "SELECT CAST(SUM(t2.home_team_goal) AS REAL) / COUNT(t2.id) FROM Country AS t1 INNER JOIN Match AS t2 ON t1.id = t2.country_id WHERE t1.name = 'Poland' AND t2.season = '2010/2011'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Country", "Match"],
        "columns": [
          "Match.home_team_goal",
          "Match.id",
          "Country.id",
          "Match.country_id",
          "Match.season",
          "Country.name"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to filter matches by country\">Country</table>",
        "<table purpose=\"Contains match data including goals and season\">Match</table>",
        "<column purpose=\"calculate: 'average home team goal'\">Match.home_team_goal</column>",
        "<column purpose=\"count: distinct matches for average calculation\">Match.id</column>",
        "<column purpose=\"join: Match.country_id\">Country.id</column>",
        "<column purpose=\"join: Country.id\">Match.country_id</column>",
        "<column purpose=\"filter: '2010/2011 season'\">Match.season</column>",
        "<column purpose=\"filter: 'country of Poland'\">Country.name</column>",
        "<output_schema purpose=\"average home team goal\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'home team goal'--><table>Match</table>",
        "<!--Required for 'country of Poland'--><table>Country</table>",
        "<!--Required to link Country and Match--><table>League</table>",
        "<!--Filter: 'season = 2010/2011'--><column>Match.season</column>",
        "<!--Calculate: 'average home team goal'--><column>Match.home_team_goal</column>",
        "<!--Join: Match.country_id--><column>Country.id</column>",
        "<!--Join: Country.id--><column>League.country_id</column>",
        "<!--Join: League.id--><column>Match.league_id</column>",
        "<!--Filter: 'country of Poland'--><column>Country.name</column>",
        "<!--Average home team goal in Poland for 2010/2011 season--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1058,
      "db_id": "european_football_2",
      "question": "Who has the highest average finishing rate between the highest and shortest football player?",
      "evidence": "finishing rate refers to finishing; highest average finishing rate = MAX(AVG(finishing)); highest football player refers to MAX(height); shortest football player refers to MIN(height);",
      "SQL": "SELECT A FROM ( SELECT AVG(finishing) result, 'Max' A FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.height = ( SELECT MAX(height) FROM Player ) UNION SELECT AVG(finishing) result, 'Min' A FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.height = ( SELECT MIN(height) FROM Player ) ) tmp ORDER BY result DESC LIMIT 1",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["Player", "Player", "Player_Attributes", "Player"],
        "columns": [
          "Player.player_api_id",
          "Player.height",
          "Player_Attributes.player_api_id",
          "Player_Attributes.finishing"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for player information, including height\">Player</table>",
        "<table purpose=\"Required for player attributes, including finishing rate\">Player_Attributes</table>",
        "<column purpose=\"join: Player.player_api_id with Player_Attributes.player_api_id\">Player.player_api_id</column>",
        "<column purpose=\"filter: 'highest and shortest football player'\">Player.height</column>",
        "<column purpose=\"join: Player_Attributes.player_api_id with Player.player_api_id\">Player_Attributes.player_api_id</column>",
        "<column purpose=\"calculate: 'highest average finishing rate'\">Player_Attributes.finishing</column>",
        "<output_schema purpose=\"Result indicating 'Max' or 'Min' for highest average finishing rate\">text</output_schema>",
        "<warning>The second occurrence of the Player table is unnecessary and should be removed.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for player attributes--><table>Player_Attributes</table>",
        "<!--Required for player height--><table>Player</table>",
        "<!--Join Player and Player_Attributes--><column>Player.player_api_id</column>",
        "<!--Join Player and Player_Attributes--><column>Player_Attributes.player_api_id</column>",
        "<!--Calculate highest player--><column>Player.height</column>",
        "<!--Calculate shortest player--><column>Player.height</column>",
        "<!--Calculate average finishing rate--><column>Player_Attributes.finishing</column>",
        "<!--Output: player name--><output_schema>text</output_schema>",
        "<!--Output: average finishing rate--><output_schema>real</output_schema>",
        "<!--Output: player height--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1068,
      "db_id": "european_football_2",
      "question": "From 2010 to 2015, what was the average overall rating of players who are higher than 170?",
      "evidence": "from 2010 to 2015 refers to strftime('%Y', date) >= '2010' AND <= '2015'; average overall rating = SUM(t2.overall_rating)/ COUNT(t2.id); higher than 170 refers to Player.height > 170;",
      "SQL": "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height > 170 AND STRFTIME('%Y',t2.\"date\") >= '2010' AND STRFTIME('%Y',t2.\"date\") <= '2015'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Player", "Player_Attributes"],
        "columns": [
          "Player_Attributes.overall_rating",
          "Player_Attributes.id",
          "Player.player_api_id",
          "Player_Attributes.player_api_id",
          "Player_Attributes.date",
          "Player.height"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for player height information\">Player</table>",
        "<table purpose=\"Required for player overall rating and date information\">Player_Attributes</table>",
        "<column purpose=\"calculate: 'average overall rating'\">Player_Attributes.overall_rating</column>",
        "<column purpose=\"calculate: count of players for average\">Player_Attributes.id</column>",
        "<column purpose=\"join: Player_Attributes.player_api_id\">Player.player_api_id</column>",
        "<column purpose=\"join: Player.player_api_id\">Player_Attributes.player_api_id</column>",
        "<column purpose=\"filter: 'from 2010 to 2015'\">Player_Attributes.date</column>",
        "<column purpose=\"filter: 'higher than 170'\">Player.height</column>",
        "<output_schema purpose=\"average overall rating\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for player attributes and overall rating--><table>Player_Attributes</table>",
        "<!--Required for player height--><table>Player</table>",
        "<!--Filter: 'From 2010 to 2015'--><column>Player_Attributes.date</column>",
        "<!--Calculate: 'average overall rating'--><column>Player_Attributes.overall_rating</column>",
        "<!--Filter: 'players who are higher than 170'--><column>Player.height</column>",
        "<!--Join: Player.player_api_id--><column>Player_Attributes.player_api_id</column>",
        "<!--Join: Player_Attributes.player_api_id--><column>Player.player_api_id</column>",
        "<!--Average overall rating of players higher than 170 from 2010 to 2015--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1076,
      "db_id": "european_football_2",
      "question": "What is the difference of the average ball control score between Abdou Diallo and Aaron Appindangoye\n?",
      "evidence": "difference of the average ball control = SUBTRACT(AVG(ball_control WHERE player_name = 'Abdou Diallo'), AVG(ball_control WHERE player_name = 'Aaron Appindangoye')); AVG(ball_control WHERE player_name = 'XX XX') = SUM(CASE WHEN player_name = 'XX XX' THEN ball_control ELSE 0 END) / COUNT(CASE WHEN player_name = 'XX XX' THEN id ELSE NULL END)",
      "SQL": "SELECT CAST(SUM(CASE WHEN t1.player_name = 'Abdou Diallo' THEN t2.ball_control ELSE 0 END) AS REAL) / COUNT(CASE WHEN t1.player_name = 'Abdou Diallo' THEN t2.id ELSE NULL END) - CAST(SUM(CASE WHEN t1.player_name = 'Aaron Appindangoye' THEN t2.ball_control ELSE 0 END) AS REAL) / COUNT(CASE WHEN t1.player_name = 'Aaron Appindangoye' THEN t2.id ELSE NULL END) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["Player", "Player_Attributes"],
        "columns": [
          "Player.player_name",
          "Player_Attributes.ball_control",
          "Player_Attributes.id",
          "Player.player_api_id",
          "Player_Attributes.player_api_id"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for player names and to join with Player_Attributes\">Player</table>",
        "<table purpose=\"Required for ball control scores\">Player_Attributes</table>",
        "<column purpose=\"filter: 'Abdou Diallo' and 'Aaron Appindangoye'\">Player.player_name</column>",
        "<column purpose=\"calculate: average ball control score\">Player_Attributes.ball_control</column>",
        "<column purpose=\"count: number of records for each player\">Player_Attributes.id</column>",
        "<column purpose=\"join: Player.player_api_id\">Player.player_api_id</column>",
        "<column purpose=\"join: Player_Attributes.player_api_id\">Player_Attributes.player_api_id</column>",
        "<output_schema purpose=\"difference of the average ball control scores\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for player names and ball control scores--><table>Player</table>",
        "<!--Required for ball control scores--><table>Player_Attributes</table>",
        "<!--Join Player and Player_Attributes--><column>Player.player_api_id</column>",
        "<!--Join Player and Player_Attributes--><column>Player_Attributes.player_api_id</column>",
        "<!--Filter for 'Abdou Diallo'--><column>Player.player_name</column>",
        "<!--Filter for 'Aaron Appindangoye'--><column>Player.player_name</column>",
        "<!--Calculate average ball control--><column>Player_Attributes.ball_control</column>",
        "<!--Difference of average ball control scores--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1078,
      "db_id": "european_football_2",
      "question": "Which player is older, Aaron Lennon or Abdelaziz Barrada?",
      "evidence": "The larger the birthday value, the younger the person is, and vice versa;",
      "SQL": "SELECT player_name FROM Player WHERE player_name IN ('Aaron Lennon', 'Abdelaziz Barrada') ORDER BY birthday ASC LIMIT 1",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["Player"],
        "columns": ["Player.player_name", "Player.birthday"],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains player information including names and birthdates\">Player</table>",
        "<column purpose=\"filter: 'Aaron Lennon or Abdelaziz Barrada', output: player name\">Player.player_name</column>",
        "<column purpose=\"calculate: 'Which player is older', filter: ORDER BY birthday ASC\">Player.birthday</column>",
        "<output_schema purpose=\"Return the name of the older player\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for comparing player ages--><table>Player</table>",
        "<!--Required to identify Aaron Lennon--><column>Player.player_name</column>",
        "<!--Required to identify Abdelaziz Barrada--><column>Player.player_name</column>",
        "<!--Required to compare ages--><column>Player.birthday</column>",
        "<!--Output for Aaron Lennon's birthday--><output_schema>text</output_schema>",
        "<!--Output for Abdelaziz Barrada's birthday--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1079,
      "db_id": "european_football_2",
      "question": "Which player is the tallest?",
      "evidence": "tallest player refers to MAX(height);",
      "SQL": "SELECT player_name FROM Player ORDER BY height DESC LIMIT 1",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["Player"],
        "columns": ["Player.player_name", "Player.height"],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains player information including height\">Player</table>",
        "<column purpose=\"Retrieve the name of the tallest player\">Player.player_name</column>",
        "<column purpose=\"Used to determine the tallest player\">Player.height</column>",
        "<output_schema purpose=\"The name of the tallest player\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for player height information--><table>Player</table>",
        "<!--Used to find the tallest player--><column>Player.height</column>",
        "<!--Needed to identify the player--><column>Player.player_name</column>",
        "<!--Name of the tallest player--><output_schema>text</output_schema>",
        "<!--Height of the tallest player--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1080,
      "db_id": "european_football_2",
      "question": "Among the players whose preferred foot was the left foot when attacking, how many of them would remain in his position when the team attacked?",
      "evidence": "preferred foot when attacking was the left refers to preferred_foot = 'left'; players who would remain in his position when the team attacked refers to attacking_work_rate = 'low';",
      "SQL": "SELECT COUNT(player_api_id) FROM Player_Attributes WHERE preferred_foot = 'left' AND attacking_work_rate = 'low'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Player_Attributes"],
        "columns": [
          "Player_Attributes.player_api_id",
          "Player_Attributes.attacking_work_rate",
          "Player_Attributes.preferred_foot"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains player attributes including preferred foot and attacking work rate\">Player_Attributes</table>",
        "<column purpose=\"Used for counting unique players\">Player_Attributes.player_api_id</column>",
        "<column purpose=\"filter: 'players who would remain in his position when the team attacked'\">Player_Attributes.attacking_work_rate</column>",
        "<column purpose=\"filter: 'players whose preferred foot was the left foot when attacking'\">Player_Attributes.preferred_foot</column>",
        "<output_schema purpose=\"Count of players meeting the criteria\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'preferred foot was the left foot'--><table>Player_Attributes</table>",
        "<!--filter: 'preferred foot was the left foot'--><column>Player_Attributes.preferred_foot</column>",
        "<!--filter: 'remain in his position when the team attacked'--><column>Player_Attributes.attacking_work_rate</column>",
        "<!--count of players meeting both conditions--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1084,
      "db_id": "european_football_2",
      "question": "Among the players born before the year 1986, how many of them would remain in his position and defense while the team attacked?",
      "evidence": "players born before the year 1986 refers to strftime('%Y', birthday)<'1986'; players who would remain in his position and defense while the team attacked refers to defensive_work_rate = 'high'; Should consider DISTINCT in the final result;",
      "SQL": "SELECT COUNT(DISTINCT t1.player_name) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE STRFTIME('%Y',t1.birthday) < '1986' AND t2.defensive_work_rate = 'high'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["Player", "Player_Attributes"],
        "columns": [
          "Player.player_name",
          "Player.player_api_id",
          "Player_Attributes.player_api_id",
          "Player_Attributes.defensive_work_rate",
          "Player.birthday"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains player information including birthday\">Player</table>",
        "<table purpose=\"Contains player attributes including defensive work rate\">Player_Attributes</table>",
        "<column purpose=\"Used for DISTINCT count of players\">Player.player_name</column>",
        "<column purpose=\"join: Player_Attributes.player_api_id\">Player.player_api_id</column>",
        "<column purpose=\"join: Player.player_api_id\">Player_Attributes.player_api_id</column>",
        "<column purpose=\"filter: 'players who would remain in his position and defense while the team attacked'\">Player_Attributes.defensive_work_rate</column>",
        "<column purpose=\"filter: 'players born before the year 1986'\">Player.birthday</column>",
        "<output_schema purpose=\"Count of distinct players meeting the criteria\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Filter: 'players born before the year 1986'--><table>Player</table>",
        "<!--Filter: 'players born before the year 1986'--><column>Player.birthday</column>",
        "<!--Filter: 'players who would remain in his position and defense while the team attacked'--><table>Player_Attributes</table>",
        "<!--Filter: 'players who would remain in his position and defense while the team attacked'--><column>Player_Attributes.defensive_work_rate</column>",
        "<!--Join Player and Player_Attributes tables--><column>Player.player_api_id</column>",
        "<!--Join Player and Player_Attributes tables--><column>Player_Attributes.player_api_id</column>",
        "<!--Count of distinct players meeting the criteria--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1088,
      "db_id": "european_football_2",
      "question": "Please list the names of the players whose volley score and dribbling score are over 70.",
      "evidence": "volley score are over 70 refers to volleys > 70; dribbling score refers to dribbling are over 70 refers to dribbling > 70;",
      "SQL": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.volleys > 70 AND t2.dribbling > 70",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Player", "Player_Attributes"],
        "columns": [
          "Player.player_name",
          "Player.player_api_id",
          "Player_Attributes.player_api_id",
          "Player_Attributes.dribbling",
          "Player_Attributes.volleys"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains player names\">Player</table>",
        "<table purpose=\"Contains player attribute scores\">Player_Attributes</table>",
        "<column purpose=\"Output: player names\">Player.player_name</column>",
        "<column purpose=\"Join: Player with Player_Attributes\">Player.player_api_id</column>",
        "<column purpose=\"Join: Player_Attributes with Player\">Player_Attributes.player_api_id</column>",
        "<column purpose=\"Filter: dribbling score > 70\">Player_Attributes.dribbling</column>",
        "<column purpose=\"Filter: volley score > 70\">Player_Attributes.volleys</column>",
        "<output_schema purpose=\"List of player names\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for player names--><table>Player</table>",
        "<!--Required for volley and dribbling scores--><table>Player_Attributes</table>",
        "<!--Join Player and Player_Attributes tables--><column>Player.player_api_id</column>",
        "<!--Join Player and Player_Attributes tables--><column>Player_Attributes.player_api_id</column>",
        "<!--Player name for output--><column>Player.player_name</column>",
        "<!--Filter: 'volley score are over 70'--><column>Player_Attributes.volleys</column>",
        "<!--Filter: 'dribbling score are over 70'--><column>Player_Attributes.dribbling</column>",
        "<!--List of player names--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1091,
      "db_id": "european_football_2",
      "question": "How many matches were held in the Belgium Jupiler League in April, 2009?",
      "evidence": "Belgium Jupiler League refers to League.name = 'Belgium Jupiler League'; in April, 2009 refers to SUBSTR(\"date\", 1, 7);",
      "SQL": "SELECT COUNT(t2.id) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t1.name = 'Belgium Jupiler League' AND SUBSTR(t2.\"date\", 1, 7) = '2009-04'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["League", "Match"],
        "columns": [
          "Match.id",
          "League.id",
          "Match.league_id",
          "Match.date",
          "League.name"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to identify the Belgium Jupiler League\">League</table>",
        "<table purpose=\"Contains match data including dates\">Match</table>",
        "<column purpose=\"Used for counting matches\">Match.id</column>",
        "<column purpose=\"Join key with Match.league_id\">League.id</column>",
        "<column purpose=\"Join key with League.id\">Match.league_id</column>",
        "<column purpose=\"Filter: 'in April, 2009'\">Match.date</column>",
        "<column purpose=\"Filter: 'Belgium Jupiler League'\">League.name</column>",
        "<output_schema purpose=\"Count of matches\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Belgium Jupiler League'--><table>League</table>",
        "<!--Required for match information--><table>Match</table>",
        "<!--Filter: 'Belgium Jupiler League'--><column>League.name</column>",
        "<!--Join: Match.league_id--><column>League.id</column>",
        "<!--Join: League.id--><column>Match.league_id</column>",
        "<!--Filter: 'in April, 2009'--><column>Match.date</column>",
        "<!--Count of matches--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1092,
      "db_id": "european_football_2",
      "question": "Give the name of the league had the most matches in the 2008/2009 season?",
      "evidence": "league that had the most matches in the 2008/2009 season refers to MAX(league_name WHERE season = '2008/2009');",
      "SQL": "SELECT t1.name FROM League AS t1 JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2008/2009' GROUP BY t1.name HAVING COUNT(t2.id) = (SELECT MAX(match_count) FROM (SELECT COUNT(t2.id) AS match_count FROM Match AS t2 WHERE t2.season = '2008/2009' GROUP BY t2.league_id) tmp)",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["League", "Match", "Match"],
        "columns": [
          "Match.id",
          "Match.season",
          "Match.league_id",
          "League.name",
          "League.id"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for league information\">League</table>",
        "<table purpose=\"Required for match information\">Match</table>",
        "<table warning=\"Duplicate table reference\">Match</table>",
        "<column purpose=\"count: 'had the most matches'\">Match.id</column>",
        "<column purpose=\"filter: '2008/2009 season'\">Match.season</column>",
        "<column purpose=\"join: League.id\">Match.league_id</column>",
        "<column purpose=\"output: 'name of the league'\">League.name</column>",
        "<column purpose=\"join: Match.league_id\">League.id</column>",
        "<output_schema purpose=\"name of the league\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'league had the most matches'--><table>Match</table>",
        "<!--Required for league name--><table>League</table>",
        "<!--Filter: 'in the 2008/2009 season'--><column>Match.season</column>",
        "<!--Join: Match.league_id--><column>Match.league_id</column>",
        "<!--Join: League.id--><column>League.id</column>",
        "<!--Required for league name--><column>League.name</column>",
        "<!--Name of the league with most matches--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1094,
      "db_id": "european_football_2",
      "question": "How much higher in percentage is Ariel Borysiuk's overall rating than that of Paulin Puel?",
      "evidence": "how much higher in percentage = MULTIPLY(DIVIDE(SUBTRACT(overall_rating WHERE player_name = 'Ariel Borysiuk', overall_rating WHERE player_name = 'Paulin Puel'), overall_rating WHERE player_name = 'Paulin Puel'), 100);",
      "SQL": "SELECT (SUM(CASE WHEN t1.player_name = 'Ariel Borysiuk' THEN t2.overall_rating ELSE 0 END) * 1.0 - SUM(CASE WHEN t1.player_name = 'Paulin Puel' THEN t2.overall_rating ELSE 0 END)) * 100 / SUM(CASE WHEN t1.player_name = 'Paulin Puel' THEN t2.overall_rating ELSE 0 END) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["Player", "Player_Attributes"],
        "columns": [
          "Player.player_name",
          "Player_Attributes.overall_rating",
          "Player.player_api_id",
          "Player_Attributes.player_api_id"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains player names and IDs\">Player</table>",
        "<table purpose=\"Contains player attributes including overall rating\">Player_Attributes</table>",
        "<column purpose=\"filter: 'Ariel Borysiuk' and 'Paulin Puel'\">Player.player_name</column>",
        "<column purpose=\"calculate: difference in overall rating\">Player_Attributes.overall_rating</column>",
        "<column purpose=\"join: Player and Player_Attributes tables\">Player.player_api_id</column>",
        "<column purpose=\"join: Player and Player_Attributes tables\">Player_Attributes.player_api_id</column>",
        "<output_schema purpose=\"percentage difference in overall rating\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for player information--><table>Player</table>",
        "<!--Required for player attributes--><table>Player_Attributes</table>",
        "<!--Join Player and Player_Attributes--><column>Player.player_api_id</column>",
        "<!--Join Player and Player_Attributes--><column>Player_Attributes.player_api_id</column>",
        "<!--Filter for 'Ariel Borysiuk'--><column>Player.player_name</column>",
        "<!--Filter for 'Paulin Puel'--><column>Player.player_name</column>",
        "<!--Calculate percentage difference--><column>Player_Attributes.overall_rating</column>",
        "<!--Percentage difference in overall rating--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1096,
      "db_id": "european_football_2",
      "question": "Calculate the average overall rating of Pietro Marino.",
      "evidence": "Pietro Marino refers to player_name = 'Pietro Marino'; average overall rating AVG(T1.overall_rating)",
      "SQL": "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Pietro Marino'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Player", "Player_Attributes"],
        "columns": [
          "Player_Attributes.overall_rating",
          "Player_Attributes.id",
          "Player.player_api_id",
          "Player_Attributes.player_api_id",
          "Player.player_name"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to identify 'Pietro Marino'\">Player</table>",
        "<table purpose=\"Required for 'overall rating'\">Player_Attributes</table>",
        "<column purpose=\"calculate: 'average overall rating'\">Player_Attributes.overall_rating</column>",
        "<column purpose=\"Used in COUNT() for average calculation\">Player_Attributes.id</column>",
        "<column purpose=\"join: Player_Attributes.player_api_id\">Player.player_api_id</column>",
        "<column purpose=\"join: Player.player_api_id\">Player_Attributes.player_api_id</column>",
        "<column purpose=\"filter: 'Pietro Marino'\">Player.player_name</column>",
        "<output_schema purpose=\"average overall rating\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'average overall rating'--><table>Player_Attributes</table>",
        "<!--Required to identify 'Pietro Marino'--><table>Player</table>",
        "<!--join: Player.player_api_id--><column>Player_Attributes.player_api_id</column>",
        "<!--join: Player_Attributes.player_api_id--><column>Player.player_api_id</column>",
        "<!--filter: 'Pietro Marino'--><column>Player.player_name</column>",
        "<!--calculate: 'average overall rating'--><column>Player_Attributes.overall_rating</column>",
        "<!--average overall rating of Pietro Marino--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1098,
      "db_id": "european_football_2",
      "question": "What is Ajax's highest chance creation passing score and what is it classified as?",
      "evidence": "Ajax's refers to team_long_name = 'Ajax'; chance creation passing score refers to MAX(chanceCreationPassing); classified refer to chanceCreationPassingClass",
      "SQL": "SELECT t2.chanceCreationPassing, t2.chanceCreationPassingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'Ajax' ORDER BY t2.chanceCreationPassing DESC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Team", "Team_Attributes"],
        "columns": [
          "Team_Attributes.chanceCreationPassing",
          "Team_Attributes.chanceCreationPassingClass",
          "Team.team_api_id",
          "Team_Attributes.team_api_id",
          "Team.team_long_name"
        ],
        "output_schema": ["integer", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to identify Ajax\">Team</table>",
        "<table purpose=\"Contains chance creation passing score and class\">Team_Attributes</table>",
        "<column purpose=\"calculate: 'highest chance creation passing score'\">Team_Attributes.chanceCreationPassing</column>",
        "<column purpose=\"output: 'classified as'\">Team_Attributes.chanceCreationPassingClass</column>",
        "<column purpose=\"join: Team_Attributes.team_api_id\">Team.team_api_id</column>",
        "<column purpose=\"join: Team.team_api_id\">Team_Attributes.team_api_id</column>",
        "<column purpose=\"filter: 'Ajax's'\">Team.team_long_name</column>",
        "<output_schema purpose=\"highest chance creation passing score\">integer</output_schema>",
        "<output_schema purpose=\"classification of chance creation passing\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for Ajax's team information--><table>Team</table>",
        "<!--Required for team attributes including chance creation passing score--><table>Team_Attributes</table>",
        "<!--Used to identify Ajax--><column>Team.team_long_name</column>",
        "<!--Join Team and Team_Attributes tables--><column>Team.team_api_id</column>",
        "<!--Join Team and Team_Attributes tables--><column>Team_Attributes.team_api_id</column>",
        "<!--Highest chance creation passing score--><column>Team_Attributes.chanceCreationPassing</column>",
        "<!--Classification of chance creation passing--><column>Team_Attributes.chanceCreationPassingClass</column>",
        "<!--Highest chance creation passing score--><output_schema>integer</output_schema>",
        "<!--Classification of the highest score--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1102,
      "db_id": "european_football_2",
      "question": "For the players who had a 77 points overall rating on 2016/6/23, who was the oldest? Give the name of the player.",
      "evidence": "77 points overall rating refers to overall_rating = 77; on 2016/6/23 refers to date LIKE '2016-06-23%'; The larger the birthday value, the younger the person is, and vice versa;",
      "SQL": "SELECT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t2.\"date\", 1, 10) = '2016-06-23' AND t2.overall_rating = 77 ORDER BY t1.birthday ASC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Player", "Player_Attributes"],
        "columns": [
          "Player.player_name",
          "Player.player_api_id",
          "Player_Attributes.player_api_id",
          "Player_Attributes.overall_rating",
          "Player_Attributes.date",
          "Player.birthday"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains player information including name and birthday\">Player</table>",
        "<table purpose=\"Contains player attributes including overall rating and date of rating\">Player_Attributes</table>",
        "<column purpose=\"join: Player.player_api_id, output: 'name of the player'\">Player.player_name</column>",
        "<column purpose=\"join: Player_Attributes.player_api_id\">Player.player_api_id</column>",
        "<column purpose=\"join: Player.player_api_id\">Player_Attributes.player_api_id</column>",
        "<column purpose=\"filter: '77 points overall rating'\">Player_Attributes.overall_rating</column>",
        "<column purpose=\"filter: 'on 2016/6/23'\">Player_Attributes.date</column>",
        "<column purpose=\"sort: 'who was the oldest?'\">Player.birthday</column>",
        "<output_schema purpose=\"name of the player\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'overall rating'--><table>Player_Attributes</table>",
        "<!--Required for player name and birthday--><table>Player</table>",
        "<!--Filter: 'overall rating = 77'--><column>Player_Attributes.overall_rating</column>",
        "<!--Filter: 'on 2016/6/23'--><column>Player_Attributes.date</column>",
        "<!--Join: Player.player_api_id--><column>Player_Attributes.player_api_id</column>",
        "<!--Join: Player_Attributes.player_api_id--><column>Player.player_api_id</column>",
        "<!--Output: 'name of the player'--><column>Player.player_name</column>",
        "<!--Sort: 'who was the oldest'--><column>Player.birthday</column>",
        "<!--Name of the oldest player--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1103,
      "db_id": "european_football_2",
      "question": "What was the overall rating for Aaron Mooy on 2016/2/4?",
      "evidence": "Aaron Mooy refers to player_name = 'Aaron Mooy'; on 2016/2/4 refers to date LIKE '2016-02-04%';",
      "SQL": "SELECT t2.overall_rating FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t2.\"date\", 1, 10) = '2016-02-04' AND t1.player_name = 'Aaron Mooy'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Player", "Player_Attributes"],
        "columns": [
          "Player_Attributes.overall_rating",
          "Player.player_api_id",
          "Player_Attributes.player_api_id",
          "Player_Attributes.date",
          "Player.player_name"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains player information, including name\">Player</table>",
        "<table purpose=\"Contains player attributes, including overall rating and date\">Player_Attributes</table>",
        "<column purpose=\"calculate: 'overall rating for Aaron Mooy'\">Player_Attributes.overall_rating</column>",
        "<column purpose=\"join: Player_Attributes.player_api_id\">Player.player_api_id</column>",
        "<column purpose=\"join: Player.player_api_id\">Player_Attributes.player_api_id</column>",
        "<column purpose=\"filter: 'on 2016/2/4'\">Player_Attributes.date</column>",
        "<column purpose=\"filter: 'Aaron Mooy'\">Player.player_name</column>",
        "<output_schema purpose=\"overall rating is an integer value\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Aaron Mooy'--><table>Player</table>",
        "<!--Required for 'overall rating'--><table>Player_Attributes</table>",
        "<!--filter: 'Aaron Mooy'--><column>Player.player_name</column>",
        "<!--join: Player.player_api_id--><column>Player_Attributes.player_api_id</column>",
        "<!--join: Player_Attributes.player_api_id--><column>Player.player_api_id</column>",
        "<!--filter: 'on 2016/2/4'--><column>Player_Attributes.date</column>",
        "<!--'overall rating'--><column>Player_Attributes.overall_rating</column>",
        "<!--overall rating for Aaron Mooy on 2016/2/4--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1105,
      "db_id": "european_football_2",
      "question": "How was Francesco Migliore's attacking work rate on 2015/5/1?",
      "evidence": "Francesco Migliore refers to player_name = 'Francesco Migliore'; on 2015/5/1 refers to date LIKE '2015-05-01%';",
      "SQL": "SELECT t2.attacking_work_rate FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.\"date\" LIKE '2015-05-01%' AND t1.player_name = 'Francesco Migliore'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Player", "Player_Attributes"],
        "columns": [
          "Player_Attributes.attacking_work_rate",
          "Player.player_api_id",
          "Player_Attributes.player_api_id",
          "Player_Attributes.date",
          "Player.player_name"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains player information, including name\">Player</table>",
        "<table purpose=\"Contains player attributes, including attacking work rate\">Player_Attributes</table>",
        "<column purpose=\"retrieve: 'Francesco Migliore's attacking work rate'\">Player_Attributes.attacking_work_rate</column>",
        "<column purpose=\"join: Player.player_api_id\">Player.player_api_id</column>",
        "<column purpose=\"join: Player_Attributes.player_api_id\">Player_Attributes.player_api_id</column>",
        "<column purpose=\"filter: 'on 2015/5/1'\">Player_Attributes.date</column>",
        "<column purpose=\"filter: 'Francesco Migliore'\">Player.player_name</column>",
        "<output_schema purpose=\"attacking work rate is a text value\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for player information--><table>Player</table>",
        "<!--Required for player attributes--><table>Player_Attributes</table>",
        "<!--Join Player and Player_Attributes--><column>Player.player_api_id</column>",
        "<!--Join Player and Player_Attributes--><column>Player_Attributes.player_api_id</column>",
        "<!--Filter for specific player--><column>Player.player_name</column>",
        "<!--Filter for specific date--><column>Player_Attributes.date</column>",
        "<!--Retrieve attacking work rate--><column>Player_Attributes.attacking_work_rate</column>",
        "<!--Francesco Migliore's attacking work rate on 2015/5/1--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1107,
      "db_id": "european_football_2",
      "question": "When was the first time did Kevin Constant have his highest crossing score? Give the date.",
      "evidence": "Kevin Constant refers to player_name = 'Kevin Constant'; highest crossing score refers to MAX(crossing)",
      "SQL": "SELECT \"date\" FROM ( SELECT t2.crossing, t2.\"date\" FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE t1.player_name = 'Kevin Constant' ORDER BY t2.crossing DESC) ORDER BY date DESC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Player", "Player_Attributes"],
        "columns": [
          "Player_Attributes.date",
          "Player.player_fifa_api_id",
          "Player_Attributes.player_fifa_api_id",
          "Player.player_name"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to find Kevin Constant's player information\">Player</table>",
        "<table purpose=\"Required to find Kevin Constant's attribute scores\">Player_Attributes</table>",
        "<column purpose=\"Output: date of the highest crossing score\">Player_Attributes.date</column>",
        "<column purpose=\"Join: Player and Player_Attributes tables\">Player.player_fifa_api_id</column>",
        "<column purpose=\"Join: Player and Player_Attributes tables\">Player_Attributes.player_fifa_api_id</column>",
        "<column purpose=\"Filter: 'Kevin Constant'\">Player.player_name</column>",
        "<column purpose=\"Calculate: highest crossing score\">Player_Attributes.crossing</column>",
        "<output_schema purpose=\"Date of the highest crossing score\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for player information--><table>Player</table>",
        "<!--Required for player attributes--><table>Player_Attributes</table>",
        "<!--Join Player and Player_Attributes--><column>Player.player_api_id</column>",
        "<!--Join Player and Player_Attributes--><column>Player_Attributes.player_api_id</column>",
        "<!--Filter for 'Kevin Constant'--><column>Player.player_name</column>",
        "<!--Find the highest crossing score--><column>Player_Attributes.crossing</column>",
        "<!--Get the date of the highest crossing score--><column>Player_Attributes.date</column>",
        "<!--Output the date of the first highest crossing score--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1110,
      "db_id": "european_football_2",
      "question": "Tell the build Up play passing class for \"FC Lorient\" on 2010/2/22.",
      "evidence": "\"FC Lorient\" refers to team_long_name = 'FC Lorient'; on 2010/2/22 refers to date LIKE '2010-02-22%';",
      "SQL": "SELECT t2.buildUpPlayPassingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'FC Lorient' AND t2.\"date\" LIKE '2010-02-22%'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Team", "Team_Attributes"],
        "columns": [
          "Team_Attributes.buildUpPlayPassingClass",
          "Team.team_api_id",
          "Team_Attributes.team_api_id",
          "Team_Attributes.date",
          "Team.team_long_name"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to get team information for 'FC Lorient'\">Team</table>",
        "<table purpose=\"Required to get build up play passing class\">Team_Attributes</table>",
        "<column purpose=\"calculate: 'build Up play passing class'\">Team_Attributes.buildUpPlayPassingClass</column>",
        "<column purpose=\"join: Team_Attributes.team_api_id\">Team.team_api_id</column>",
        "<column purpose=\"join: Team.team_api_id\">Team_Attributes.team_api_id</column>",
        "<column purpose=\"filter: 'on 2010/2/22'\">Team_Attributes.date</column>",
        "<column purpose=\"filter: 'FC Lorient'\">Team.team_long_name</column>",
        "<output_schema purpose=\"build Up play passing class\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for team information--><table>Team</table>",
        "<!--Required for team attributes--><table>Team_Attributes</table>",
        "<!--To match team name--><column>Team.team_long_name</column>",
        "<!--To join Team and Team_Attributes--><column>Team.team_api_id</column>",
        "<!--To join Team and Team_Attributes--><column>Team_Attributes.team_api_id</column>",
        "<!--To filter by date--><column>Team_Attributes.date</column>",
        "<!--To get build up play passing class--><column>Team_Attributes.buildUpPlayPassingClass</column>",
        "<!--Build up play passing class for FC Lorient on 2010/2/22--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1113,
      "db_id": "european_football_2",
      "question": "For the team \"Hannover 96\", what was its defence aggression class on 2015/9/10?",
      "evidence": "\"Hannover 96\" refers to team_long_name = 'Hannover 96'; on 2015/9/10 refers to date LIKE '2015-09-10%';",
      "SQL": "SELECT t2.defenceAggressionClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'Hannover 96' AND t2.\"date\" LIKE '2015-09-10%'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Team", "Team_Attributes"],
        "columns": [
          "Team_Attributes.defenceAggressionClass",
          "Team.team_api_id",
          "Team_Attributes.team_api_id",
          "Team_Attributes.date",
          "Team.team_long_name"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to get team information for 'Hannover 96'\">Team</table>",
        "<table purpose=\"Required to get defence aggression class for the team\">Team_Attributes</table>",
        "<column purpose=\"Output: 'defence aggression class'\">Team_Attributes.defenceAggressionClass</column>",
        "<column purpose=\"Join: Team.team_api_id\">Team.team_api_id</column>",
        "<column purpose=\"Join: Team_Attributes.team_api_id\">Team_Attributes.team_api_id</column>",
        "<column purpose=\"Filter: 'on 2015/9/10'\">Team_Attributes.date</column>",
        "<column purpose=\"Filter: 'Hannover 96'\">Team.team_long_name</column>",
        "<output_schema purpose=\"defence aggression class is a text value\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for team information--><table>Team</table>",
        "<!--Required for team attributes--><table>Team_Attributes</table>",
        "<!--Filter for team name--><column>Team.team_long_name</column>",
        "<!--Join Team and Team_Attributes--><column>Team.team_api_id</column>",
        "<!--Join Team and Team_Attributes--><column>Team_Attributes.team_api_id</column>",
        "<!--Filter for specific date--><column>Team_Attributes.date</column>",
        "<!--Required attribute for the question--><column>Team_Attributes.defenceAggressionClass</column>",
        "<!--Defence aggression class for Hannover 96 on 2015/9/10--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1114,
      "db_id": "european_football_2",
      "question": "What was the average overall rating for Marko Arnautovic from 2007/2/22 to 2016/4/21?",
      "evidence": "average overall rating refers to avg(overall_rating); Marko Arnautovic refers to player_name = 'Marko Arnautovic'; from 2007/2/22 to 2016/4/21 refers to the first 10 characters of date BETWEEN '2007-02-22' and '2016-04-21'",
      "SQL": "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE t1.player_name = 'Marko Arnautovic' AND SUBSTR(t2.\"date\", 1, 10) BETWEEN '2007-02-22' AND '2016-04-21'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["Player", "Player_Attributes"],
        "columns": [
          "Player_Attributes.overall_rating",
          "Player_Attributes.id",
          "Player.player_fifa_api_id",
          "Player_Attributes.player_fifa_api_id",
          "Player_Attributes.date",
          "Player.player_name"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for player information\">Player</table>",
        "<table purpose=\"Required for player attributes and ratings\">Player_Attributes</table>",
        "<column purpose=\"calculate: 'average overall rating'\">Player_Attributes.overall_rating</column>",
        "<column purpose=\"Used for counting records\">Player_Attributes.id</column>",
        "<column purpose=\"join: Player_Attributes.player_fifa_api_id\">Player.player_fifa_api_id</column>",
        "<column purpose=\"join: Player.player_fifa_api_id\">Player_Attributes.player_fifa_api_id</column>",
        "<column purpose=\"filter: 'from 2007/2/22 to 2016/4/21'\">Player_Attributes.date</column>",
        "<column purpose=\"filter: 'Marko Arnautovic'\">Player.player_name</column>",
        "<output_schema purpose=\"average overall rating\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for player information--><table>Player</table>",
        "<!--Required for player attributes--><table>Player_Attributes</table>",
        "<!--Join Player and Player_Attributes--><column>Player.player_api_id</column>",
        "<!--Join Player and Player_Attributes--><column>Player_Attributes.player_api_id</column>",
        "<!--Filter for 'Marko Arnautovic'--><column>Player.player_name</column>",
        "<!--Calculate 'average overall rating'--><column>Player_Attributes.overall_rating</column>",
        "<!--Filter date range--><column>Player_Attributes.date</column>",
        "<!--Average overall rating for Marko Arnautovic--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1115,
      "db_id": "european_football_2",
      "question": "What percentage is Landon Donovan's overall rating higher than Jordan Bowery on 2013/7/12?",
      "evidence": "Landon Donovan's refers to player_name = 'Landon Donovan'; Jordan Bowery refers to player_name = 'Jordan Bowery'; percentage refers to DIVIDE(SUBTRACT(player_name = 'Landon Donovan' overall_rating; player_name = 'Jordan Bowery' overall_rating), player_name = 'Landon Donovan' overall_rating)*100",
      "SQL": "SELECT (SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) * 1.0 - SUM(CASE WHEN t1.player_name = 'Jordan Bowery' THEN t2.overall_rating ELSE 0 END)) * 100 / SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) LvsJ_percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE SUBSTR(t2.\"date\", 1, 10) = '2013-07-12'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["Player", "Player_Attributes"],
        "columns": [
          "Player.player_name",
          "Player_Attributes.overall_rating",
          "Player.player_fifa_api_id",
          "Player_Attributes.player_fifa_api_id",
          "Player_Attributes.date"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains player names and IDs\">Player</table>",
        "<table purpose=\"Contains player attributes including overall rating\">Player_Attributes</table>",
        "<column purpose=\"filter: 'Landon Donovan' and 'Jordan Bowery'\">Player.player_name</column>",
        "<column purpose=\"calculate: percentage difference in overall rating\">Player_Attributes.overall_rating</column>",
        "<column purpose=\"join: Player and Player_Attributes tables\">Player.player_fifa_api_id</column>",
        "<column purpose=\"join: Player and Player_Attributes tables\">Player_Attributes.player_fifa_api_id</column>",
        "<column purpose=\"filter: '2013/7/12'\">Player_Attributes.date</column>",
        "<output_schema purpose=\"percentage difference in overall rating\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for player information--><table>Player</table>",
        "<!--Required for player attributes--><table>Player_Attributes</table>",
        "<!--Join Player and Player_Attributes--><column>Player.player_api_id</column>",
        "<!--Join Player and Player_Attributes--><column>Player_Attributes.player_api_id</column>",
        "<!--Filter for Landon Donovan--><column>Player.player_name</column>",
        "<!--Filter for Jordan Bowery--><column>Player.player_name</column>",
        "<!--Filter for date 2013/7/12--><column>Player_Attributes.date</column>",
        "<!--Calculate percentage difference--><column>Player_Attributes.overall_rating</column>",
        "<!--Percentage difference in overall rating--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 1116,
      "db_id": "european_football_2",
      "question": "List down most tallest players' name.",
      "evidence": "tallest refers to rank based on the height in descending order; Most tallest players refers to rank = 1 ",
      "SQL": "SELECT player_name FROM (SELECT player_name, height, DENSE_RANK() OVER (ORDER BY height DESC) as rank FROM Player) WHERE rank = 1",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["Player"],
        "columns": ["Player.player_name", "Player.height"],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains player information including height\">Player</table>",
        "<column purpose=\"To display the names of the tallest players\">Player.player_name</column>",
        "<column purpose=\"To rank players based on height\">Player.height</column>",
        "<output_schema purpose=\"To display the names of the tallest players\">text</output_schema>",
        "<warning>The proposal is missing a way to rank the players. Consider adding a window function or subquery to create the rank.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for player information--><table>Player</table>",
        "<!--Required to get player names--><column>Player.player_name</column>",
        "<!--Required to determine height and rank--><column>Player.height</column>",
        "<!--Output: player names of the tallest players--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1122,
      "db_id": "european_football_2",
      "question": "State the name of the most strongest player.",
      "evidence": "strongest players refers to player has MAX(overall_rating)",
      "SQL": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes)",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["Player", "Player_Attributes", "Player_Attributes"],
        "columns": [
          "Player_Attributes.overall_rating",
          "Player.player_name",
          "Player.player_api_id",
          "Player_Attributes.player_api_id"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains player information including name\">Player</table>",
        "<table purpose=\"Contains player attributes including overall rating\">Player_Attributes</table>",
        "<table purpose=\"Used for subquery to find maximum overall rating\">Player_Attributes</table>",
        "<column purpose=\"calculate: find MAX(overall_rating)\">Player_Attributes.overall_rating</column>",
        "<column purpose=\"output: 'name of the most strongest player'\">Player.player_name</column>",
        "<column purpose=\"join: Player and Player_Attributes tables\">Player.player_api_id</column>",
        "<column purpose=\"join: Player and Player_Attributes tables\">Player_Attributes.player_api_id</column>",
        "<output_schema purpose=\"player name as text\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'strongest player'--><table>Player_Attributes</table>",
        "<!--Required for player name--><table>Player</table>",
        "<!--calculate: 'strongest player'--><column>Player_Attributes.overall_rating</column>",
        "<!--join: Player.player_api_id--><column>Player_Attributes.player_api_id</column>",
        "<!--join: Player_Attributes.player_api_id--><column>Player.player_api_id</column>",
        "<!--output: 'name of the most strongest player'--><column>Player.player_name</column>",
        "<!--name of the most strongest player--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1124,
      "db_id": "european_football_2",
      "question": "Who are the players that tend to be attacking when their mates were doing attack moves? List down their name.",
      "evidence": "tend to be attacking when their mates were doing attack moves refers to attacking_work_rate = 'high';",
      "SQL": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.attacking_work_rate = 'high'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Player", "Player_Attributes"],
        "columns": [
          "Player.player_name",
          "Player.player_api_id",
          "Player_Attributes.player_api_id",
          "Player_Attributes.attacking_work_rate"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for player names\">Player</table>",
        "<table purpose=\"Required for player attributes, specifically attacking_work_rate\">Player_Attributes</table>",
        "<column purpose=\"output: 'List down their name'\">Player.player_name</column>",
        "<column purpose=\"join: Player_Attributes.player_api_id\">Player.player_api_id</column>",
        "<column purpose=\"join: Player.player_api_id\">Player_Attributes.player_api_id</column>",
        "<column purpose=\"filter: 'tend to be attacking when their mates were doing attack moves refers to attacking_work_rate = 'high''\">Player_Attributes.attacking_work_rate</column>",
        "<output_schema purpose=\"player names\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for player information--><table>Player</table>",
        "<!--Required for player attributes--><table>Player_Attributes</table>",
        "<!--Player name--><column>Player.player_name</column>",
        "<!--Join Player and Player_Attributes--><column>Player.player_api_id</column>",
        "<!--Join Player and Player_Attributes--><column>Player_Attributes.player_api_id</column>",
        "<!--Filter for 'high' attacking work rate--><column>Player_Attributes.attacking_work_rate</column>",
        "<!--List of player names--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1130,
      "db_id": "european_football_2",
      "question": "What are the short name of team who played safe while creating chance of passing?",
      "evidence": "played safe while creating chance of passing refers to chanceCreationPassingClass = 'Safe'; short name of team refers to team_short_name",
      "SQL": "SELECT DISTINCT t1.team_short_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.chanceCreationPassingClass = 'Safe'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Team", "Team_Attributes"],
        "columns": [
          "Team.team_short_name",
          "Team.team_api_id",
          "Team_Attributes.team_api_id",
          "Team_Attributes.chanceCreationPassingClass"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for team short name\">Team</table>",
        "<table purpose=\"Required for chance creation passing class\">Team_Attributes</table>",
        "<column purpose=\"output: 'short name of team'\">Team.team_short_name</column>",
        "<column purpose=\"join: Team_Attributes.team_api_id\">Team.team_api_id</column>",
        "<column purpose=\"join: Team.team_api_id\">Team_Attributes.team_api_id</column>",
        "<column purpose=\"filter: 'played safe while creating chance of passing'\">Team_Attributes.chanceCreationPassingClass</column>",
        "<output_schema purpose=\"short name of team\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'chanceCreationPassingClass'--><table>Team_Attributes</table>",
        "<!--Required for 'team_short_name'--><table>Team</table>",
        "<!--Filter: 'played safe while creating chance of passing'--><column>Team_Attributes.chanceCreationPassingClass</column>",
        "<!--Join: Team.team_api_id--><column>Team_Attributes.team_api_id</column>",
        "<!--Join: Team_Attributes.team_api_id--><column>Team.team_api_id</column>",
        "<!--Output: 'short name of team'--><column>Team.team_short_name</column>",
        "<!--List of team short names--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1133,
      "db_id": "european_football_2",
      "question": "How many football players born after the 1990s have the first name \"Aaron\"?",
      "evidence": "first name \"Aaron\" refers to player_name LIKE 'Aaron%'; born after the 1990s refers to birthday > '1990'",
      "SQL": "SELECT COUNT(id) FROM Player WHERE birthday > '1990' AND player_name LIKE 'Aaron%'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["Player"],
        "columns": ["Player.id", "Player.birthday", "Player.player_name"],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains player information including name and birthday\">Player</table>",
        "<column purpose=\"Used for counting unique players\">Player.id</column>",
        "<column purpose=\"Filter: 'born after the 1990s'\">Player.birthday</column>",
        "<column purpose=\"Filter: 'first name Aaron'\">Player.player_name</column>",
        "<output_schema purpose=\"Count of players meeting the criteria\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for player information--><table>Player</table>",
        "<!--Filter: 'born after the 1990s'--><column>Player.birthday</column>",
        "<!--Filter: 'first name \"Aaron\"'--><column>Player.player_name</column>",
        "<!--Count of players meeting criteria--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1134,
      "db_id": "european_football_2",
      "question": "What is the difference between players 6 and 23's jumping scores?",
      "evidence": "difference between players 6 and 23's jumping scores refers to SUBTRACT(jumping AND id = 6,jumping AND id = 23)",
      "SQL": "SELECT SUM(CASE WHEN t1.id = 6 THEN t1.jumping ELSE 0 END) - SUM(CASE WHEN t1.id = 23 THEN t1.jumping ELSE 0 END) FROM Player_Attributes AS t1",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["Player_Attributes"],
        "columns": ["Player_Attributes.id", "Player_Attributes.jumping"],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains player attributes including jumping scores\">Player_Attributes</table>",
        "<column purpose=\"filter: 'players 6 and 23'\">Player_Attributes.id</column>",
        "<column purpose=\"calculate: 'difference between players 6 and 23's jumping scores'\">Player_Attributes.jumping</column>",
        "<output_schema purpose=\"difference between jumping scores\">integer</output_schema>",
        "<warning>The query may return multiple rows for each player if there are multiple entries in Player_Attributes for the same player. Consider using MAX() or a specific date to ensure one value per player.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'players 6 and 23's jumping scores'--><table>Player_Attributes</table>",
        "<!--Filter for player 6--><column>Player_Attributes.id</column>",
        "<!--Filter for player 23--><column>Player_Attributes.id</column>",
        "<!--Calculate difference in jumping scores--><column>Player_Attributes.jumping</column>",
        "<!--Difference between players 6 and 23's jumping scores--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1135,
      "db_id": "european_football_2",
      "question": "Please provide top four football players' IDs who are among the lowest potential players and prefer to use the right foot when attacking.",
      "evidence": "lowest potential players refers to MIN(potential); prefer to use the right foot when attacking refers to preferred_foot = 'right'",
      "SQL": "SELECT id FROM Player_Attributes WHERE preferred_foot = 'right' ORDER BY potential ASC LIMIT 4",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Player_Attributes"],
        "columns": [
          "Player_Attributes.id",
          "Player_Attributes.preferred_foot",
          "Player_Attributes.potential"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains player attributes including potential and preferred foot\">Player_Attributes</table>",
        "<column purpose=\"Unique identifier for players, used for output\">Player_Attributes.id</column>",
        "<column purpose=\"Filter: 'prefer to use the right foot when attacking'\">Player_Attributes.preferred_foot</column>",
        "<column purpose=\"Sort: 'lowest potential players'\">Player_Attributes.potential</column>",
        "<output_schema purpose=\"Player IDs of the top four lowest potential right-footed players\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for player attributes--><table>Player_Attributes</table>",
        "<!--Required for player names--><table>Player</table>",
        "<!--Filter for right-footed players--><column>Player_Attributes.preferred_foot</column>",
        "<!--Calculate lowest potential--><column>Player_Attributes.potential</column>",
        "<!--Join Player and Player_Attributes tables--><column>Player.player_api_id</column>",
        "<!--Join Player and Player_Attributes tables--><column>Player_Attributes.player_api_id</column>",
        "<!--Output player IDs--><column>Player.player_api_id</column>",
        "<!--Output player names--><column>Player.player_name</column>",
        "<!--Player IDs of top four lowest potential, right-footed players--><output_schema>integer</output_schema>",
        "<!--Names of top four lowest potential, right-footed players--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1136,
      "db_id": "european_football_2",
      "question": "How many players had the highest potential score for crossing that preferred to use their left foots while attacking?",
      "evidence": "highest potential score for crossing refers to MAX(crossing); preferred to use their left foots while attacking refers to preferred_foot = 'left'",
      "SQL": "SELECT COUNT(t1.id) FROM Player_Attributes AS t1 WHERE t1.preferred_foot = 'left' AND t1.crossing = ( SELECT MAX(crossing) FROM Player_Attributes)",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Player_Attributes", "Player_Attributes"],
        "columns": [
          "Player_Attributes.crossing",
          "Player_Attributes.id",
          "Player_Attributes.preferred_foot"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains player attributes including crossing and preferred foot\">Player_Attributes</table>",
        "<table purpose=\"Used in subquery to find the maximum crossing value\">Player_Attributes</table>",
        "<column purpose=\"calculate: 'highest potential score for crossing', filter: MAX(crossing)\">Player_Attributes.crossing</column>",
        "<column purpose=\"count: 'How many players'\">Player_Attributes.id</column>",
        "<column purpose=\"filter: 'preferred to use their left foots while attacking'\">Player_Attributes.preferred_foot</column>",
        "<output_schema purpose=\"count of players meeting the criteria\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'highest potential score for crossing'--><table>Player_Attributes</table>",
        "<!--Required for 'preferred to use their left foots while attacking'--><table>Player_Attributes</table>",
        "<!--calculate: 'highest potential score for crossing'--><column>Player_Attributes.crossing</column>",
        "<!--filter: 'preferred to use their left foots while attacking'--><column>Player_Attributes.preferred_foot</column>",
        "<!--count of players--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1139,
      "db_id": "european_football_2",
      "question": "What was the final score for the match on September 24, 2008, in the Belgian Jupiler League between the home team and the away team?",
      "evidence": "September 24, 2008 refers to date like '2008-09-24%'; in the Belgian Jupiler League refers to League.name = 'Belgium Jupiler League'; final score for home team refers to home_team_goal; final score for away team refers to away_team_goal",
      "SQL": "SELECT t2.home_team_goal, t2.away_team_goal FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t1.name = 'Belgium Jupiler League' AND t2.\"date\" LIKE '2008-09-24%'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["League", "Match"],
        "columns": [
          "Match.home_team_goal",
          "Match.away_team_goal",
          "League.id",
          "Match.league_id",
          "Match.date",
          "League.name"
        ],
        "output_schema": ["integer", "integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to identify the Belgian Jupiler League\">League</table>",
        "<table purpose=\"Contains match information including scores and date\">Match</table>",
        "<column purpose=\"calculate: final score for home team\">Match.home_team_goal</column>",
        "<column purpose=\"calculate: final score for away team\">Match.away_team_goal</column>",
        "<column purpose=\"join: Match.league_id\">League.id</column>",
        "<column purpose=\"join: League.id\">Match.league_id</column>",
        "<column purpose=\"filter: 'on September 24, 2008'\">Match.date</column>",
        "<column purpose=\"filter: 'in the Belgian Jupiler League'\">League.name</column>",
        "<output_schema purpose=\"final score for home team\">integer</output_schema>",
        "<output_schema purpose=\"final score for away team\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for match details--><table>Match</table>",
        "<!--Required to identify the league--><table>League</table>",
        "<!--Required to join Match and League tables--><table>Country</table>",
        "<!--Filter: 'on September 24, 2008'--><column>Match.date</column>",
        "<!--Join: Match.league_id--><column>League.id</column>",
        "<!--Filter: 'in the Belgian Jupiler League'--><column>League.name</column>",
        "<!--Join: League.country_id--><column>Country.id</column>",
        "<!--Calculate: 'final score for the match'--><column>Match.home_team_goal</column>",
        "<!--Calculate: 'final score for the match'--><column>Match.away_team_goal</column>",
        "<!--Home team score--><output_schema>integer</output_schema>",
        "<!--Away team score--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1141,
      "db_id": "european_football_2",
      "question": "Does the KSV Cercle Brugge team have a slow, balanced or fast speed class?",
      "evidence": "KSV Cercle Brugge refers to team_long_name = 'KSV Cercle Brugge'; speed class refers to buildUpPlaySpeedClass",
      "SQL": "SELECT DISTINCT t1.buildUpPlaySpeedClass FROM Team_Attributes AS t1 INNER JOIN Team AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.team_long_name = 'KSV Cercle Brugge'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Team_Attributes", "Team"],
        "columns": [
          "Team_Attributes.buildUpPlaySpeedClass",
          "Team_Attributes.team_api_id",
          "Team.team_api_id",
          "Team.team_long_name"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains team attributes including buildUpPlaySpeedClass\">Team_Attributes</table>",
        "<table purpose=\"Contains team information including team_long_name\">Team</table>",
        "<column purpose=\"filter: 'slow, balanced or fast speed class'\">Team_Attributes.buildUpPlaySpeedClass</column>",
        "<column purpose=\"join: Team.team_api_id\">Team_Attributes.team_api_id</column>",
        "<column purpose=\"join: Team_Attributes.team_api_id\">Team.team_api_id</column>",
        "<column purpose=\"filter: 'KSV Cercle Brugge'\">Team.team_long_name</column>",
        "<output_schema purpose=\"speed class of KSV Cercle Brugge\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for team information--><table>Team</table>",
        "<!--Required for team attributes--><table>Team_Attributes</table>",
        "<!--To identify the team--><column>Team.team_long_name</column>",
        "<!--To link Team and Team_Attributes--><column>Team.team_api_id</column>",
        "<!--To link Team and Team_Attributes--><column>Team_Attributes.team_api_id</column>",
        "<!--The required attribute for speed class--><column>Team_Attributes.buildUpPlaySpeedClass</column>",
        "<!--The speed class of KSV Cercle Brugge--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1144,
      "db_id": "european_football_2",
      "question": "Please state the finishing rate and curve score of the player who has the heaviest weight.",
      "evidence": "finishing rate refer to finishing; curve score refer to curve; heaviest weight refers to MAX(weight)",
      "SQL": "SELECT id, finishing, curve FROM Player_Attributes WHERE player_api_id = ( SELECT player_api_id FROM Player ORDER BY weight DESC LIMIT 1 ) LIMIT 1",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["Player_Attributes", "Player"],
        "columns": [
          "Player.player_api_id",
          "Player.weight",
          "Player_Attributes.id",
          "Player_Attributes.finishing",
          "Player_Attributes.curve",
          "Player_Attributes.player_api_id"
        ],
        "output_schema": ["integer", "integer", "integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains player attributes including finishing and curve scores\">Player_Attributes</table>",
        "<table purpose=\"Contains player information including weight\">Player</table>",
        "<column purpose=\"join: Player_Attributes.player_api_id\">Player.player_api_id</column>",
        "<column purpose=\"filter: 'heaviest weight'\">Player.weight</column>",
        "<column purpose=\"Unique identifier for the player attribute record\">Player_Attributes.id</column>",
        "<column purpose=\"calculate: 'finishing rate'\">Player_Attributes.finishing</column>",
        "<column purpose=\"calculate: 'curve score'\">Player_Attributes.curve</column>",
        "<column purpose=\"join: Player.player_api_id\">Player_Attributes.player_api_id</column>",
        "<output_schema purpose=\"Unique identifier for the player attribute record\">integer</output_schema>",
        "<output_schema purpose=\"finishing rate\">integer</output_schema>",
        "<output_schema purpose=\"curve score\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for player attributes--><table>Player_Attributes</table>",
        "<!--Required for player weight--><table>Player</table>",
        "<!--Join Player and Player_Attributes--><column>Player.player_api_id</column>",
        "<!--Join Player and Player_Attributes--><column>Player_Attributes.player_api_id</column>",
        "<!--Find heaviest weight--><column>Player.weight</column>",
        "<!--Get finishing rate--><column>Player_Attributes.finishing</column>",
        "<!--Get curve score--><column>Player_Attributes.curve</column>",
        "<!--Output finishing rate--><output_schema>integer</output_schema>",
        "<!--Output curve score--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1145,
      "db_id": "european_football_2",
      "question": "Which top 4 leagues had the most games in the 2015-2016 season?",
      "evidence": "in the 2015-2016 season refers to season = '2015/2016'; league with most games refers to League.name where MAX(COUNT(id))",
      "SQL": "SELECT t1.name FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2015/2016' GROUP BY t1.name ORDER BY COUNT(t2.id) DESC LIMIT 4",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["League", "Match"],
        "columns": [
          "League.name",
          "League.id",
          "Match.league_id",
          "Match.season",
          "Match.id"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for league information\">League</table>",
        "<table purpose=\"Required for match information\">Match</table>",
        "<column purpose=\"Output: name of the league\">League.name</column>",
        "<column purpose=\"Join: League and Match tables\">League.id</column>",
        "<column purpose=\"Join: League and Match tables\">Match.league_id</column>",
        "<column purpose=\"Filter: '2015/2016' season\">Match.season</column>",
        "<column purpose=\"Calculate: count of games per league\">Match.id</column>",
        "<output_schema purpose=\"League names of top 4 leagues with most games\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for league information--><table>League</table>",
        "<!--Required for match information--><table>Match</table>",
        "<!--Join League and Match tables--><column>League.id</column>",
        "<!--Join League and Match tables--><column>Match.league_id</column>",
        "<!--Filter for 2015/2016 season--><column>Match.season</column>",
        "<!--Count number of games--><column>Match.id</column>",
        "<!--Identify leagues--><column>League.name</column>",
        "<!--League names--><output_schema>text</output_schema>",
        "<!--Number of games per league--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1146,
      "db_id": "european_football_2",
      "question": "Please provide the full name of the away team that scored the most goals.",
      "evidence": "full name refers to team_long_name; away team refers to away_team_api_id; scored the most goals refers to MAX(away_team_goal)",
      "SQL": "SELECT t2.team_long_name FROM Match AS t1 INNER JOIN Team AS t2 ON t1.away_team_api_id = t2.team_api_id ORDER BY t1.away_team_goal DESC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Match", "Team"],
        "columns": [
          "Team.team_long_name",
          "Match.away_team_api_id",
          "Team.team_api_id",
          "Match.away_team_goal"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains match data including away team goals and IDs\">Match</table>",
        "<table purpose=\"Contains team information including full names\">Team</table>",
        "<column purpose=\"Output: 'full name of the away team'\">Team.team_long_name</column>",
        "<column purpose=\"Join: Match.away_team_api_id with Team.team_api_id\">Match.away_team_api_id</column>",
        "<column purpose=\"Join: Team.team_api_id with Match.away_team_api_id\">Team.team_api_id</column>",
        "<column purpose=\"Filter: 'scored the most goals'\">Match.away_team_goal</column>",
        "<output_schema purpose=\"Full name of the team is a text field\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'away team'--><table>Match</table>",
        "<!--Required for 'full name'--><table>Team</table>",
        "<!--join: Match.away_team_api_id--><column>Team.team_api_id</column>",
        "<!--join: Team.team_api_id--><column>Match.away_team_api_id</column>",
        "<!--calculate: 'scored the most goals'--><column>Match.away_team_goal</column>",
        "<!--'full name'--><column>Team.team_long_name</column>",
        "<!--full name of the away team that scored the most goals--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1147,
      "db_id": "european_football_2",
      "question": "Please name one player whose overall strength is the greatest.",
      "evidence": "overall strength is the greatest refers to MAX(overall_rating)",
      "SQL": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.overall_rating = ( SELECT MAX(overall_rating) FROM Player_Attributes)",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["Player", "Player_Attributes", "Player_Attributes"],
        "columns": [
          "Player_Attributes.overall_rating",
          "Player.player_name",
          "Player.player_api_id",
          "Player_Attributes.player_api_id"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains player information including name\">Player</table>",
        "<table purpose=\"Contains player attributes including overall rating\">Player_Attributes</table>",
        "<table warning=\"Duplicate table reference\">Player_Attributes</table>",
        "<column purpose=\"Used to find the maximum overall rating\">Player_Attributes.overall_rating</column>",
        "<column purpose=\"To display the name of the player with the highest overall rating\">Player.player_name</column>",
        "<column purpose=\"Join key between Player and Player_Attributes tables\">Player.player_api_id</column>",
        "<column purpose=\"Join key between Player and Player_Attributes tables\">Player_Attributes.player_api_id</column>",
        "<output_schema purpose=\"To display the player name as text\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'overall strength'--><table>Player_Attributes</table>",
        "<!--calculate: 'overall strength is the greatest'--><column>Player_Attributes.overall_rating</column>",
        "<!--Required to get player name--><table>Player</table>",
        "<!--join: Player.player_api_id--><column>Player_Attributes.player_api_id</column>",
        "<!--join: Player_Attributes.player_api_id--><column>Player.player_api_id</column>",
        "<!--name one player--><column>Player.player_name</column>",
        "<!--name one player with greatest overall strength--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1148,
      "db_id": "european_football_2",
      "question": "What is the percentage of players that are under 180 cm who have an overall strength of more than 70?",
      "evidence": "percentage refers to DIVIDE(COUNT(height < 180 AND overall_rating > 70),COUNT(id)) * 100",
      "SQL": "SELECT CAST(COUNT(CASE WHEN t2.overall_rating > 70  AND t1.height < 180 THEN t1.id ELSE NULL END) AS REAL) * 100 / COUNT(t1.id) percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id ",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["Player", "Player_Attributes"],
        "columns": [
          "Player.height",
          "Player_Attributes.overall_rating",
          "Player.id",
          "Player.player_api_id",
          "Player_Attributes.player_api_id"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains player height information\">Player</table>",
        "<table purpose=\"Contains player overall rating information\">Player_Attributes</table>",
        "<column purpose=\"filter: 'under 180 cm'\">Player.height</column>",
        "<column purpose=\"filter: 'overall strength of more than 70'\">Player_Attributes.overall_rating</column>",
        "<column purpose=\"count: unique players for percentage calculation\">Player.id</column>",
        "<column purpose=\"join: Player and Player_Attributes tables\">Player.player_api_id</column>",
        "<column purpose=\"join: Player and Player_Attributes tables\">Player_Attributes.player_api_id</column>",
        "<output_schema purpose=\"percentage calculation result\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for player height--><table>Player</table>",
        "<!--Required for overall strength--><table>Player_Attributes</table>",
        "<!--Filter: 'under 180 cm'--><column>Player.height</column>",
        "<!--Filter: 'overall strength of more than 70'--><column>Player_Attributes.overall_rating</column>",
        "<!--Join Player and Player_Attributes tables--><column>Player.player_api_id</column>",
        "<!--Join Player and Player_Attributes tables--><column>Player_Attributes.player_api_id</column>",
        "<!--Count total players--><column>Player.id</column>",
        "<!--Percentage of players meeting criteria--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 846,
      "db_id": "formula_1",
      "question": "Please list the reference names of the drivers who are eliminated in the first period in race number 20.",
      "evidence": "driver reference name refers to driverRef; first qualifying period refers to q1; drivers who are eliminated in the first qualifying period refers to 5 drivers with MAX(q1); race number refers to raceId;",
      "SQL": "SELECT T2.driverRef FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 20 ORDER BY T1.q1 DESC LIMIT 5",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["qualifying", "drivers"],
        "columns": [
          "drivers.driverRef",
          "qualifying.driverId",
          "drivers.driverId",
          "qualifying.raceId",
          "qualifying.q1"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains qualifying data for the race\">qualifying</table>",
        "<table purpose=\"Contains driver information\">drivers</table>",
        "<column purpose=\"output: 'reference names of the drivers'\">drivers.driverRef</column>",
        "<column purpose=\"join: drivers.driverId\">qualifying.driverId</column>",
        "<column purpose=\"join: qualifying.driverId\">drivers.driverId</column>",
        "<column purpose=\"filter: 'race number 20'\">qualifying.raceId</column>",
        "<column purpose=\"filter: 'drivers who are eliminated in the first period'\">qualifying.q1</column>",
        "<output_schema purpose=\"driver reference name\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'race number 20'--><table>races</table>",
        "<!--Required for qualifying data--><table>qualifying</table>",
        "<!--Required for driver reference names--><table>drivers</table>",
        "<!--Filter: 'race number 20'--><column>races.raceId</column>",
        "<!--Join: races.raceId--><column>qualifying.raceId</column>",
        "<!--Filter: 'first qualifying period'--><column>qualifying.q1</column>",
        "<!--Join: qualifying.driverId--><column>drivers.driverId</column>",
        "<!--Output: 'reference names of the drivers'--><column>drivers.driverRef</column>",
        "<!--List of driver reference names--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 847,
      "db_id": "formula_1",
      "question": "What is the surname of the driver with the best lap time in race number 19 in the second qualifying period?",
      "evidence": "race number refers to raceId; second qualifying period refers to q2; best lap time refers to MIN(q2);",
      "SQL": "SELECT T2.surname FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 19 ORDER BY T1.q2 ASC LIMIT 1",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["qualifying", "drivers"],
        "columns": [
          "drivers.surname",
          "qualifying.driverId",
          "drivers.driverId",
          "qualifying.raceId",
          "qualifying.q2"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains qualifying data including lap times\">qualifying</table>",
        "<table purpose=\"Contains driver information including surnames\">drivers</table>",
        "<column purpose=\"join: qualifying.driverId\">qualifying.driverId</column>",
        "<column purpose=\"join: qualifying.driverId\">drivers.driverId</column>",
        "<column purpose=\"filter: 'race number 19'\">qualifying.raceId</column>",
        "<column purpose=\"calculate: 'best lap time in second qualifying period'\">qualifying.q2</column>",
        "<column purpose=\"output: 'surname of the driver'\">drivers.surname</column>",
        "<output_schema purpose=\"surname is a text field\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'race number 19'--><table>qualifying</table>",
        "<!--Required for driver surname--><table>drivers</table>",
        "<!--filter: 'race number 19'--><column>qualifying.raceId</column>",
        "<!--calculate: 'best lap time in second qualifying period'--><column>qualifying.q2</column>",
        "<!--join: qualifying.driverId--><column>drivers.driverId</column>",
        "<!--output: 'surname of the driver'--><column>drivers.surname</column>",
        "<!--surname of the driver with the best lap time--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 850,
      "db_id": "formula_1",
      "question": "Please give the name of the race held on the circuits in Germany.",
      "evidence": "Germany is a name of country;",
      "SQL": "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Germany'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["circuits", "races"],
        "columns": [
          "races.name",
          "circuits.circuitId",
          "races.circuitId",
          "circuits.country"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to filter circuits in Germany\">circuits</table>",
        "<table purpose=\"Required to get race names\">races</table>",
        "<column purpose=\"output: 'name of the race'\">races.name</column>",
        "<column purpose=\"join: races.circuitId\">circuits.circuitId</column>",
        "<column purpose=\"join: circuits.circuitId\">races.circuitId</column>",
        "<column purpose=\"filter: 'circuits in Germany'\">circuits.country</column>",
        "<output_schema purpose=\"name of the race\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'circuits in Germany'--><table>circuits</table>",
        "<!--Required for 'name of the race'--><table>races</table>",
        "<!--filter: 'circuits in Germany'--><column>circuits.country</column>",
        "<!--join: circuits.circuitId--><column>races.circuitId</column>",
        "<!--join: races.circuitId--><column>circuits.circuitId</column>",
        "<!--output: 'name of the race'--><column>races.name</column>",
        "<!--name of the race--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 854,
      "db_id": "formula_1",
      "question": "What is the coordinates location of the circuits for Australian grand prix?",
      "evidence": "coordinate position/location refers to lat, lng; circuits for Australian grand prix refers to races.name = 'Australian Grand Prix'",
      "SQL": "SELECT DISTINCT T1.lat, T1.lng FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'Australian Grand Prix'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["circuits", "races"],
        "columns": [
          "circuits.lat",
          "circuits.lng",
          "circuits.circuitId",
          "races.circuitId",
          "races.name"
        ],
        "output_schema": ["real", "real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for circuit coordinates\">circuits</table>",
        "<table purpose=\"Required to identify Australian Grand Prix races\">races</table>",
        "<column purpose=\"calculate: 'coordinates location of the circuits'\">circuits.lat</column>",
        "<column purpose=\"calculate: 'coordinates location of the circuits'\">circuits.lng</column>",
        "<column purpose=\"join: races.circuitId\">circuits.circuitId</column>",
        "<column purpose=\"join: circuits.circuitId\">races.circuitId</column>",
        "<column purpose=\"filter: 'Australian grand prix'\">races.name</column>",
        "<output_schema purpose=\"latitude coordinate\">real</output_schema>",
        "<output_schema purpose=\"longitude coordinate\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'circuits for Australian grand prix'--><table>races</table>",
        "<!--Required for 'coordinates location of the circuits'--><table>circuits</table>",
        "<!--filter: 'Australian grand prix'--><column>races.name</column>",
        "<!--join: circuits.circuitId--><column>races.circuitId</column>",
        "<!--join: races.circuitId--><column>circuits.circuitId</column>",
        "<!--coordinate: latitude--><column>circuits.lat</column>",
        "<!--coordinate: longitude--><column>circuits.lng</column>",
        "<!--circuit name for context--><column>circuits.name</column>",
        "<!--circuit name--><output_schema>text</output_schema>",
        "<!--latitude coordinate--><output_schema>real</output_schema>",
        "<!--longitude coordinate--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 857,
      "db_id": "formula_1",
      "question": "Give the coordinate position for Abu Dhabi Grand Prix.",
      "evidence": "coordinate position/location refers to lat, lng; Abu Dhabi Grand Prix refers to races.name = 'Abu Dhabi Grand Prix'",
      "SQL": "SELECT DISTINCT T1.lat, T1.lng FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'Abu Dhabi Grand Prix'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["circuits", "races"],
        "columns": [
          "circuits.lat",
          "circuits.lng",
          "circuits.circuitId",
          "races.circuitId",
          "races.name"
        ],
        "output_schema": ["real", "real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains circuit information including coordinates\">circuits</table>",
        "<table purpose=\"Contains race information including race names\">races</table>",
        "<column purpose=\"calculate: 'coordinate position' (latitude)\">circuits.lat</column>",
        "<column purpose=\"calculate: 'coordinate position' (longitude)\">circuits.lng</column>",
        "<column purpose=\"join: races.circuitId\">circuits.circuitId</column>",
        "<column purpose=\"join: circuits.circuitId\">races.circuitId</column>",
        "<column purpose=\"filter: 'Abu Dhabi Grand Prix'\">races.name</column>",
        "<output_schema purpose=\"latitude coordinate\">real</output_schema>",
        "<output_schema purpose=\"longitude coordinate\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Abu Dhabi Grand Prix'--><table>races</table>",
        "<!--Required for coordinate position--><table>circuits</table>",
        "<!--filter: 'Abu Dhabi Grand Prix'--><column>races.name</column>",
        "<!--join: races.circuitId--><column>circuits.circuitId</column>",
        "<!--coordinate position: latitude--><column>circuits.lat</column>",
        "<!--coordinate position: longitude--><column>circuits.lng</column>",
        "<!--latitude of Abu Dhabi Grand Prix--><output_schema>real</output_schema>",
        "<!--longitude of Abu Dhabi Grand Prix--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 859,
      "db_id": "formula_1",
      "question": "What's Bruno Senna's Q1 result in the qualifying race No. 354?",
      "evidence": "race number refers to raceId; Bruno Senna refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;",
      "SQL": "SELECT T1.q1 FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 354 AND T2.forename = 'Bruno' AND T2.surname = 'Senna'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["qualifying", "drivers"],
        "columns": [
          "qualifying.q1",
          "qualifying.driverId",
          "drivers.driverId",
          "drivers.forename",
          "drivers.surname",
          "qualifying.raceId"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains qualifying data including Q1 results\">qualifying</table>",
        "<table purpose=\"Contains driver information for identifying Bruno Senna\">drivers</table>",
        "<column purpose=\"retrieve: 'Q1 result'\">qualifying.q1</column>",
        "<column purpose=\"join: drivers.driverId\">qualifying.driverId</column>",
        "<column purpose=\"join: qualifying.driverId\">drivers.driverId</column>",
        "<column purpose=\"filter: 'Bruno'\">drivers.forename</column>",
        "<column purpose=\"filter: 'Senna'\">drivers.surname</column>",
        "<column purpose=\"filter: 'race No. 354'\">qualifying.raceId</column>",
        "<output_schema purpose=\"Q1 result is stored as text\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'qualifying race'--><table>qualifying</table>",
        "<!--Required for driver information--><table>drivers</table>",
        "<!--filter: 'race No. 354'--><column>qualifying.raceId</column>",
        "<!--join: qualifying.driverId--><column>drivers.driverId</column>",
        "<!--filter: 'Bruno Senna'--><column>drivers.forename</column>",
        "<!--filter: 'Bruno Senna'--><column>drivers.surname</column>",
        "<!--Q1 result--><column>qualifying.q1</column>",
        "<!--Bruno Senna's Q1 result--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 861,
      "db_id": "formula_1",
      "question": "What is his number of the driver who finished 0:01:54 in the Q3 of qualifying race No.903?",
      "evidence": "race number refers to raceId; finished 0:0M:SS in the Q3 refers to q3 LIKE 'M:SS%'",
      "SQL": "SELECT T2.number FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 903 AND T1.q3 LIKE '1:54%'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["qualifying", "drivers"],
        "columns": [
          "drivers.number",
          "qualifying.driverId",
          "drivers.driverId",
          "qualifying.q3",
          "qualifying.raceId"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains qualifying data for the specified race\">qualifying</table>",
        "<table purpose=\"Contains driver information including their number\">drivers</table>",
        "<column purpose=\"Output: 'his number of the driver'\">drivers.number</column>",
        "<column purpose=\"join: drivers.driverId\">qualifying.driverId</column>",
        "<column purpose=\"join: qualifying.driverId\">drivers.driverId</column>",
        "<column purpose=\"filter: 'finished 0:01:54 in the Q3'\">qualifying.q3</column>",
        "<column purpose=\"filter: 'qualifying race No.903'\">qualifying.raceId</column>",
        "<output_schema purpose=\"driver's number\">integer</output_schema>",
        "<warning>The 'number' column in the drivers table has 95.7% null values. Consider using qualifying.number instead, which is more likely to contain the driver's number for a specific race.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'qualifying race No.903'--><table>qualifying</table>",
        "<!--Filter: 'qualifying race No.903'--><column>qualifying.raceId</column>",
        "<!--Filter: 'finished 0:01:54 in the Q3'--><column>qualifying.q3</column>",
        "<!--Retrieve: 'his number'--><column>qualifying.number</column>",
        "<!--Driver's number who finished 0:01:54 in Q3 of qualifying race No.903--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 862,
      "db_id": "formula_1",
      "question": "For the Bahrain Grand Prix in 2007, how many drivers not finished the game?",
      "evidence": "Bahrain Grand Prix refers to races.name = 'Bahrain Grand Prix'; drivers who finished the race refers to time is not empty (i.e. time IS NOT NULL);",
      "SQL": "SELECT COUNT(T3.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.year = 2007 AND T1.name = 'Bahrain Grand Prix' AND T2.time IS NULL",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["races", "results", "drivers"],
        "columns": [
          "drivers.driverId",
          "races.raceId",
          "results.raceId",
          "results.time",
          "results.driverId",
          "races.name",
          "races.year"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'Bahrain Grand Prix in 2007'\">races</table>",
        "<table purpose=\"Required for driver finish status\">results</table>",
        "<table purpose=\"Required for driver information\">drivers</table>",
        "<column purpose=\"join: results.driverId, count: 'how many drivers'\">drivers.driverId</column>",
        "<column purpose=\"join: results.raceId\">races.raceId</column>",
        "<column purpose=\"join: races.raceId\">results.raceId</column>",
        "<column purpose=\"filter: 'drivers who finished the race'\">results.time</column>",
        "<column purpose=\"join: drivers.driverId\">results.driverId</column>",
        "<column purpose=\"filter: 'Bahrain Grand Prix'\">races.name</column>",
        "<column purpose=\"filter: 'in 2007'\">races.year</column>",
        "<output_schema purpose=\"count of drivers not finished\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Bahrain Grand Prix in 2007'--><table>races</table>",
        "<!--Required for driver results--><table>results</table>",
        "<!--Filter: 'Bahrain Grand Prix'--><column>races.name</column>",
        "<!--Filter: 'in 2007'--><column>races.year</column>",
        "<!--Join: results.raceId--><column>races.raceId</column>",
        "<!--Join: races.raceId--><column>results.raceId</column>",
        "<!--Filter: drivers who finished the race--><column>results.time</column>",
        "<!--Count of drivers not finished--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 865,
      "db_id": "formula_1",
      "question": "For all the drivers who finished the game in race No. 592, who is the oldest?",
      "evidence": "drivers who finished the race refers to time is not empty (i.e. time IS NOT NULL); race number refers to raceId; date of birth refers to drivers.dob; The larger the birthday value, the younger the person is, and vice versa;",
      "SQL": "SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 592 AND T2.time IS NOT NULL AND T1.dob IS NOT NULL ORDER BY T1.dob ASC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["drivers", "results"],
        "columns": [
          "drivers.forename",
          "drivers.surname",
          "drivers.driverId",
          "results.driverId",
          "results.raceId",
          "results.time",
          "drivers.dob"
        ],
        "output_schema": ["text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains driver information including date of birth\">drivers</table>",
        "<table purpose=\"Contains race results information\">results</table>",
        "<column purpose=\"Output: part of the driver's name\">drivers.forename</column>",
        "<column purpose=\"Output: part of the driver's name\">drivers.surname</column>",
        "<column purpose=\"Join: link drivers to results\">drivers.driverId</column>",
        "<column purpose=\"Join: link results to drivers\">results.driverId</column>",
        "<column purpose=\"Filter: 'race No. 592'\">results.raceId</column>",
        "<column purpose=\"Filter: 'drivers who finished the race'\">results.time</column>",
        "<column purpose=\"Filter and Sort: 'who is the oldest?'\">drivers.dob</column>",
        "<output_schema purpose=\"Driver's first name\">text</output_schema>",
        "<output_schema purpose=\"Driver's last name\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'race No. 592'--><table>races</table>",
        "<!--Required for driver information and date of birth--><table>drivers</table>",
        "<!--Required for race results and finish status--><table>results</table>",
        "<!--Filter: 'race No. 592'--><column>races.raceId</column>",
        "<!--Join: races.raceId--><column>results.raceId</column>",
        "<!--Filter: 'drivers who finished the game'--><column>results.time</column>",
        "<!--Join: results.driverId--><column>drivers.driverId</column>",
        "<!--Calculate: 'who is the oldest'--><column>drivers.dob</column>",
        "<!--Oldest driver's first name--><output_schema>text</output_schema>",
        "<!--Oldest driver's last name--><output_schema>text</output_schema>",
        "<!--Oldest driver's date of birth--><output_schema>date</output_schema>"
      ]
    },
    {
      "question_id": 866,
      "db_id": "formula_1",
      "question": "Who was the player that got the lap time of 0:01:27 in the race No. 161? Show his introduction website.",
      "evidence": "player and driver are synonyms; the lap time of 0:0M:SS refers to lapTime.time LIKE 'M:SS%';race number refers to raceId; introduction website of the drivers refers to url;",
      "SQL": "SELECT DISTINCT T2.forename, T2.surname, T2.url FROM lapTimes AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 161 AND T1.time LIKE '1:27%'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["lapTimes", "drivers"],
        "columns": [
          "drivers.forename",
          "drivers.surname",
          "drivers.url",
          "lapTimes.driverId",
          "drivers.driverId",
          "lapTimes.raceId",
          "lapTimes.time"
        ],
        "output_schema": ["text", "text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains lap time information for the race\">lapTimes</table>",
        "<table purpose=\"Contains driver information including their introduction website\">drivers</table>",
        "<column purpose=\"Part of driver's name for output\">drivers.forename</column>",
        "<column purpose=\"Part of driver's name for output\">drivers.surname</column>",
        "<column purpose=\"Driver's introduction website for output\">drivers.url</column>",
        "<column purpose=\"join: drivers.driverId\">lapTimes.driverId</column>",
        "<column purpose=\"join: lapTimes.driverId\">drivers.driverId</column>",
        "<column purpose=\"filter: 'race No. 161'\">lapTimes.raceId</column>",
        "<column purpose=\"filter: 'lap time of 0:01:27'\">lapTimes.time</column>",
        "<output_schema purpose=\"Driver's first name\">text</output_schema>",
        "<output_schema purpose=\"Driver's last name\">text</output_schema>",
        "<output_schema purpose=\"Driver's introduction website\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'lap time'--><table>lapTimes</table>",
        "<!--Required for 'driver' information--><table>drivers</table>",
        "<!--Required to join lapTimes and drivers--><column>lapTimes.driverId</column>",
        "<!--Required to join lapTimes and drivers--><column>drivers.driverId</column>",
        "<!--Filter: 'lap time of 0:01:27'--><column>lapTimes.time</column>",
        "<!--Filter: 'race No. 161'--><column>lapTimes.raceId</column>",
        "<!--Output: 'introduction website'--><column>drivers.url</column>",
        "<!--Driver's introduction website--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 868,
      "db_id": "formula_1",
      "question": "Where is Malaysian Grand Prix held? Give the location coordinates.",
      "evidence": "location coordinates refers to (lat, lng); Malaysian Grand Prix refers to races.name = 'Malaysian Grand Prix'",
      "SQL": "SELECT DISTINCT T1.lat, T1.lng FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'Malaysian Grand Prix'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["circuits", "races"],
        "columns": [
          "circuits.lat",
          "circuits.lng",
          "circuits.circuitId",
          "races.circuitId",
          "races.name"
        ],
        "output_schema": ["real", "real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for location coordinates of the circuit\">circuits</table>",
        "<table purpose=\"Required to identify the Malaysian Grand Prix\">races</table>",
        "<column purpose=\"calculate: 'location coordinates' (latitude)\">circuits.lat</column>",
        "<column purpose=\"calculate: 'location coordinates' (longitude)\">circuits.lng</column>",
        "<column purpose=\"join: races.circuitId\">circuits.circuitId</column>",
        "<column purpose=\"join: circuits.circuitId\">races.circuitId</column>",
        "<column purpose=\"filter: 'Malaysian Grand Prix'\">races.name</column>",
        "<output_schema purpose=\"latitude coordinate\">real</output_schema>",
        "<output_schema purpose=\"longitude coordinate\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Malaysian Grand Prix'--><table>races</table>",
        "<!--Required for location coordinates--><table>circuits</table>",
        "<!--filter: 'Malaysian Grand Prix'--><column>races.name</column>",
        "<!--join: circuits.circuitId--><column>races.circuitId</column>",
        "<!--join: races.circuitId--><column>circuits.circuitId</column>",
        "<!--location coordinate: latitude--><column>circuits.lat</column>",
        "<!--location coordinate: longitude--><column>circuits.lng</column>",
        "<!--latitude of Malaysian Grand Prix--><output_schema>real</output_schema>",
        "<!--longitude of Malaysian Grand Prix--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 869,
      "db_id": "formula_1",
      "question": "For the constructor which got the highest point in the race No. 9 , what is its introduction website?",
      "evidence": "race number refers to raceId; constructor which got the highest point refers to MAX(constructorResults.points); introduction website of the constructor refers to url;",
      "SQL": "SELECT T2.url FROM constructorResults AS T1 INNER JOIN constructors AS T2 ON T2.constructorId = T1.constructorId WHERE T1.raceId = 9 ORDER BY T1.points DESC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["constructorResults", "constructors"],
        "columns": [
          "constructors.url",
          "constructorResults.constructorId",
          "constructors.constructorId",
          "constructorResults.raceId",
          "constructorResults.points"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'constructor which got the highest point in the race'\">constructorResults</table>",
        "<table purpose=\"Required for 'introduction website' of the constructor\">constructors</table>",
        "<column purpose=\"output: 'introduction website' of the constructor\">constructors.url</column>",
        "<column purpose=\"join: constructors.constructorId\">constructorResults.constructorId</column>",
        "<column purpose=\"join: constructorResults.constructorId\">constructors.constructorId</column>",
        "<column purpose=\"filter: 'race No. 9'\">constructorResults.raceId</column>",
        "<column purpose=\"calculate: 'highest point'\">constructorResults.points</column>",
        "<output_schema purpose=\"introduction website of the constructor\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'race No. 9'--><table>races</table>",
        "<!--Required for 'constructor which got the highest point'--><table>constructorResults</table>",
        "<!--Required for 'introduction website'--><table>constructors</table>",
        "<!--filter: 'race No. 9'--><column>races.raceId</column>",
        "<!--join: races.raceId--><column>constructorResults.raceId</column>",
        "<!--calculate: 'highest point'--><column>constructorResults.points</column>",
        "<!--join: constructorResults.constructorId--><column>constructors.constructorId</column>",
        "<!--output: 'introduction website of the constructor'--><column>constructors.url</column>",
        "<!--introduction website of the constructor--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 872,
      "db_id": "formula_1",
      "question": "In the race No. 45, for the driver who had the Q3 time as 0:01:33, what is his abbreviated code?",
      "evidence": "race number refers to raceId; had the Q3 time as 0:0M:SS refers to q3 LIKE 'M:SS%'",
      "SQL": "SELECT T2.code FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 45 AND T1.q3 LIKE '1:33%'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["qualifying", "drivers"],
        "columns": [
          "drivers.code",
          "qualifying.driverId",
          "drivers.driverId",
          "qualifying.q3",
          "qualifying.raceId"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for qualifying information\">qualifying</table>",
        "<table purpose=\"Required for driver information\">drivers</table>",
        "<column purpose=\"output: 'what is his abbreviated code?'\">drivers.code</column>",
        "<column purpose=\"join: drivers.driverId\">qualifying.driverId</column>",
        "<column purpose=\"join: qualifying.driverId\">drivers.driverId</column>",
        "<column purpose=\"filter: 'had the Q3 time as 0:01:33'\">qualifying.q3</column>",
        "<column purpose=\"filter: 'In the race No. 45'\">qualifying.raceId</column>",
        "<output_schema purpose=\"driver's abbreviated code\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'race No. 45'--><table>qualifying</table>",
        "<!--Required to get driver information--><table>drivers</table>",
        "<!--filter: 'race No. 45'--><column>qualifying.raceId</column>",
        "<!--filter: 'had the Q3 time as 0:01:33'--><column>qualifying.q3</column>",
        "<!--join: qualifying.driverId--><column>drivers.driverId</column>",
        "<!--output: 'what is his abbreviated code?'--><column>drivers.code</column>",
        "<!--driver's abbreviated code--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 875,
      "db_id": "formula_1",
      "question": "Show me the season page of year when the race No. 901 took place.",
      "evidence": "the season page refers to url; race number refers to raceId;",
      "SQL": "SELECT T2.url FROM races AS T1 INNER JOIN seasons AS T2 ON T2.year = T1.year WHERE T1.raceId = 901",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["races", "seasons"],
        "columns": ["seasons.url", "races.year", "seasons.year", "races.raceId"],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"contains race information including raceId and year\">races</table>",
        "<table purpose=\"contains season information including year and url\">seasons</table>",
        "<column purpose=\"output: 'Show me the season page'\">seasons.url</column>",
        "<column purpose=\"join: races to seasons\">races.year</column>",
        "<column purpose=\"join: seasons to races\">seasons.year</column>",
        "<column purpose=\"filter: 'race No. 901'\">races.raceId</column>",
        "<output_schema purpose=\"URL of the season page\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'race No. 901'--><table>races</table>",
        "<!--Required for 'season page'--><table>seasons</table>",
        "<!--filter: 'race No. 901'--><column>races.raceId</column>",
        "<!--join: seasons.year--><column>races.year</column>",
        "<!--join: races.year--><column>seasons.year</column>",
        "<!--'season page refers to url'--><column>seasons.url</column>",
        "<!--season page of year when race No. 901 took place--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 877,
      "db_id": "formula_1",
      "question": "For all the drivers who finished the game in race No. 872, who is the youngest?",
      "evidence": "race number refers to raceId; drivers who finished the race refers to time has value; the youngest is a driver where MAX(dob);",
      "SQL": "SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 872 AND T2.time IS NOT NULL ORDER BY T1.dob DESC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["drivers", "results"],
        "columns": [
          "drivers.forename",
          "drivers.surname",
          "drivers.driverId",
          "results.driverId",
          "results.raceId",
          "results.time",
          "drivers.dob"
        ],
        "output_schema": ["text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains driver information, including date of birth\">drivers</table>",
        "<table purpose=\"Contains race results, including finish times\">results</table>",
        "<column purpose=\"output: part of the driver's name\">drivers.forename</column>",
        "<column purpose=\"output: part of the driver's name\">drivers.surname</column>",
        "<column purpose=\"join: link drivers to results\">drivers.driverId</column>",
        "<column purpose=\"join: link results to drivers\">results.driverId</column>",
        "<column purpose=\"filter: 'race No. 872'\">results.raceId</column>",
        "<column purpose=\"filter: 'drivers who finished the race'\">results.time</column>",
        "<column purpose=\"calculate: 'the youngest' (MAX(dob))\">drivers.dob</column>",
        "<output_schema purpose=\"driver's first name\">text</output_schema>",
        "<output_schema purpose=\"driver's last name\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'race No. 872'--><table>races</table>",
        "<!--Required for driver information and age--><table>drivers</table>",
        "<!--Required for race results--><table>results</table>",
        "<!--Filter: 'race No. 872'--><column>races.raceId</column>",
        "<!--Join: races.raceId--><column>results.raceId</column>",
        "<!--Join: results.driverId--><column>drivers.driverId</column>",
        "<!--Filter: 'drivers who finished the race'--><column>results.time</column>",
        "<!--Calculate: 'the youngest'--><column>drivers.dob</column>",
        "<!--Output: youngest driver's name--><output_schema>text</output_schema>",
        "<!--Output: youngest driver's date of birth--><output_schema>date</output_schema>"
      ]
    },
    {
      "question_id": 879,
      "db_id": "formula_1",
      "question": "For the driver who set the fastest lap speed, what is his nationality?",
      "evidence": "the fastest lap speed refers to (MAX) fastestLapSpeed;",
      "SQL": "SELECT T1.nationality FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["drivers", "results"],
        "columns": [
          "drivers.nationality",
          "drivers.driverId",
          "results.driverId",
          "results.fastestLapSpeed"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains driver information including nationality\">drivers</table>",
        "<table purpose=\"Contains race results including fastest lap speed\">results</table>",
        "<column purpose=\"Output: 'what is his nationality?'\">drivers.nationality</column>",
        "<column purpose=\"join: results.driverId\">drivers.driverId</column>",
        "<column purpose=\"join: drivers.driverId\">results.driverId</column>",
        "<column purpose=\"filter: 'driver who set the fastest lap speed'\">results.fastestLapSpeed</column>",
        "<output_schema purpose=\"nationality of the driver\">text</output_schema>",
        "<warning>The query might need to handle potential NULL values in results.fastestLapSpeed</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'driver who set the fastest lap speed'--><table>results</table>",
        "<!--Required for driver's nationality--><table>drivers</table>",
        "<!--calculate: 'fastest lap speed'--><column>results.fastestLapSpeed</column>",
        "<!--join: drivers.driverId--><column>results.driverId</column>",
        "<!--join: results.driverId--><column>drivers.driverId</column>",
        "<!--output: 'what is his nationality?'--><column>drivers.nationality</column>",
        "<!--driver's nationality--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 880,
      "db_id": "formula_1",
      "question": "Paul di Resta was in the No. 853 race, what percent faster did he finish in the 853rd race than the next race for the fastest lap speed?",
      "evidence": "Paul di Resta refers to the full name of the driver; Full name of the driver refers to drivers.forename ='Paul' and drivers.surname = 'di Resta'; race number refers to raceId; percentage = DIVIDE(SUBTRACT(fastestLapSpeed(raceId = 853), (fastestLapSpeed (raceId = 854)) * 100 , (fastestLapSpeed(raceId = 853))",
      "SQL": "SELECT (SUM(IIF(T2.raceId = 853, T2.fastestLapSpeed, 0)) - SUM(IIF(T2.raceId = 854, T2.fastestLapSpeed, 0))) * 100 / SUM(IIF(T2.raceId = 853, T2.fastestLapSpeed, 0)) FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T1.forename = 'Paul' AND T1.surname = 'di Resta'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["drivers", "results"],
        "columns": [
          "results.raceId",
          "results.fastestLapSpeed",
          "drivers.driverId",
          "results.driverId",
          "drivers.forename",
          "drivers.surname"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to identify Paul di Resta\">drivers</table>",
        "<table purpose=\"Required for race results and fastest lap speed\">results</table>",
        "<column purpose=\"filter: 'No. 853 race' and 'next race'\">results.raceId</column>",
        "<column purpose=\"calculate: 'percent faster' based on fastest lap speed\">results.fastestLapSpeed</column>",
        "<column purpose=\"join: drivers.driverId\">drivers.driverId</column>",
        "<column purpose=\"join: results.driverId\">results.driverId</column>",
        "<column purpose=\"filter: 'Paul di Resta'\">drivers.forename</column>",
        "<column purpose=\"filter: 'Paul di Resta'\">drivers.surname</column>",
        "<output_schema purpose=\"percentage calculation result\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for driver identification--><table>drivers</table>",
        "<!--Required for race results--><table>results</table>",
        "<!--Required for race information--><table>races</table>",
        "<!--Filter: 'Paul di Resta'--><column>drivers.forename</column>",
        "<!--Filter: 'Paul di Resta'--><column>drivers.surname</column>",
        "<!--Join: drivers.driverId--><column>results.driverId</column>",
        "<!--Filter: 'No. 853 race'--><column>results.raceId</column>",
        "<!--Calculate: 'fastest lap speed'--><column>results.fastestLapSpeed</column>",
        "<!--Join: results.raceId--><column>races.raceId</column>",
        "<!--Order races chronologically--><column>races.date</column>",
        "<!--Percentage difference in fastest lap speed--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 881,
      "db_id": "formula_1",
      "question": "For the drivers who took part in the race in 1983/7/16, what's their race completion rate?",
      "evidence": "DIVIDE(COUNT(driverid when time has value ), (COUNT(driverid )) as percentage; in 1983/7/16 refers to when date = '1983-07-16'",
      "SQL": "SELECT CAST(COUNT(CASE WHEN T2.time IS NOT NULL THEN T2.driverId END) AS REAL) * 100 / COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.date = '1983-07-16'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["races", "results"],
        "columns": [
          "results.time",
          "results.driverId",
          "races.raceId",
          "results.raceId",
          "races.date"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to identify the specific race on 1983/7/16\">races</table>",
        "<table purpose=\"Contains driver participation and completion data for races\">results</table>",
        "<column purpose=\"calculate: used to determine if a driver completed the race\">results.time</column>",
        "<column purpose=\"count: used to count the number of drivers who participated\">results.driverId</column>",
        "<column purpose=\"join: links races and results tables\">races.raceId</column>",
        "<column purpose=\"join: links races and results tables\">results.raceId</column>",
        "<column purpose=\"filter: '1983/7/16' refers to when date = '1983-07-16'\">races.date</column>",
        "<output_schema purpose=\"race completion rate as a percentage\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for race date and driver information--><table>races</table>",
        "<!--Required for driver completion status--><table>results</table>",
        "<!--filter: 'in 1983/7/16'--><column>races.date</column>",
        "<!--join: results.raceId--><column>races.raceId</column>",
        "<!--join: races.raceId--><column>results.raceId</column>",
        "<!--count: 'drivers who took part'--><column>results.driverId</column>",
        "<!--determine: 'race completion'--><column>results.time</column>",
        "<!--race completion rate--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 884,
      "db_id": "formula_1",
      "question": "List the names of all races that occurred in the earliest recorded year and month.",
      "evidence": "earliest recorded year and month refers to year = year(min(date)) and month = month(min(date));",
      "SQL": "SELECT name FROM races WHERE STRFTIME('%Y', date) = ( SELECT STRFTIME('%Y', date) FROM races ORDER BY date ASC LIMIT 1 ) AND STRFTIME('%m', date) = ( SELECT STRFTIME('%m', date) FROM races ORDER BY date ASC LIMIT 1 )",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["races"],
        "columns": ["races.date", "races.name"],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains race information including date and name\">races</table>",
        "<column purpose=\"filter: 'earliest recorded year and month'\">races.date</column>",
        "<column purpose=\"output: 'List the names of all races'\">races.name</column>",
        "<output_schema purpose=\"names of races\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for race information--><table>races</table>",
        "<!--Required to find the earliest date--><column>races.date</column>",
        "<!--Required for race names--><column>races.name</column>",
        "<!--List the names of races--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 892,
      "db_id": "formula_1",
      "question": "State the driver with the most points scored. Find his full name with that points.",
      "evidence": "the most points scored refers to max(points); Full name of the driver refers to drivers.forename and drivers.surname;",
      "SQL": "SELECT T3.forename, T3.surname, T2.points FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId ORDER BY T2.points DESC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["races", "driverStandings", "drivers"],
        "columns": [
          "drivers.forename",
          "drivers.surname",
          "driverStandings.points",
          "races.raceId",
          "driverStandings.raceId",
          "driverStandings.driverId",
          "drivers.driverId"
        ],
        "output_schema": ["text", "text", "real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for joining with driverStandings\">races</table>",
        "<table purpose=\"Contains points data for drivers\">driverStandings</table>",
        "<table purpose=\"Contains driver information for full name\">drivers</table>",
        "<column purpose=\"Part of full name: 'Find his full name'\">drivers.forename</column>",
        "<column purpose=\"Part of full name: 'Find his full name'\">drivers.surname</column>",
        "<column purpose=\"Calculate: 'the most points scored'\">driverStandings.points</column>",
        "<column purpose=\"Join: driverStandings.raceId\">races.raceId</column>",
        "<column purpose=\"Join: races.raceId\">driverStandings.raceId</column>",
        "<column purpose=\"Join: drivers.driverId\">driverStandings.driverId</column>",
        "<column purpose=\"Join: driverStandings.driverId\">drivers.driverId</column>",
        "<output_schema purpose=\"Driver's first name\">text</output_schema>",
        "<output_schema purpose=\"Driver's last name\">text</output_schema>",
        "<output_schema purpose=\"Maximum points scored\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'driver with the most points scored'--><table>results</table>",
        "<!--Required for 'full name of the driver'--><table>drivers</table>",
        "<!--calculate: 'most points scored'--><column>results.points</column>",
        "<!--join: drivers.driverId--><column>results.driverId</column>",
        "<!--join: results.driverId--><column>drivers.driverId</column>",
        "<!--'full name of the driver'--><column>drivers.forename</column>",
        "<!--'full name of the driver'--><column>drivers.surname</column>",
        "<!--driver's first name--><output_schema>text</output_schema>",
        "<!--driver's last name--><output_schema>text</output_schema>",
        "<!--most points scored--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 894,
      "db_id": "formula_1",
      "question": "What is the best lap time recorded? List the driver and race with such recorded lap time.",
      "evidence": "the best lap time refers to min(milliseconds); List the driver refers to drivers.forename and drivers.surname; List the race refers to races.name",
      "SQL": "SELECT T2.milliseconds, T1.forename, T1.surname, T3.name FROM drivers AS T1 INNER JOIN lapTimes AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T2.raceId = T3.raceId ORDER BY T2.milliseconds ASC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["drivers", "lapTimes", "races"],
        "columns": [
          "lapTimes.milliseconds",
          "drivers.forename",
          "drivers.surname",
          "races.name",
          "drivers.driverId",
          "lapTimes.driverId",
          "lapTimes.raceId",
          "races.raceId"
        ],
        "output_schema": ["integer", "text", "text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for driver information\">drivers</table>",
        "<table purpose=\"Required for lap time data\">lapTimes</table>",
        "<table purpose=\"Required for race information\">races</table>",
        "<column purpose=\"calculate: 'best lap time recorded'\">lapTimes.milliseconds</column>",
        "<column purpose=\"output: 'List the driver'\">drivers.forename</column>",
        "<column purpose=\"output: 'List the driver'\">drivers.surname</column>",
        "<column purpose=\"output: 'List the race'\">races.name</column>",
        "<column purpose=\"join: lapTimes.driverId\">drivers.driverId</column>",
        "<column purpose=\"join: drivers.driverId\">lapTimes.driverId</column>",
        "<column purpose=\"join: races.raceId\">lapTimes.raceId</column>",
        "<column purpose=\"join: lapTimes.raceId\">races.raceId</column>",
        "<output_schema purpose=\"best lap time in milliseconds\">integer</output_schema>",
        "<output_schema purpose=\"driver's first name\">text</output_schema>",
        "<output_schema purpose=\"driver's last name\">text</output_schema>",
        "<output_schema purpose=\"race name\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'best lap time'--><table>results</table>",
        "<!--Required for 'List the driver'--><table>drivers</table>",
        "<!--Required for 'List the race'--><table>races</table>",
        "<!--calculate: 'best lap time'--><column>results.milliseconds</column>",
        "<!--join: drivers.driverId--><column>results.driverId</column>",
        "<!--join: results.driverId--><column>drivers.driverId</column>",
        "<!--List the driver: 'forename'--><column>drivers.forename</column>",
        "<!--List the driver: 'surname'--><column>drivers.surname</column>",
        "<!--join: races.raceId--><column>results.raceId</column>",
        "<!--join: results.raceId--><column>races.raceId</column>",
        "<!--List the race: 'name'--><column>races.name</column>",
        "<!--best lap time--><output_schema>integer</output_schema>",
        "<!--driver forename--><output_schema>text</output_schema>",
        "<!--driver surname--><output_schema>text</output_schema>",
        "<!--race name--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 895,
      "db_id": "formula_1",
      "question": "What is the average lap time for Lewis Hamilton in the 2009 Malaysian Grand Prix?",
      "evidence": "average lap time = AVG(milliseconds); 'Lewis Hamilton' refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname; 'Malaysian Grand Prix' refers to races.name = 'Malaysian Grand Prix'",
      "SQL": "SELECT AVG(T2.milliseconds) FROM races AS T1 INNER JOIN lapTimes AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' AND T1.year = 2009 AND T1.name = 'Malaysian Grand Prix'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["races", "lapTimes", "drivers"],
        "columns": [
          "lapTimes.milliseconds",
          "races.raceId",
          "lapTimes.raceId",
          "lapTimes.driverId",
          "drivers.driverId",
          "drivers.forename",
          "drivers.surname",
          "races.name",
          "races.year"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for race information and filtering\">races</table>",
        "<table purpose=\"Required for lap time data\">lapTimes</table>",
        "<table purpose=\"Required for driver information\">drivers</table>",
        "<column purpose=\"calculate: 'average lap time'\">lapTimes.milliseconds</column>",
        "<column purpose=\"join: lapTimes.raceId\">races.raceId</column>",
        "<column purpose=\"join: races.raceId\">lapTimes.raceId</column>",
        "<column purpose=\"join: drivers.driverId\">lapTimes.driverId</column>",
        "<column purpose=\"join: lapTimes.driverId\">drivers.driverId</column>",
        "<column purpose=\"filter: 'Lewis Hamilton'\">drivers.forename</column>",
        "<column purpose=\"filter: 'Lewis Hamilton'\">drivers.surname</column>",
        "<column purpose=\"filter: 'Malaysian Grand Prix'\">races.name</column>",
        "<column purpose=\"filter: '2009'\">races.year</column>",
        "<output_schema purpose=\"average lap time in milliseconds\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Lewis Hamilton'--><table>drivers</table>",
        "<!--Required for 'Malaysian Grand Prix' and year--><table>races</table>",
        "<!--Required for lap times--><table>lapTimes</table>",
        "<!--filter: 'Lewis Hamilton'--><column>drivers.forename</column>",
        "<!--filter: 'Lewis Hamilton'--><column>drivers.surname</column>",
        "<!--join: lapTimes.driverId--><column>drivers.driverId</column>",
        "<!--filter: 'Malaysian Grand Prix'--><column>races.name</column>",
        "<!--filter: '2009'--><column>races.year</column>",
        "<!--join: lapTimes.raceId--><column>races.raceId</column>",
        "<!--join: races.raceId--><column>lapTimes.raceId</column>",
        "<!--join: drivers.driverId--><column>lapTimes.driverId</column>",
        "<!--calculate: 'average lap time'--><column>lapTimes.milliseconds</column>",
        "<!--average lap time for Lewis Hamilton in the 2009 Malaysian Grand Prix--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 896,
      "db_id": "formula_1",
      "question": "Calculate the percentage whereby Hamilton was not at the 1st track of the the f1 circuit since 2010.",
      "evidence": "percentage = DIVIDE(COUNT(raceId) where surname = 'Hamilton' and position>1), (COUNT(raceId) where surname = 'Hamilton'); since 2010 refers to year >= 2010",
      "SQL": "SELECT CAST(COUNT(CASE WHEN T2.position <> 1 THEN T2.position END) AS REAL) * 100 / COUNT(T2.driverStandingsId) FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.surname = 'Hamilton' AND T1.year >= 2010",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["races", "driverStandings", "drivers"],
        "columns": [
          "driverStandings.position",
          "driverStandings.driverStandingsId",
          "races.raceId",
          "driverStandings.raceId",
          "driverStandings.driverId",
          "drivers.driverId",
          "drivers.surname",
          "races.year"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for race information and year filtering\">races</table>",
        "<table purpose=\"Required for driver standings and position information\">driverStandings</table>",
        "<table purpose=\"Required to filter for Hamilton\">drivers</table>",
        "<column purpose=\"filter: 'not at the 1st track', calculate: percentage\">driverStandings.position</column>",
        "<column purpose=\"calculate: total count of Hamilton's races\">driverStandings.driverStandingsId</column>",
        "<column purpose=\"join: races.raceId\">races.raceId</column>",
        "<column purpose=\"join: races.raceId\">driverStandings.raceId</column>",
        "<column purpose=\"join: drivers.driverId\">driverStandings.driverId</column>",
        "<column purpose=\"join: driverStandings.driverId\">drivers.driverId</column>",
        "<column purpose=\"filter: 'Hamilton'\">drivers.surname</column>",
        "<column purpose=\"filter: 'since 2010'\">races.year</column>",
        "<output_schema purpose=\"percentage calculation result\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for driver information--><table>drivers</table>",
        "<!--Required for race information--><table>races</table>",
        "<!--Required for race results--><table>results</table>",
        "<!--Filter: 'since 2010'--><column>races.year</column>",
        "<!--Join: races.raceId--><column>results.raceId</column>",
        "<!--Join: results.driverId--><column>drivers.driverId</column>",
        "<!--Filter: 'Hamilton'--><column>drivers.surname</column>",
        "<!--Filter: 'not at the 1st track'--><column>races.round</column>",
        "<!--Calculate: 'percentage whereby Hamilton was not at the 1st track'--><column>results.position</column>",
        "<!--Percentage calculation--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 897,
      "db_id": "formula_1",
      "question": "Name the driver with the most winning. Mention his nationality and what is his maximum point scores.",
      "evidence": "Full name of the driver refers to drivers.forename and drivers.surname; the most winning refers to MAX(COUNT(wins)); average point scores refers to MAX(points);",
      "SQL": "SELECT T1.forename, T1.surname, T1.nationality, MAX(T2.points) FROM drivers AS T1 INNER JOIN driverStandings AS T2 ON T2.driverId = T1.driverId WHERE T2.wins >= 1 GROUP BY T1.forename, T1.surname, T1.nationality ORDER BY COUNT(T2.wins) DESC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["drivers", "driverStandings"],
        "columns": [
          "drivers.forename",
          "drivers.surname",
          "drivers.nationality",
          "driverStandings.points",
          "drivers.driverId",
          "driverStandings.driverId",
          "driverStandings.wins"
        ],
        "output_schema": ["text", "text", "text", "real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for driver information\">drivers</table>",
        "<table purpose=\"Required for driver standings and wins\">driverStandings</table>",
        "<column purpose=\"calculate: 'Full name of the driver'\">drivers.forename</column>",
        "<column purpose=\"calculate: 'Full name of the driver'\">drivers.surname</column>",
        "<column purpose=\"output: 'Mention his nationality'\">drivers.nationality</column>",
        "<column purpose=\"calculate: 'maximum point scores'\">driverStandings.points</column>",
        "<column purpose=\"join: driverStandings.driverId\">drivers.driverId</column>",
        "<column purpose=\"join: drivers.driverId\">driverStandings.driverId</column>",
        "<column purpose=\"filter and calculate: 'the most winning'\">driverStandings.wins</column>",
        "<output_schema purpose=\"driver's first name\">text</output_schema>",
        "<output_schema purpose=\"driver's last name\">text</output_schema>",
        "<output_schema purpose=\"driver's nationality\">text</output_schema>",
        "<output_schema purpose=\"maximum point scores\">real</output_schema>",
        "<warning>The query might not correctly identify the driver with the most wins. Consider using a subquery or CTE to first find the driver with the maximum number of wins, then join with other tables to get the required information.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for driver information--><table>drivers</table>",
        "<!--Required for driver standings--><table>driverStandings</table>",
        "<!--Required for driver's full name--><column>drivers.forename</column>",
        "<!--Required for driver's full name--><column>drivers.surname</column>",
        "<!--Required for driver's nationality--><column>drivers.nationality</column>",
        "<!--Required to join drivers and driverStandings--><column>drivers.driverId</column>",
        "<!--Required to join drivers and driverStandings--><column>driverStandings.driverId</column>",
        "<!--Required to count wins--><column>driverStandings.wins</column>",
        "<!--Required for maximum point scores--><column>driverStandings.points</column>",
        "<!--Driver's full name (forename and surname)--><output_schema>text</output_schema>",
        "<!--Driver's nationality--><output_schema>text</output_schema>",
        "<!--Maximum number of wins--><output_schema>integer</output_schema>",
        "<!--Maximum point score--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 898,
      "db_id": "formula_1",
      "question": "How old is the youngest Japanese driver? What is his name?",
      "evidence": "date of birth refers to drivers.dob; The larger the birthday value, the younger the person is, and vice versa; Japanese refers to nationality = 'Japanese'; age = YEAR(CURRENT_TIMESTAMP) - YEAR(dob);",
      "SQL": "SELECT STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob), forename , surname FROM drivers WHERE nationality = 'Japanese' ORDER BY dob DESC LIMIT 1",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["drivers"],
        "columns": [
          "drivers.dob",
          "drivers.forename",
          "drivers.surname",
          "drivers.nationality"
        ],
        "output_schema": ["integer", "text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains driver information including nationality and date of birth\">drivers</table>",
        "<column purpose=\"calculate: age of the driver, filter: youngest driver\">drivers.dob</column>",
        "<column purpose=\"output: driver's first name\">drivers.forename</column>",
        "<column purpose=\"output: driver's last name\">drivers.surname</column>",
        "<column purpose=\"filter: 'Japanese' drivers\">drivers.nationality</column>",
        "<output_schema purpose=\"age of the youngest Japanese driver\">integer</output_schema>",
        "<output_schema purpose=\"first name of the youngest Japanese driver\">text</output_schema>",
        "<output_schema purpose=\"last name of the youngest Japanese driver\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Japanese driver'--><table>drivers</table>",
        "<!--filter: 'Japanese'--><column>drivers.nationality</column>",
        "<!--calculate: 'youngest' (largest dob value)--><column>drivers.dob</column>",
        "<!--'name' of the driver--><column>drivers.forename</column>",
        "<!--'name' of the driver--><column>drivers.surname</column>",
        "<!--youngest Japanese driver's name--><output_schema>text</output_schema>",
        "<!--youngest Japanese driver's name--><output_schema>text</output_schema>",
        "<!--age of the youngest Japanese driver--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 901,
      "db_id": "formula_1",
      "question": "Name the races along with its circuit name and location for f1 races hosted in September 2005.",
      "evidence": "in September 2005 refers to MONTH(date) = 9 and YEAR(date) = 2005",
      "SQL": "SELECT DISTINCT T2.name, T1.name, T1.location FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.year = 2005 AND STRFTIME('%m', T2.date) = '09'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["circuits", "races"],
        "columns": [
          "races.name",
          "circuits.name",
          "circuits.location",
          "circuits.circuitId",
          "races.circuitId",
          "races.year",
          "races.date"
        ],
        "output_schema": ["text", "text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for circuit information\">circuits</table>",
        "<table purpose=\"Required for race information\">races</table>",
        "<column purpose=\"calculate: 'Name the races'\">races.name</column>",
        "<column purpose=\"calculate: 'circuit name'\">circuits.name</column>",
        "<column purpose=\"calculate: 'location'\">circuits.location</column>",
        "<column purpose=\"join: races.circuitId\">circuits.circuitId</column>",
        "<column purpose=\"join: circuits.circuitId\">races.circuitId</column>",
        "<column purpose=\"filter: 'in September 2005'\">races.year</column>",
        "<column purpose=\"filter: 'in September 2005'\">races.date</column>",
        "<output_schema purpose=\"race name\">text</output_schema>",
        "<output_schema purpose=\"circuit name\">text</output_schema>",
        "<output_schema purpose=\"location\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for race information--><table>races</table>",
        "<!--Required for circuit information--><table>circuits</table>",
        "<!--Filter: 'in September 2005'--><column>races.date</column>",
        "<!--Join: races.circuitId--><column>races.circuitId</column>",
        "<!--Join: circuits.circuitId--><column>circuits.circuitId</column>",
        "<!--Output: 'Name the races'--><column>races.name</column>",
        "<!--Output: 'circuit name'--><column>circuits.name</column>",
        "<!--Output: 'location'--><column>circuits.location</column>",
        "<!--Race name--><output_schema>text</output_schema>",
        "<!--Circuit name--><output_schema>text</output_schema>",
        "<!--Circuit location--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 902,
      "db_id": "formula_1",
      "question": "Which race was Alex Yoong in when he was in track number less than 20?",
      "evidence": "Alex Yoong refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;track number less than 10 refers to position < 20",
      "SQL": "SELECT T1.name FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Alex' AND T3.surname = 'Yoong' AND T2.position < 20",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["races", "driverStandings", "drivers"],
        "columns": [
          "races.name",
          "races.raceId",
          "driverStandings.raceId",
          "driverStandings.position",
          "driverStandings.driverId",
          "drivers.driverId",
          "drivers.forename",
          "drivers.surname"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for race information\">races</table>",
        "<table purpose=\"Required for driver standings and position\">driverStandings</table>",
        "<table purpose=\"Required for driver information\">drivers</table>",
        "<column purpose=\"output: name of the race\">races.name</column>",
        "<column purpose=\"join: races.raceId\">races.raceId</column>",
        "<column purpose=\"join: races.raceId\">driverStandings.raceId</column>",
        "<column purpose=\"filter: 'track number less than 20'\">driverStandings.position</column>",
        "<column purpose=\"join: drivers.driverId\">driverStandings.driverId</column>",
        "<column purpose=\"join: driverStandings.driverId\">drivers.driverId</column>",
        "<column purpose=\"filter: 'Alex Yoong'\">drivers.forename</column>",
        "<column purpose=\"filter: 'Alex Yoong'\">drivers.surname</column>",
        "<output_schema purpose=\"name of the race\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for driver information--><table>drivers</table>",
        "<!--Required for race information--><table>results</table>",
        "<!--Required for race details--><table>races</table>",
        "<!--Filter: \"Alex Yoong\"--><column>drivers.forename</column>",
        "<!--Filter: \"Alex Yoong\"--><column>drivers.surname</column>",
        "<!--Join: drivers.driverId--><column>results.driverId</column>",
        "<!--Filter: \"track number less than 20\"--><column>results.position</column>",
        "<!--Join: results.raceId--><column>races.raceId</column>",
        "<!--Output: race information--><column>races.name</column>",
        "<!--Output: race information--><column>races.year</column>",
        "<!--Race name--><output_schema>text</output_schema>",
        "<!--Race year--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 904,
      "db_id": "formula_1",
      "question": "State the race and year of race in which Michael Schumacher had his fastest lap.",
      "evidence": "fastest lap refers to min(milliseconds); Alex Yoong refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;",
      "SQL": "SELECT T1.name, T1.year FROM races AS T1 INNER JOIN lapTimes AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Michael' AND T3.surname = 'Schumacher' ORDER BY T2.milliseconds ASC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["races", "lapTimes", "drivers"],
        "columns": [
          "races.name",
          "races.year",
          "races.raceId",
          "lapTimes.raceId",
          "lapTimes.driverId",
          "drivers.driverId",
          "drivers.forename",
          "drivers.surname",
          "lapTimes.milliseconds"
        ],
        "output_schema": ["text", "integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for race information\">races</table>",
        "<table purpose=\"Required for lap time information\">lapTimes</table>",
        "<table purpose=\"Required for driver information\">drivers</table>",
        "<column purpose=\"output: 'State the race'\">races.name</column>",
        "<column purpose=\"output: 'year of race'\">races.year</column>",
        "<column purpose=\"join: lapTimes.raceId\">races.raceId</column>",
        "<column purpose=\"join: races.raceId\">lapTimes.raceId</column>",
        "<column purpose=\"join: drivers.driverId\">lapTimes.driverId</column>",
        "<column purpose=\"join: lapTimes.driverId\">drivers.driverId</column>",
        "<column purpose=\"filter: 'Michael Schumacher'\">drivers.forename</column>",
        "<column purpose=\"filter: 'Michael Schumacher'\">drivers.surname</column>",
        "<column purpose=\"calculate: 'fastest lap refers to min(milliseconds)'\">lapTimes.milliseconds</column>",
        "<output_schema purpose=\"race name\">text</output_schema>",
        "<output_schema purpose=\"year of race\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'race' information--><table>races</table>",
        "<!--Required for 'Michael Schumacher' driver information--><table>drivers</table>",
        "<!--Required for 'fastest lap' information--><table>results</table>",
        "<!--join: races.raceId--><column>results.raceId</column>",
        "<!--join: results.raceId--><column>races.raceId</column>",
        "<!--filter: 'Michael Schumacher'--><column>drivers.forename</column>",
        "<!--filter: 'Michael Schumacher'--><column>drivers.surname</column>",
        "<!--join: drivers.driverId--><column>results.driverId</column>",
        "<!--join: results.driverId--><column>drivers.driverId</column>",
        "<!--calculate: 'fastest lap'--><column>results.milliseconds</column>",
        "<!--'race'--><column>races.name</column>",
        "<!--'year of race'--><column>races.year</column>",
        "<!--race name--><output_schema>text</output_schema>",
        "<!--year of race--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 906,
      "db_id": "formula_1",
      "question": "Which was Lewis Hamilton first race? What was his points recorded for his first race event?",
      "evidence": "first race refers to min(Year); Lewis Hamiltonrefers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;",
      "SQL": "SELECT T1.name, T2.points FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' ORDER BY T1.year ASC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["races", "driverStandings", "drivers"],
        "columns": [
          "races.name",
          "driverStandings.points",
          "races.raceId",
          "driverStandings.raceId",
          "driverStandings.driverId",
          "drivers.driverId",
          "drivers.forename",
          "drivers.surname",
          "races.year"
        ],
        "output_schema": ["text", "real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for race information\">races</table>",
        "<table purpose=\"Required for driver standings and points\">driverStandings</table>",
        "<table purpose=\"Required for driver identification\">drivers</table>",
        "<column purpose=\"Output: name of Lewis Hamilton's first race\">races.name</column>",
        "<column purpose=\"Output: points recorded for Lewis Hamilton's first race\">driverStandings.points</column>",
        "<column purpose=\"Join: races.raceId = driverStandings.raceId\">races.raceId</column>",
        "<column purpose=\"Join: races.raceId = driverStandings.raceId\">driverStandings.raceId</column>",
        "<column purpose=\"Join: driverStandings.driverId = drivers.driverId\">driverStandings.driverId</column>",
        "<column purpose=\"Join: driverStandings.driverId = drivers.driverId\">drivers.driverId</column>",
        "<column purpose=\"Filter: 'Lewis Hamilton'\">drivers.forename</column>",
        "<column purpose=\"Filter: 'Lewis Hamilton'\">drivers.surname</column>",
        "<column purpose=\"Order: 'first race refers to min(Year)'\">races.year</column>",
        "<output_schema purpose=\"Name of Lewis Hamilton's first race\">text</output_schema>",
        "<output_schema purpose=\"Points recorded for Lewis Hamilton's first race\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Lewis Hamilton' identification--><table>drivers</table>",
        "<!--Required for race information--><table>races</table>",
        "<!--Required for race results and points--><table>results</table>",
        "<!--Filter: 'Lewis Hamilton'--><column>drivers.forename</column>",
        "<!--Filter: 'Lewis Hamilton'--><column>drivers.surname</column>",
        "<!--Join: drivers.driverId--><column>results.driverId</column>",
        "<!--Join: races.raceId--><column>results.raceId</column>",
        "<!--Filter: 'first race' (min year)--><column>races.year</column>",
        "<!--Output: race information--><column>races.name</column>",
        "<!--Output: race information--><column>races.date</column>",
        "<!--Calculate: 'points recorded'--><column>results.points</column>",
        "<!--First race name--><output_schema>text</output_schema>",
        "<!--First race date--><output_schema>date</output_schema>",
        "<!--Points recorded for first race--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 909,
      "db_id": "formula_1",
      "question": "Among all European Grand Prix races, what is the percentage of the races were hosted in Germany?",
      "evidence": "European Grand Prix races refers to races.name = 'European Grand Prix';percentage = divide(COUNT(races where country = Germany and name = 'Europearn Grand Prix'),COUNT(races where name = 'Europearn Grand Prix'))*100",
      "SQL": "SELECT CAST(COUNT(CASE WHEN T1.country = 'Germany' THEN T2.circuitID END) AS REAL) * 100 / COUNT(T2.circuitId) FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'European Grand Prix'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["circuits", "races"],
        "columns": [
          "circuits.country",
          "races.circuitId",
          "circuits.circuitId",
          "races.name"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for country information of the circuits\">circuits</table>",
        "<table purpose=\"Required for race information\">races</table>",
        "<column purpose=\"filter: 'hosted in Germany'\">circuits.country</column>",
        "<column purpose=\"join: circuits.circuitId\">races.circuitId</column>",
        "<column purpose=\"join: races.circuitId\">circuits.circuitId</column>",
        "<column purpose=\"filter: 'European Grand Prix races'\">races.name</column>",
        "<output_schema purpose=\"percentage of races hosted in Germany\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'European Grand Prix races'--><table>races</table>",
        "<!--Required for country information--><table>circuits</table>",
        "<!--Filter: 'European Grand Prix races'--><column>races.name</column>",
        "<!--Join: races.circuitId--><column>races.circuitId</column>",
        "<!--Join: circuits.circuitId--><column>circuits.circuitId</column>",
        "<!--Filter: 'hosted in Germany'--><column>circuits.country</column>",
        "<!--Percentage of races hosted in Germany--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 910,
      "db_id": "formula_1",
      "question": "What's the location coordinates of Silverstone Circuit?",
      "evidence": "location coordinates refers to (lat, lng); Silverstone Circuit refers to circuits.name = 'Silverstone Circuit'",
      "SQL": "SELECT lat, lng FROM circuits WHERE name = 'Silverstone Circuit'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["circuits"],
        "columns": ["circuits.lat", "circuits.lng", "circuits.name"],
        "output_schema": ["real", "real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for finding Silverstone Circuit's location coordinates\">circuits</table>",
        "<column purpose=\"calculate: latitude coordinate of Silverstone Circuit\">circuits.lat</column>",
        "<column purpose=\"calculate: longitude coordinate of Silverstone Circuit\">circuits.lng</column>",
        "<column purpose=\"filter: 'Silverstone Circuit'\">circuits.name</column>",
        "<output_schema purpose=\"latitude coordinate\">real</output_schema>",
        "<output_schema purpose=\"longitude coordinate\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Silverstone Circuit'--><table>circuits</table>",
        "<!--filter: 'Silverstone Circuit'--><column>circuits.name</column>",
        "<!--location coordinate: 'lat'--><column>circuits.lat</column>",
        "<!--location coordinate: 'lng'--><column>circuits.lng</column>",
        "<!--latitude of Silverstone Circuit--><output_schema>real</output_schema>",
        "<!--longitude of Silverstone Circuit--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 912,
      "db_id": "formula_1",
      "question": "What's the reference name of Marina Bay Street Circuit?",
      "evidence": "reference name refers to circuitRef; Marina Bay Street Circuit refers to circuits.name = 'Marina Bay Street Circuit'",
      "SQL": "SELECT circuitRef FROM circuits WHERE name = 'Marina Bay Street Circuit'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["circuits"],
        "columns": ["circuits.circuitRef", "circuits.name"],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to find the circuit information\">circuits</table>",
        "<column purpose=\"output: 'reference name of Marina Bay Street Circuit'\">circuits.circuitRef</column>",
        "<column purpose=\"filter: 'Marina Bay Street Circuit'\">circuits.name</column>",
        "<output_schema purpose=\"circuitRef is of type text\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Marina Bay Street Circuit'--><table>circuits</table>",
        "<!--filter: 'Marina Bay Street Circuit'--><column>circuits.name</column>",
        "<!--output: 'reference name'--><column>circuits.circuitRef</column>",
        "<!--reference name of Marina Bay Street Circuit--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 915,
      "db_id": "formula_1",
      "question": "Which country is the oldest driver from?",
      "evidence": "date of birth refers to drivers.dob; The larger the birthday value, the younger the person is, and vice versa;",
      "SQL": "SELECT nationality FROM drivers WHERE dob IS NOT NULL ORDER BY dob ASC LIMIT 1",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["drivers"],
        "columns": ["drivers.nationality", "drivers.dob"],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains driver information including nationality and date of birth\">drivers</table>",
        "<column purpose=\"filter: 'Which country', output: nationality of the oldest driver\">drivers.nationality</column>",
        "<column purpose=\"filter: 'oldest driver', sort: ascending to find oldest\">drivers.dob</column>",
        "<output_schema purpose=\"country (nationality) of the oldest driver\">text</output_schema>",
        "<warning>The proposal doesn't explicitly mention handling NULL values in the dob column, which is important as per the SQL query.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'oldest driver'--><table>drivers</table>",
        "<!--calculate: 'oldest driver'--><column>drivers.dob</column>",
        "<!--output: 'Which country'--><column>drivers.nationality</column>",
        "<!--Which country is the oldest driver from--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 928,
      "db_id": "formula_1",
      "question": "Which driver ranked the first in the Canadian Grand Prix in 2007? Please give his reference name.",
      "evidence": "reference name refers to driverRef; Canadian Grand Prix refers to races.name = 'Canadian Grand Prix';",
      "SQL": "SELECT T3.forename, T3.surname, T3.driverRef FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.name = 'Canadian Grand Prix' AND T2.rank = 1 AND T1.year = 2007",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["races", "results", "drivers"],
        "columns": [
          "drivers.forename",
          "drivers.surname",
          "drivers.driverRef",
          "races.raceId",
          "results.raceId",
          "results.rank",
          "results.driverId",
          "drivers.driverId",
          "races.name",
          "races.year"
        ],
        "output_schema": ["text", "text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for identifying the Canadian Grand Prix\">races</table>",
        "<table purpose=\"Required for ranking information\">results</table>",
        "<table purpose=\"Required for driver information\">drivers</table>",
        "<column purpose=\"Part of the driver's information, though not explicitly requested\">drivers.forename</column>",
        "<column purpose=\"Part of the driver's information, though not explicitly requested\">drivers.surname</column>",
        "<column purpose=\"Required: 'Please give his reference name'\">drivers.driverRef</column>",
        "<column purpose=\"join: results.raceId\">races.raceId</column>",
        "<column purpose=\"join: races.raceId\">results.raceId</column>",
        "<column purpose=\"filter: 'ranked the first'\">results.rank</column>",
        "<column purpose=\"join: drivers.driverId\">results.driverId</column>",
        "<column purpose=\"join: results.driverId\">drivers.driverId</column>",
        "<column purpose=\"filter: 'Canadian Grand Prix'\">races.name</column>",
        "<column purpose=\"filter: 'in 2007'\">races.year</column>",
        "<output_schema purpose=\"driver's forename (not explicitly requested but included)\">text</output_schema>",
        "<output_schema purpose=\"driver's surname (not explicitly requested but included)\">text</output_schema>",
        "<output_schema purpose=\"driver's reference name (driverRef)\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Canadian Grand Prix'--><table>races</table>",
        "<!--Required for driver information--><table>drivers</table>",
        "<!--Required for race results--><table>results</table>",
        "<!--Filter: 'Canadian Grand Prix'--><column>races.name</column>",
        "<!--Filter: '2007'--><column>races.year</column>",
        "<!--Join: races.raceId--><column>results.raceId</column>",
        "<!--Join: results.driverId--><column>drivers.driverId</column>",
        "<!--Filter: 'ranked the first'--><column>results.position</column>",
        "<!--Output: 'reference name'--><column>drivers.driverRef</column>",
        "<!--Driver reference name--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 930,
      "db_id": "formula_1",
      "question": "In which Formula_1 race did Lewis Hamilton rank the highest?",
      "evidence": "rank the highest refers to min(rank); Lewis Hamilton refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;",
      "SQL": "SELECT name FROM races WHERE raceId IN ( SELECT raceId FROM results WHERE rank = 1 AND driverId = ( SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton' ) )",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["races", "results", "drivers"],
        "columns": [
          "results.raceId",
          "results.rank",
          "drivers.driverId",
          "results.driverId",
          "drivers.forename",
          "drivers.surname",
          "races.name",
          "races.raceId"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for race information\">races</table>",
        "<table purpose=\"Required for driver performance data\">results</table>",
        "<table purpose=\"Required for driver identification\">drivers</table>",
        "<column purpose=\"join: races.raceId, filter: Lewis Hamilton's best performance\">results.raceId</column>",
        "<column purpose=\"filter: 'rank the highest'\">results.rank</column>",
        "<column purpose=\"join: results.driverId\">drivers.driverId</column>",
        "<column purpose=\"join: drivers.driverId\">results.driverId</column>",
        "<column purpose=\"filter: 'Lewis Hamilton'\">drivers.forename</column>",
        "<column purpose=\"filter: 'Lewis Hamilton'\">drivers.surname</column>",
        "<column purpose=\"output: 'In which Formula_1 race'\">races.name</column>",
        "<column purpose=\"join: results.raceId\">races.raceId</column>",
        "<output_schema purpose=\"name of the race where Lewis Hamilton ranked highest\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Formula_1 race' information--><table>races</table>",
        "<!--Required for driver information--><table>drivers</table>",
        "<!--Required for race results and ranking--><table>results</table>",
        "<!--Filter: 'Lewis Hamilton'--><column>drivers.forename</column>",
        "<!--Filter: 'Lewis Hamilton'--><column>drivers.surname</column>",
        "<!--Join: drivers.driverId--><column>results.driverId</column>",
        "<!--Join: races.raceId--><column>results.raceId</column>",
        "<!--Calculate: 'rank the highest'--><column>results.rank</column>",
        "<!--Race information--><column>races.name</column>",
        "<!--Race information--><column>races.year</column>",
        "<!--Race information--><column>races.round</column>",
        "<!--Output: Race name--><output_schema>text</output_schema>",
        "<!--Output: Race year--><output_schema>integer</output_schema>",
        "<!--Output: Race round--><output_schema>integer</output_schema>",
        "<!--Output: Highest rank--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 931,
      "db_id": "formula_1",
      "question": "What was the fastest lap speed among all drivers in the 2009 Spanish Grand Prix?",
      "evidence": "the fastest lap speed among all refers to max(fastestLapSpeed); Spanish Grand Prix refers to races.name = 'Spanish Grand Prix';",
      "SQL": "SELECT T2.fastestLapSpeed FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.name = 'Spanish Grand Prix' AND T1.year = 2009 AND T2.fastestLapSpeed IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["races", "results"],
        "columns": [
          "results.fastestLapSpeed",
          "races.raceId",
          "results.raceId",
          "races.name",
          "races.year"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for identifying the Spanish Grand Prix in 2009\">races</table>",
        "<table purpose=\"Required for obtaining fastest lap speed data\">results</table>",
        "<column purpose=\"calculate: 'fastest lap speed among all drivers'\">results.fastestLapSpeed</column>",
        "<column purpose=\"join: results.raceId\">races.raceId</column>",
        "<column purpose=\"join: races.raceId\">results.raceId</column>",
        "<column purpose=\"filter: 'Spanish Grand Prix'\">races.name</column>",
        "<column purpose=\"filter: '2009'\">races.year</column>",
        "<output_schema purpose=\"fastest lap speed\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Spanish Grand Prix'--><table>races</table>",
        "<!--Required for 'fastest lap speed'--><table>results</table>",
        "<!--filter: 'Spanish Grand Prix'--><column>races.name</column>",
        "<!--filter: '2009'--><column>races.year</column>",
        "<!--join: results.raceId--><column>races.raceId</column>",
        "<!--join: races.raceId--><column>results.raceId</column>",
        "<!--calculate: 'fastest lap speed'--><column>results.fastestLapSpeed</column>",
        "<!--fastest lap speed--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 933,
      "db_id": "formula_1",
      "question": "What was Lewis Hamilton's final rank in the 2008 Chinese Grand Prix?",
      "evidence": "Lewis Hamilton refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname; final rank refers to positionOrder; Chinese Grand Prix refers to races.name = 'Chinese Grand Prix';",
      "SQL": "SELECT T2.positionOrder FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' AND T1.name = 'Chinese Grand Prix' AND T1.year = 2008",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["races", "results", "drivers"],
        "columns": [
          "results.positionOrder",
          "races.raceId",
          "results.raceId",
          "results.driverId",
          "drivers.driverId",
          "drivers.forename",
          "drivers.surname",
          "races.name",
          "races.year"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'Chinese Grand Prix' and year information\">races</table>",
        "<table purpose=\"Required for 'final rank' (positionOrder)\">results</table>",
        "<table purpose=\"Required for 'Lewis Hamilton' (driver's full name)\">drivers</table>",
        "<column purpose=\"calculate: 'final rank'\">results.positionOrder</column>",
        "<column purpose=\"join: results.raceId\">races.raceId</column>",
        "<column purpose=\"join: races.raceId\">results.raceId</column>",
        "<column purpose=\"join: drivers.driverId\">results.driverId</column>",
        "<column purpose=\"join: results.driverId\">drivers.driverId</column>",
        "<column purpose=\"filter: 'Lewis Hamilton'\">drivers.forename</column>",
        "<column purpose=\"filter: 'Lewis Hamilton'\">drivers.surname</column>",
        "<column purpose=\"filter: 'Chinese Grand Prix'\">races.name</column>",
        "<column purpose=\"filter: '2008'\">races.year</column>",
        "<output_schema purpose=\"final rank (positionOrder)\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Lewis Hamilton'--><table>drivers</table>",
        "<!--Required for 'Chinese Grand Prix' and year 2008--><table>races</table>",
        "<!--Required for final rank--><table>results</table>",
        "<!--filter: 'Lewis Hamilton'--><column>drivers.forename</column>",
        "<!--filter: 'Lewis Hamilton'--><column>drivers.surname</column>",
        "<!--join: drivers.driverId--><column>results.driverId</column>",
        "<!--filter: 'Chinese Grand Prix'--><column>races.name</column>",
        "<!--filter: year 2008--><column>races.year</column>",
        "<!--join: races.raceId--><column>results.raceId</column>",
        "<!--final rank--><column>results.positionOrder</column>",
        "<!--Lewis Hamilton's final rank--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 937,
      "db_id": "formula_1",
      "question": "What's the finish time for the driver who ranked second in 2008's AustChineseralian Grand Prix?",
      "evidence": "finish time refers to time; Chinese Grand Prix refers to races.name = 'Chinese Grand Prix';",
      "SQL": "SELECT T1.time FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.rank = 2 AND T2.name = 'Chinese Grand Prix' AND T2.year = 2008",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["results", "races"],
        "columns": [
          "results.time",
          "results.raceId",
          "races.raceId",
          "races.name",
          "races.year",
          "results.rank"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains race results data, including finish times\">results</table>",
        "<table purpose=\"Contains race information, including race names and years\">races</table>",
        "<column purpose=\"calculate: 'finish time for the driver who ranked second'\">results.time</column>",
        "<column purpose=\"join: races.raceId\">results.raceId</column>",
        "<column purpose=\"join: results.raceId\">races.raceId</column>",
        "<column purpose=\"filter: 'Chinese Grand Prix'\">races.name</column>",
        "<column purpose=\"filter: '2008'\">races.year</column>",
        "<column purpose=\"filter: 'ranked second'\">results.rank</column>",
        "<output_schema purpose=\"finish time in text format\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Chinese Grand Prix'--><table>races</table>",
        "<!--Required for driver finish time--><table>results</table>",
        "<!--Filter: '2008'--><column>races.year</column>",
        "<!--Filter: 'Chinese Grand Prix'--><column>races.name</column>",
        "<!--Join: results.raceId--><column>races.raceId</column>",
        "<!--Join: races.raceId--><column>results.raceId</column>",
        "<!--Filter: 'ranked second'--><column>results.position</column>",
        "<!--Output: 'finish time'--><column>results.time</column>",
        "<!--Finish time for second-ranked driver--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 940,
      "db_id": "formula_1",
      "question": "Among the drivers that finished the race in the 2008 Chinese Grand Prix, how many of them have participated in Formula_1 races?",
      "evidence": "COUNT(raceID) > 0 reveals that this driver participated in races; drivers who finished the race refers to time has value.",
      "SQL": "SELECT COUNT(*) FROM ( SELECT T1.driverId FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.name = 'Chinese Grand Prix' AND T2.year = 2008 AND T1.time IS NOT NULL GROUP BY T1.driverId HAVING COUNT(T2.raceId) > 0 )",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["results", "races"],
        "columns": [
          "results.raceId",
          "races.raceId",
          "races.name",
          "races.year",
          "results.time",
          "results.driverId"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains race results data, including driver performance and timing information\">results</table>",
        "<table purpose=\"Contains information about Formula 1 races, including race names and years\">races</table>",
        "<column purpose=\"join: link results to specific races\">results.raceId</column>",
        "<column purpose=\"join: link races to specific results\">races.raceId</column>",
        "<column purpose=\"filter: identify 'Chinese Grand Prix'\">races.name</column>",
        "<column purpose=\"filter: specify the year 2008\">races.year</column>",
        "<column purpose=\"filter: identify drivers who finished the race ('time has value')\">results.time</column>",
        "<column purpose=\"group: count unique drivers\">results.driverId</column>",
        "<output_schema purpose=\"count of drivers meeting the criteria\">integer</output_schema>",
        "<warning>The proposal is missing a way to check if a driver has participated in Formula 1 races (COUNT(raceId) > 0). This could be achieved by using a subquery or a HAVING clause.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for '2008 Chinese Grand Prix'--><table>races</table>",
        "<!--Required for driver results--><table>results</table>",
        "<!--Required for driver information--><table>drivers</table>",
        "<!--Filter: '2008 Chinese Grand Prix'--><column>races.year</column>",
        "<!--Filter: '2008 Chinese Grand Prix'--><column>races.name</column>",
        "<!--Join: races.raceId--><column>results.raceId</column>",
        "<!--Filter: 'finished the race'--><column>results.time</column>",
        "<!--Join: results.driverId--><column>drivers.driverId</column>",
        "<!--Count of drivers who finished--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 944,
      "db_id": "formula_1",
      "question": "How much faster in percentage is the champion than the driver who finished the race last in the 2008 Australian Grand Prix?",
      "evidence": "how much faster in percentage = divide(subtract(incremental time, champion time), last_driver time) * 100; last driver finished time = incremental time + champion time; only champion's finished time is represented by 'HH:MM:SS.mmm'; finished the game refers to time is not null",
      "SQL": "WITH time_in_seconds AS ( SELECT T1.positionOrder, CASE WHEN T1.positionOrder = 1 THEN (CAST(SUBSTR(T1.time, 1, 1) AS REAL) * 3600) + (CAST(SUBSTR(T1.time, 3, 2) AS REAL) * 60) + CAST(SUBSTR(T1.time, 6) AS REAL) ELSE CAST(SUBSTR(T1.time, 2) AS REAL) END AS time_seconds FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.name = 'Australian Grand Prix' AND T1.time IS NOT NULL AND T2.year = 2008 ), champion_time AS ( SELECT time_seconds FROM time_in_seconds WHERE positionOrder = 1), last_driver_incremental AS ( SELECT time_seconds FROM time_in_seconds WHERE positionOrder = (SELECT MAX(positionOrder) FROM time_in_seconds) ) SELECT (CAST((SELECT time_seconds FROM last_driver_incremental) AS REAL) * 100) / (SELECT time_seconds + (SELECT time_seconds FROM last_driver_incremental) FROM champion_time)",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["results", "races"],
        "columns": [
          "results.positionOrder",
          "results.time",
          "results.raceId",
          "races.raceId",
          "races.name",
          "races.year"
        ],
        "output_schema": ["null"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains race results data, including finish times\">results</table>",
        "<table purpose=\"Contains race information, including race name and year\">races</table>",
        "<column purpose=\"join: results.raceId, filter: to identify champion and last driver\">results.positionOrder</column>",
        "<column purpose=\"calculate: to extract finish times for champion and last driver\">results.time</column>",
        "<column purpose=\"join: races.raceId\">results.raceId</column>",
        "<column purpose=\"join: results.raceId\">races.raceId</column>",
        "<column purpose=\"filter: 'Australian Grand Prix'\">races.name</column>",
        "<column purpose=\"filter: '2008'\">races.year</column>",
        "<output_schema error=\"The output schema should be 'real' to represent the percentage difference\">null</output_schema>",
        "<error>Missing a column to filter out drivers who didn't finish the race (results.time IS NOT NULL)</error>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for '2008 Australian Grand Prix'--><table>races</table>",
        "<!--Required for race results--><table>results</table>",
        "<!--Filter: '2008 Australian Grand Prix'--><column>races.year</column>",
        "<!--Filter: '2008 Australian Grand Prix'--><column>races.name</column>",
        "<!--Join: races.raceId--><column>results.raceId</column>",
        "<!--Calculate: 'champion time'--><column>results.time</column>",
        "<!--Calculate: 'last driver finished time'--><column>results.time</column>",
        "<!--Filter: 'finished the race'--><column>results.time</column>",
        "<!--Calculate: 'champion time'--><column>results.milliseconds</column>",
        "<!--Calculate: 'last driver finished time'--><column>results.milliseconds</column>",
        "<!--Filter: 'finished the race'--><column>results.milliseconds</column>",
        "<!--Determine race positions--><column>results.positionOrder</column>",
        "<!--Percentage difference between champion and last finisher--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 945,
      "db_id": "formula_1",
      "question": "How many circuits are there in Adelaide, Australia?",
      "evidence": "Australia is the country; Melbourne is the location of circuit;",
      "SQL": "SELECT COUNT(circuitId) FROM circuits WHERE location = 'Adelaide' AND country = 'Australia'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["circuits"],
        "columns": [
          "circuits.circuitId",
          "circuits.country",
          "circuits.location"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for counting circuits in Adelaide, Australia\">circuits</table>",
        "<column purpose=\"calculate: count of circuits\">circuits.circuitId</column>",
        "<column purpose=\"filter: 'Australia is the country'\">circuits.country</column>",
        "<column purpose=\"filter: 'Adelaide' is the location\">circuits.location</column>",
        "<output_schema purpose=\"count of circuits\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'circuits'--><table>circuits</table>",
        "<!--filter: 'in Adelaide, Australia'--><column>circuits.location</column>",
        "<!--filter: 'Australia'--><column>circuits.country</column>",
        "<!--count of circuits--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 948,
      "db_id": "formula_1",
      "question": "What are the maximum points of British constructors?",
      "evidence": "maximum points = MAX(points); British is a nationality",
      "SQL": "SELECT MAX(T1.points) FROM constructorStandings AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T2.nationality = 'British'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["constructorStandings", "constructors"],
        "columns": [
          "constructorStandings.points",
          "constructorStandings.constructorId",
          "constructors.constructorId",
          "constructors.nationality"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'maximum points'\">constructorStandings</table>",
        "<table purpose=\"Required to filter 'British constructors'\">constructors</table>",
        "<column purpose=\"calculate: 'maximum points'\">constructorStandings.points</column>",
        "<column purpose=\"join: constructors.constructorId\">constructorStandings.constructorId</column>",
        "<column purpose=\"join: constructorStandings.constructorId\">constructors.constructorId</column>",
        "<column purpose=\"filter: 'British constructors'\">constructors.nationality</column>",
        "<output_schema purpose=\"maximum points of British constructors\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'points of British constructors'--><table>constructorResults</table>",
        "<!--Required for 'British constructors'--><table>constructors</table>",
        "<!--calculate: 'maximum points'--><column>constructorResults.points</column>",
        "<!--join: constructors.constructorId--><column>constructorResults.constructorId</column>",
        "<!--join: constructorResults.constructorId--><column>constructors.constructorId</column>",
        "<!--filter: 'British constructors'--><column>constructors.nationality</column>",
        "<!--maximum points of British constructors--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 950,
      "db_id": "formula_1",
      "question": "Please list the constructor names with 0 points at race 291.",
      "evidence": "race at 291 refers to raceID = 291;",
      "SQL": "SELECT T2.name FROM constructorStandings AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.points = 0 AND T1.raceId = 291",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["constructorStandings", "constructors"],
        "columns": [
          "constructors.name",
          "constructorStandings.constructorId",
          "constructors.constructorId",
          "constructorStandings.points",
          "constructorStandings.raceId"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains constructor standings data, including points and race information\">constructorStandings</table>",
        "<table purpose=\"Contains constructor information, including names\">constructors</table>",
        "<column purpose=\"Output: 'constructor names'\">constructors.name</column>",
        "<column purpose=\"join: constructors.constructorId\">constructorStandings.constructorId</column>",
        "<column purpose=\"join: constructorStandings.constructorId\">constructors.constructorId</column>",
        "<column purpose=\"filter: 'with 0 points'\">constructorStandings.points</column>",
        "<column purpose=\"filter: 'at race 291'\">constructorStandings.raceId</column>",
        "<output_schema purpose=\"constructor names\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'constructor names'--><table>constructors</table>",
        "<!--Required for 'points at race 291'--><table>constructorResults</table>",
        "<!--filter: 'race 291'--><column>constructorResults.raceId</column>",
        "<!--filter: '0 points'--><column>constructorResults.points</column>",
        "<!--join: constructorResults.constructorId--><column>constructors.constructorId</column>",
        "<!--join: constructors.constructorId--><column>constructorResults.constructorId</column>",
        "<!--output: 'constructor names'--><column>constructors.name</column>",
        "<!--list of constructor names--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 951,
      "db_id": "formula_1",
      "question": "How many Japanese constructors have 0 points in 2 races?",
      "evidence": "2 races refers to COUNT(raceID) = 2; Japanese refers to constructors.nationality = 'Japanese';",
      "SQL": "SELECT COUNT(T1.raceId) FROM constructorStandings AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.points = 0 AND T2.nationality = 'Japanese' GROUP BY T1.constructorId HAVING COUNT(raceId) = 2",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["constructorStandings", "constructors"],
        "columns": [
          "constructorStandings.raceId",
          "constructorStandings.constructorId",
          "constructors.constructorId",
          "constructors.nationality",
          "constructorStandings.points"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for counting races and points\">constructorStandings</table>",
        "<table purpose=\"Required for filtering Japanese constructors\">constructors</table>",
        "<column purpose=\"join: constructors.constructorId, count: '2 races'\">constructorStandings.raceId</column>",
        "<column purpose=\"join: constructors.constructorId, group by: 'Japanese constructors'\">constructorStandings.constructorId</column>",
        "<column purpose=\"join: constructorStandings.constructorId\">constructors.constructorId</column>",
        "<column purpose=\"filter: 'Japanese constructors'\">constructors.nationality</column>",
        "<column purpose=\"filter: '0 points'\">constructorStandings.points</column>",
        "<output_schema purpose=\"count of Japanese constructors with 0 points in 2 races\">integer</output_schema>",
        "<warning>The proposal is missing a COUNT() function in the output schema. The question asks \"How many Japanese constructors\", which requires a count of the qualifying constructors.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Japanese constructors'--><table>constructors</table>",
        "<!--Required for 'points in races'--><table>constructorResults</table>",
        "<!--filter: 'Japanese'--><column>constructors.nationality</column>",
        "<!--join: constructors.constructorId--><column>constructorResults.constructorId</column>",
        "<!--join: constructorResults.constructorId--><column>constructors.constructorId</column>",
        "<!--calculate: 'points in races'--><column>constructorResults.points</column>",
        "<!--calculate: 'COUNT(raceID) = 2'--><column>constructorResults.raceId</column>",
        "<!--count of Japanese constructors with 0 points in 2 races--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 954,
      "db_id": "formula_1",
      "question": "Please calculate the race completion percentage of Japanese drivers from 2007 to 2009.",
      "evidence": "from 2007 to 2009 refers to year between 2007 and 2009; race completion refers to time is not null; percentage = Divide(COUNT(DriverID where time is not null and year between 2007 and 2009),Count (DriverID where year between 2007 and 2009))*100; ",
      "SQL": "SELECT CAST(SUM(IIF(T1.time IS NOT NULL, 1, 0)) AS REAL) * 100 / COUNT(T1.raceId) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN drivers AS T3 on T1.driverId = T3.driverId WHERE T3.nationality = 'Japanese' AND T2.year BETWEEN 2007 AND 2009",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["results", "races", "drivers"],
        "columns": [
          "results.time",
          "results.raceId",
          "races.raceId",
          "races.year",
          "results.driverId",
          "drivers.driverId",
          "drivers.nationality"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains race results data, including completion status\">results</table>",
        "<table purpose=\"Contains race information, including year\">races</table>",
        "<table purpose=\"Contains driver information, including nationality\">drivers</table>",
        "<column purpose=\"filter: race completion (not null indicates race completion)\">results.time</column>",
        "<column purpose=\"join: results.raceId with races.raceId\">results.raceId</column>",
        "<column purpose=\"join: results.raceId with races.raceId\">races.raceId</column>",
        "<column purpose=\"filter: 'from 2007 to 2009'\">races.year</column>",
        "<column purpose=\"join: results.driverId with drivers.driverId\">results.driverId</column>",
        "<column purpose=\"join: results.driverId with drivers.driverId\">drivers.driverId</column>",
        "<column purpose=\"filter: 'Japanese drivers'\">drivers.nationality</column>",
        "<output_schema purpose=\"percentage of race completion\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for race results and completion status--><table>results</table>",
        "<!--Required for driver nationality--><table>drivers</table>",
        "<!--Required for race year--><table>races</table>",
        "<!--Join: results.driverId to drivers.driverId--><column>results.driverId</column>",
        "<!--Join: drivers.driverId to results.driverId--><column>drivers.driverId</column>",
        "<!--Join: results.raceId to races.raceId--><column>results.raceId</column>",
        "<!--Join: races.raceId to results.raceId--><column>races.raceId</column>",
        "<!--Filter: 'Japanese drivers'--><column>drivers.nationality</column>",
        "<!--Filter: 'from 2007 to 2009'--><column>races.year</column>",
        "<!--Calculate: 'race completion'--><column>results.time</column>",
        "<!--Race completion percentage of Japanese drivers from 2007 to 2009--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 955,
      "db_id": "formula_1",
      "question": "What is the average time in seconds of champion for each year, before year 1975?",
      "evidence": "only champion's finished time is represented by 'HH:MM:SS.mmm'; finished the game refers to time is not null; before year 1975 refers to year < 1975;",
      "SQL": "WITH time_in_seconds AS ( SELECT T2.year, T2.raceId, T1.positionOrder, CASE WHEN T1.positionOrder = 1 THEN (CAST(SUBSTR(T1.time, 1, 1) AS REAL) * 3600) + (CAST(SUBSTR(T1.time, 3, 2) AS REAL) * 60) + CAST(SUBSTR(T1.time, 6,2) AS REAL )   + CAST(SUBSTR(T1.time, 9) AS REAL)/1000 ELSE 0 END AS time_seconds FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T1.time IS NOT NULL ), champion_time AS ( SELECT year, raceId, time_seconds FROM time_in_seconds WHERE positionOrder = 1 ) SELECT year, AVG(time_seconds) FROM champion_time WHERE year < 1975 GROUP BY year HAVING AVG(time_seconds) IS NOT NULL",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["results", "races"],
        "columns": [
          "races.year",
          "results.positionOrder",
          "results.time",
          "results.raceId",
          "races.raceId"
        ],
        "output_schema": ["integer", "real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains race results data including champion's finish time\">results</table>",
        "<table purpose=\"Contains race year information\">races</table>",
        "<column purpose=\"filter: 'before year 1975', group by: 'for each year'\">races.year</column>",
        "<column purpose=\"filter: 'only champion's finished time'\">results.positionOrder</column>",
        "<column purpose=\"calculate: 'average time in seconds of champion'\">results.time</column>",
        "<column purpose=\"join: results.raceId\">results.raceId</column>",
        "<column purpose=\"join: races.raceId\">races.raceId</column>",
        "<output_schema purpose=\"year for grouping\">integer</output_schema>",
        "<output_schema purpose=\"average time in seconds\">real</output_schema>",
        "<warning>The query is complex and involves string manipulation and type casting, which are not explicitly mentioned in the proposal. Consider adding a note about string manipulation for time conversion.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for race year and champion's time--><table>results</table>",
        "<!--Required for race year--><table>races</table>",
        "<!--Join results and races--><column>results.raceId</column>",
        "<!--Join results and races--><column>races.raceId</column>",
        "<!--Filter: 'before year 1975'--><column>races.year</column>",
        "<!--Calculate: 'average time in seconds of champion'--><column>results.time</column>",
        "<!--Filter: 'only champion's finished time'--><column>results.position</column>",
        "<!--Group by: 'for each year'--><output_schema>integer</output_schema>",
        "<!--Calculate: 'average time in seconds of champion'--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 959,
      "db_id": "formula_1",
      "question": "What is the fastest lap number of the champion in 2009?",
      "evidence": "in 2009 refers to year = 2009; Only the time of the champion shows in the format of \"hour: minutes: seconds.millionsecond\"",
      "SQL": "SELECT T1.fastestLap FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.year = 2009 AND T1.time LIKE '_:%:__.___'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["results", "races"],
        "columns": [
          "results.fastestLap",
          "results.raceId",
          "races.raceId",
          "races.year",
          "results.time"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains race results data including fastest lap information\">results</table>",
        "<table purpose=\"Contains race information including year\">races</table>",
        "<column purpose=\"calculate: 'fastest lap number of the champion'\">results.fastestLap</column>",
        "<column purpose=\"join: races.raceId\">results.raceId</column>",
        "<column purpose=\"join: results.raceId\">races.raceId</column>",
        "<column purpose=\"filter: 'in 2009'\">races.year</column>",
        "<column purpose=\"filter: 'Only the time of the champion shows in the format of 'hour: minutes: seconds.millionsecond''\">results.time</column>",
        "<output_schema purpose=\"fastest lap number of the champion\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for race results and champion identification--><table>results</table>",
        "<!--Required to filter races from 2009--><table>races</table>",
        "<!--Filter: 'in 2009'--><column>races.year</column>",
        "<!--Join: results.raceId--><column>races.raceId</column>",
        "<!--Join: races.raceId--><column>results.raceId</column>",
        "<!--Identify champion: only champion has time in \"hour:minutes:seconds.millisecond\" format--><column>results.time</column>",
        "<!--Get fastest lap number of champion--><column>results.fastestLap</column>",
        "<!--Fastest lap number of the champion in 2009--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 960,
      "db_id": "formula_1",
      "question": "What is the average of fastest lap speed in the 2009 Spanish Grand Prix race?",
      "evidence": "Spanish Grand Prix is the name of race refers to name = 'Spanish Grand Prix'; average fastest lap speed refers to avg(fastestLapSpeed);",
      "SQL": "SELECT AVG(T1.fastestLapSpeed) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["results", "races"],
        "columns": [
          "results.fastestLapSpeed",
          "results.raceId",
          "races.raceId",
          "races.name",
          "races.year"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains race results data including fastest lap speed\">results</table>",
        "<table purpose=\"Contains race information including year and name\">races</table>",
        "<column purpose=\"calculate: 'average of fastest lap speed'\">results.fastestLapSpeed</column>",
        "<column purpose=\"join: races.raceId\">results.raceId</column>",
        "<column purpose=\"join: results.raceId\">races.raceId</column>",
        "<column purpose=\"filter: 'Spanish Grand Prix'\">races.name</column>",
        "<column purpose=\"filter: '2009'\">races.year</column>",
        "<output_schema purpose=\"average of fastest lap speed\">real</output_schema>",
        "<warning>The fastestLapSpeed column in the results table is of type text. You may need to cast it to a numeric type before calculating the average.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Spanish Grand Prix' and '2009'--><table>races</table>",
        "<!--Required for 'fastest lap speed'--><table>results</table>",
        "<!--filter: '2009'--><column>races.year</column>",
        "<!--filter: 'Spanish Grand Prix'--><column>races.name</column>",
        "<!--join: results.raceId--><column>races.raceId</column>",
        "<!--join: races.raceId--><column>results.raceId</column>",
        "<!--calculate: 'average of fastest lap speed'--><column>results.fastestLapSpeed</column>",
        "<!--average of fastest lap speed--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 962,
      "db_id": "formula_1",
      "question": "From 2000 to 2005, what percentage of drivers who were born before 1985 and the lap numbers were over 50?",
      "evidence": "born before 1985 refers to year(dob)<1985; in 2000 to 2005 refers to year between 2000 and 2005; percentage = Divide(COUNT(driverId where year (dob) <1985 and laps >50),COUNT(DriverID where year between 2000 and 2005) *100;",
      "SQL": "SELECT CAST(SUM(IIF(STRFTIME('%Y', T3.dob) < '1985' AND T1.laps > 50, 1, 0)) AS REAL) * 100 / COUNT(*) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN drivers AS T3 on T1.driverId = T3.driverId WHERE T2.year BETWEEN 2000 AND 2005",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["results", "races", "drivers"],
        "columns": [
          "results.laps",
          "drivers.dob",
          "results.raceId",
          "races.raceId",
          "races.year",
          "results.driverId",
          "drivers.driverId"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains lap information and links to races and drivers\">results</table>",
        "<table purpose=\"Contains year information for filtering\">races</table>",
        "<table purpose=\"Contains driver date of birth information\">drivers</table>",
        "<column purpose=\"filter: 'lap numbers were over 50'\">results.laps</column>",
        "<column purpose=\"filter: 'born before 1985'\">drivers.dob</column>",
        "<column purpose=\"join: results.raceId\">results.raceId</column>",
        "<column purpose=\"join: results.raceId\">races.raceId</column>",
        "<column purpose=\"filter: 'From 2000 to 2005'\">races.year</column>",
        "<column purpose=\"join: drivers.driverId, count: for percentage calculation\">results.driverId</column>",
        "<column purpose=\"join: results.driverId\">drivers.driverId</column>",
        "<output_schema purpose=\"percentage result\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for driver information and birth date--><table>drivers</table>",
        "<!--Required for race year and lap information--><table>results</table>",
        "<!--Required for race year--><table>races</table>",
        "<!--Filter: 'From 2000 to 2005'--><column>races.year</column>",
        "<!--Filter: 'born before 1985'--><column>drivers.dob</column>",
        "<!--Filter: 'lap numbers were over 50'--><column>results.laps</column>",
        "<!--Join: results.raceId--><column>races.raceId</column>",
        "<!--Join: results.driverId--><column>drivers.driverId</column>",
        "<!--Count drivers for percentage calculation--><column>results.driverId</column>",
        "<!--Percentage of drivers meeting criteria--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 963,
      "db_id": "formula_1",
      "question": "How many French drivers who obtain the laptime less than 02:00.00?",
      "evidence": "lap time less than 02:00.00 refers to seconds < 120;",
      "SQL": "SELECT COUNT(T1.driverId) FROM drivers AS T1 INNER JOIN lapTimes AS T2 on T1.driverId = T2.driverId WHERE T1.nationality = 'French' AND (CAST(SUBSTR(T2.time, 1, 2) AS INTEGER) * 60 + CAST(SUBSTR(T2.time, 4, 2) AS INTEGER) + CAST(SUBSTR(T2.time, 7, 2) AS REAL) / 1000) < 120",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["drivers", "lapTimes"],
        "columns": [
          "drivers.driverId",
          "lapTimes.driverId",
          "lapTimes.time",
          "drivers.nationality"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for driver information, including nationality\">drivers</table>",
        "<table purpose=\"Required for lap time information\">lapTimes</table>",
        "<column purpose=\"join: lapTimes.driverId\">drivers.driverId</column>",
        "<column purpose=\"join: drivers.driverId\">lapTimes.driverId</column>",
        "<column purpose=\"filter: 'laptime less than 02:00.00'\">lapTimes.time</column>",
        "<column purpose=\"filter: 'French drivers'\">drivers.nationality</column>",
        "<output_schema purpose=\"count of French drivers with lap time less than 02:00.00\">integer</output_schema>",
        "<warning>The proposal is missing lapTimes.milliseconds, which could be used instead of lapTimes.time for easier comparison with 120 seconds</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'French drivers'--><table>drivers</table>",
        "<!--Required for 'laptime'--><table>lapTimes</table>",
        "<!--filter: 'French drivers'--><column>drivers.nationality</column>",
        "<!--join: drivers.driverId--><column>lapTimes.driverId</column>",
        "<!--join: lapTimes.driverId--><column>drivers.driverId</column>",
        "<!--filter: 'laptime less than 02:00.00'--><column>lapTimes.milliseconds</column>",
        "<!--count of French drivers with laptime less than 02:00.00--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 964,
      "db_id": "formula_1",
      "question": "List out the code for drivers who have nationality in American.",
      "evidence": "nationality = 'American'",
      "SQL": "SELECT code FROM drivers WHERE Nationality = 'American'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["drivers"],
        "columns": ["drivers.code", "drivers.nationality"],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains driver information including nationality and code\">drivers</table>",
        "<column purpose=\"filter: 'nationality = American'\">drivers.nationality</column>",
        "<column purpose=\"output: 'List out the code for drivers'\">drivers.code</column>",
        "<output_schema purpose=\"Driver codes are of type text\">text</output_schema>",
        "<warning>The query may return NULL values for code, as the schema indicates that 90.1% of code entries are null.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'drivers who have nationality in American'--><table>drivers</table>",
        "<!--filter: 'nationality = American'--><column>drivers.nationality</column>",
        "<!--List out the code for drivers--><column>drivers.code</column>",
        "<!--List out the code for drivers--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 967,
      "db_id": "formula_1",
      "question": "State code numbers of top 3 yougest drivers. How many Netherlandic drivers among them?",
      "evidence": "youngest driver refers to Max (year(dob)); Netherlandic and Dutch refer to the same country",
      "SQL": "SELECT COUNT(*) FROM ( SELECT T1.nationality FROM drivers AS T1 ORDER BY JULIANDAY(T1.dob) DESC LIMIT 3) AS T3 WHERE T3.nationality = 'Dutch'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["drivers"],
        "columns": ["drivers.nationality", "drivers.dob"],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"contains driver information including date of birth and nationality\">drivers</table>",
        "<column purpose=\"filter: 'Netherlandic drivers'\">drivers.nationality</column>",
        "<column purpose=\"calculate: 'youngest driver refers to Max (year(dob))'\">drivers.dob</column>",
        "<column purpose=\"output: 'State code numbers'\">drivers.code</column>",
        "<output_schema purpose=\"count of Netherlandic drivers among top 3 youngest\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for driver information--><table>drivers</table>",
        "<!--Required to filter 'youngest drivers'--><column>drivers.dob</column>",
        "<!--Required to identify 'Netherlandic drivers'--><column>drivers.nationality</column>",
        "<!--Required for 'code numbers'--><column>drivers.code</column>",
        "<!--'top 3 youngest drivers'--><output_schema>text</output_schema>",
        "<!--'How many Netherlandic drivers among them?'--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 971,
      "db_id": "formula_1",
      "question": "Please state the reference name of the oldest German driver.",
      "evidence": "oldest refers to MIN(year(dob)); reference names appear in drverRef.",
      "SQL": "SELECT driverRef FROM drivers WHERE nationality = 'German' ORDER BY JULIANDAY(dob) ASC LIMIT 1",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["drivers"],
        "columns": ["drivers.driverRef", "drivers.nationality", "drivers.dob"],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains driver information including nationality and date of birth\">drivers</table>",
        "<column purpose=\"output: 'reference name of the oldest German driver'\">drivers.driverRef</column>",
        "<column purpose=\"filter: 'German driver'\">drivers.nationality</column>",
        "<column purpose=\"calculate: 'oldest' (MIN(year(dob)))\">drivers.dob</column>",
        "<output_schema purpose=\"driver reference name\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'German driver'--><table>drivers</table>",
        "<!--filter: 'German driver'--><column>drivers.nationality</column>",
        "<!--calculate: 'oldest' (MIN(year(dob)))--><column>drivers.dob</column>",
        "<!--output: 'reference name'--><column>drivers.driverRef</column>",
        "<!--reference name of the oldest German driver--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 972,
      "db_id": "formula_1",
      "question": "Which drivers who were born in 1971 and has the fastest lap time on the race? Give id and code of these drivers.",
      "evidence": "born in 1971 refers to year(dob) = 1971; has the fastest lap time refers to fastestLapTime has values",
      "SQL": "SELECT T2.driverId, T2.code FROM results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE STRFTIME('%Y', T2.dob) = '1971' AND T1.fastestLapTime IS NOT NULL",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["results", "drivers"],
        "columns": [
          "drivers.driverId",
          "drivers.code",
          "results.driverId",
          "drivers.dob",
          "results.fastestLapTime"
        ],
        "output_schema": ["integer", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'has the fastest lap time'\">results</table>",
        "<table purpose=\"Required for 'drivers who were born in 1971'\">drivers</table>",
        "<column purpose=\"output: 'Give id of these drivers'\">drivers.driverId</column>",
        "<column purpose=\"output: 'Give code of these drivers'\">drivers.code</column>",
        "<column purpose=\"join: drivers.driverId\">results.driverId</column>",
        "<column purpose=\"filter: 'born in 1971'\">drivers.dob</column>",
        "<column purpose=\"filter: 'has the fastest lap time'\">results.fastestLapTime</column>",
        "<output_schema purpose=\"driver id\">integer</output_schema>",
        "<output_schema purpose=\"driver code\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for driver information--><table>drivers</table>",
        "<!--Required for race results and fastest lap times--><table>results</table>",
        "<!--filter: 'born in 1971'--><column>drivers.dob</column>",
        "<!--join: results.driverId--><column>drivers.driverId</column>",
        "<!--join: drivers.driverId--><column>results.driverId</column>",
        "<!--filter: 'has the fastest lap time'--><column>results.fastestLapTime</column>",
        "<!--'Give id and code of these drivers'--><column>drivers.driverId</column>",
        "<!--'Give id and code of these drivers'--><column>drivers.code</column>",
        "<!--driver id--><output_schema>integer</output_schema>",
        "<!--driver code--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 977,
      "db_id": "formula_1",
      "question": "From race no. 50 to 100, how many finishers have been disqualified?",
      "evidence": "disqualified refers to statusID = 2, finisher refers to time! = null; race no. refers to raceId; raceId > 50 and raceId < 100;",
      "SQL": "SELECT SUM(IIF(time IS NOT NULL, 1, 0)) FROM results WHERE statusId = 2 AND raceID < 100 AND raceId > 50",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["results"],
        "columns": ["results.time", "results.raceId", "results.statusId"],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains race results data including finish times and status\">results</table>",
        "<column purpose=\"filter: 'finisher refers to time! = null'\">results.time</column>",
        "<column purpose=\"filter: 'race no. refers to raceId; raceId &gt; 50 and raceId &lt; 100'\">results.raceId</column>",
        "<column purpose=\"filter: 'disqualified refers to statusID = 2'\">results.statusId</column>",
        "<output_schema purpose=\"count of disqualified finishers\">integer</output_schema>",
        "<warning>The proposed columns are correct, but the SQL query suggests using SUM with IIF, which is not explicitly mentioned in the proposal. This approach is valid for counting the occurrences.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for race information--><table>races</table>",
        "<!--Required for result information--><table>results</table>",
        "<!--Required for status information--><table>status</table>",
        "<!--Filter: 'From race no. 50 to 100'--><column>races.raceId</column>",
        "<!--Join: races.raceId--><column>results.raceId</column>",
        "<!--Filter: 'finisher refers to time! = null'--><column>results.time</column>",
        "<!--Filter: 'disqualified refers to statusID = 2'--><column>results.statusId</column>",
        "<!--Join: results.statusId--><column>status.statusId</column>",
        "<!--Verify: 'disqualified refers to statusID = 2'--><column>status.status</column>",
        "<!--Count of disqualified finishers--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 978,
      "db_id": "formula_1",
      "question": "How many times the circuits were held in Austria? Please give their location and coordinates.",
      "evidence": "location coordinates refers to (lat,lng); Austria refers to country = 'Austria';",
      "SQL": "SELECT DISTINCT location, lat, lng FROM circuits WHERE country = 'Austria'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["circuits"],
        "columns": [
          "circuits.location",
          "circuits.lat",
          "circuits.lng",
          "circuits.country"
        ],
        "output_schema": ["text", "real", "real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for circuit information in Austria\">circuits</table>",
        "<column purpose=\"output: 'location' of circuits in Austria\">circuits.location</column>",
        "<column purpose=\"output: part of 'coordinates' (latitude) of circuits in Austria\">circuits.lat</column>",
        "<column purpose=\"output: part of 'coordinates' (longitude) of circuits in Austria\">circuits.lng</column>",
        "<column purpose=\"filter: 'Austria refers to country = 'Austria''\">circuits.country</column>",
        "<output_schema purpose=\"location of circuits in Austria\">text</output_schema>",
        "<output_schema purpose=\"latitude coordinate of circuits in Austria\">real</output_schema>",
        "<output_schema purpose=\"longitude coordinate of circuits in Austria\">real</output_schema>",
        "<warning>The query does not count 'How many times the circuits were held in Austria'. Consider adding a COUNT(*) or COUNT(DISTINCT circuitId) to get this information.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'circuits were held in Austria'--><table>circuits</table>",
        "<!--Filter: 'in Austria'--><column>circuits.country</column>",
        "<!--Required for 'location'--><column>circuits.location</column>",
        "<!--Required for 'coordinates (lat)'--><column>circuits.lat</column>",
        "<!--Required for 'coordinates (lng)'--><column>circuits.lng</column>",
        "<!--Count of circuits in Austria--><output_schema>integer</output_schema>",
        "<!--Location of circuits in Austria--><output_schema>text</output_schema>",
        "<!--Latitude coordinate of circuits in Austria--><output_schema>real</output_schema>",
        "<!--Longitude coordinate of circuits in Austria--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 981,
      "db_id": "formula_1",
      "question": "On what year did the youngest driver had his first qualifying race? Also state the name, date and time of the race.",
      "evidence": "date of birth refers to drivers.dob; The larger the birthday value, the younger the person is, and vice versa; first qualifying race refers to MIN(races.date);",
      "SQL": "SELECT T3.year, T3.name, T3.date, T3.time FROM qualifying AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 on T1.raceId = T3.raceId WHERE T1.driverId = ( SELECT driverId FROM drivers ORDER BY dob DESC LIMIT 1 ) ORDER BY T3.date ASC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["qualifying", "drivers", "races"],
        "columns": [
          "drivers.driverId",
          "drivers.dob",
          "races.year",
          "races.name",
          "races.date",
          "races.time",
          "qualifying.driverId",
          "qualifying.raceId",
          "races.raceId"
        ],
        "output_schema": ["integer", "text", "date", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for qualifying race information\">qualifying</table>",
        "<table purpose=\"Required for driver information, including date of birth\">drivers</table>",
        "<table purpose=\"Required for race details\">races</table>",
        "<column purpose=\"join: qualifying.driverId, filter: youngest driver\">drivers.driverId</column>",
        "<column purpose=\"filter: youngest driver ('The larger the birthday value, the younger the person is')\">drivers.dob</column>",
        "<column purpose=\"output: 'On what year'\">races.year</column>",
        "<column purpose=\"output: 'state the name ... of the race'\">races.name</column>",
        "<column purpose=\"output: 'state the ... date ... of the race', filter: first qualifying race\">races.date</column>",
        "<column purpose=\"output: 'state the ... time of the race'\">races.time</column>",
        "<column purpose=\"join: drivers.driverId\">qualifying.driverId</column>",
        "<column purpose=\"join: races.raceId\">qualifying.raceId</column>",
        "<column purpose=\"join: qualifying.raceId\">races.raceId</column>",
        "<output_schema purpose=\"year of the race\">integer</output_schema>",
        "<output_schema purpose=\"name of the race\">text</output_schema>",
        "<output_schema purpose=\"date of the race\">date</output_schema>",
        "<output_schema purpose=\"time of the race\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'youngest driver'--><table>drivers</table>",
        "<!--Required for 'first qualifying race'--><table>qualifying</table>",
        "<!--Required for race details--><table>races</table>",
        "<!--join: drivers.driverId--><column>qualifying.driverId</column>",
        "<!--join: qualifying.driverId--><column>drivers.driverId</column>",
        "<!--calculate: 'youngest driver'--><column>drivers.dob</column>",
        "<!--join: qualifying.raceId--><column>races.raceId</column>",
        "<!--filter: 'first qualifying race'--><column>races.date</column>",
        "<!--output: 'year'--><column>races.year</column>",
        "<!--output: 'name of the race'--><column>races.name</column>",
        "<!--output: 'date of the race'--><column>races.date</column>",
        "<!--output: 'time of the race'--><column>races.time</column>",
        "<!--year of the race--><output_schema>integer</output_schema>",
        "<!--name of the race--><output_schema>text</output_schema>",
        "<!--date of the race--><output_schema>date</output_schema>",
        "<!--time of the race--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 988,
      "db_id": "formula_1",
      "question": "List down top 3 German drivers who has the shortest average pit stop duration and were born between 1980-1985.",
      "evidence": "Full name of the driver refers to drivers.forename and drivers.surname; born between 1980-1985 refers to 1980<= year(dob) <=1985; Average pitstop duration refers to Divide(SUM(duration),COUNT(duration)); shortest average refers to Min(avg(duration));",
      "SQL": "SELECT T2.forename, T2.surname FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'German' AND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1985' GROUP BY T2.forename, T2.surname ORDER BY AVG(T1.duration) LIMIT 3",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["pitStops", "drivers"],
        "columns": [
          "drivers.forename",
          "drivers.surname",
          "pitStops.driverId",
          "drivers.driverId",
          "drivers.nationality",
          "drivers.dob",
          "pitStops.duration"
        ],
        "output_schema": ["text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for pit stop duration data\">pitStops</table>",
        "<table purpose=\"Required for driver information\">drivers</table>",
        "<column purpose=\"output: part of 'Full name of the driver'\">drivers.forename</column>",
        "<column purpose=\"output: part of 'Full name of the driver'\">drivers.surname</column>",
        "<column purpose=\"join: pitStops.driverId\">pitStops.driverId</column>",
        "<column purpose=\"join: drivers.driverId\">drivers.driverId</column>",
        "<column purpose=\"filter: 'German drivers'\">drivers.nationality</column>",
        "<column purpose=\"filter: 'born between 1980-1985'\">drivers.dob</column>",
        "<column purpose=\"calculate: 'shortest average pit stop duration'\">pitStops.duration</column>",
        "<output_schema purpose=\"driver's first name\">text</output_schema>",
        "<output_schema purpose=\"driver's last name\">text</output_schema>",
        "<warning>The proposal is missing an ORDER BY clause to sort by average pit stop duration</warning>",
        "<warning>The proposal is missing a LIMIT clause to get only the top 3 drivers</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for driver information--><table>drivers</table>",
        "<!--Required for pit stop information--><table>pitStops</table>",
        "<!--Filter: 'German drivers'--><column>drivers.nationality</column>",
        "<!--Filter: 'born between 1980-1985'--><column>drivers.dob</column>",
        "<!--Join: drivers.driverId--><column>pitStops.driverId</column>",
        "<!--Calculate: 'average pit stop duration'--><column>pitStops.duration</column>",
        "<!--Output: 'Full name of the driver'--><column>drivers.forename</column>",
        "<!--Output: 'Full name of the driver'--><column>drivers.surname</column>",
        "<!--Output: driver's full name--><output_schema>text</output_schema>",
        "<!--Output: average pit stop duration--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 989,
      "db_id": "formula_1",
      "question": "Who is the champion of the Canadian Grand Prix in 2008? Indicate his finish time.",
      "evidence": "Only the time of the champion shows in the format of \"hour: minutes: seconds.millionsecond\";",
      "SQL": "SELECT T1.time FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.name = 'Canadian Grand Prix' AND T2.year = 2008 AND T1.time LIKE '_:%:__.___'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["results", "races"],
        "columns": [
          "results.time",
          "results.raceId",
          "races.raceId",
          "races.name",
          "races.year"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains race results data, including finish times\">results</table>",
        "<table purpose=\"Contains information about races, including names and years\">races</table>",
        "<column purpose=\"calculate: 'Indicate his finish time'\">results.time</column>",
        "<column purpose=\"join: races.raceId\">results.raceId</column>",
        "<column purpose=\"join: results.raceId\">races.raceId</column>",
        "<column purpose=\"filter: 'Canadian Grand Prix'\">races.name</column>",
        "<column purpose=\"filter: 'in 2008'\">races.year</column>",
        "<output_schema purpose=\"finish time of the champion\">text</output_schema>",
        "<warning>The query is missing a way to identify the champion (first place). Consider adding results.position = 1 or results.positionOrder = 1 to ensure you're getting the winner's time.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Canadian Grand Prix in 2008'--><table>races</table>",
        "<!--Required for driver information--><table>drivers</table>",
        "<!--Required for race results--><table>results</table>",
        "<!--Filter: 'Canadian Grand Prix in 2008'--><column>races.name</column>",
        "<!--Filter: 'Canadian Grand Prix in 2008'--><column>races.year</column>",
        "<!--Join: races.raceId--><column>results.raceId</column>",
        "<!--Join: results.driverId--><column>drivers.driverId</column>",
        "<!--Filter: champion (position 1)--><column>results.position</column>",
        "<!--Finish time of champion--><column>results.time</column>",
        "<!--Champion's name--><column>drivers.forename</column>",
        "<!--Champion's name--><column>drivers.surname</column>",
        "<!--Champion of Canadian Grand Prix 2008--><output_schema>text</output_schema>",
        "<!--Finish time of champion--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 990,
      "db_id": "formula_1",
      "question": "What is the constructor reference name of the champion in the 2009 Singapore Grand Prix? Please give its website.",
      "evidence": "the time of the champion shows in the format of \"minutes: seconds.millionsecond\" in which Max(time); constructor reference name refers to constructorRef; website refers to url",
      "SQL": "SELECT T3.constructorRef, T3.url FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN constructors AS T3 on T1.constructorId = T3.constructorId WHERE T2.name = 'Singapore Grand Prix' AND T2.year = 2009 AND T1.time LIKE '_:%:__.___'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["results", "races", "constructors"],
        "columns": [
          "constructors.constructorRef",
          "constructors.url",
          "results.raceId",
          "races.raceId",
          "races.name",
          "races.year",
          "results.constructorId",
          "constructors.constructorId",
          "results.time"
        ],
        "output_schema": ["text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for race results\">results</table>",
        "<table purpose=\"Required for race information\">races</table>",
        "<table purpose=\"Required for constructor information\">constructors</table>",
        "<column purpose=\"output: 'constructor reference name'\">constructors.constructorRef</column>",
        "<column purpose=\"output: 'website'\">constructors.url</column>",
        "<column purpose=\"join: races.raceId\">results.raceId</column>",
        "<column purpose=\"join: results.raceId\">races.raceId</column>",
        "<column purpose=\"filter: 'Singapore Grand Prix'\">races.name</column>",
        "<column purpose=\"filter: '2009'\">races.year</column>",
        "<column purpose=\"join: constructors.constructorId\">results.constructorId</column>",
        "<column purpose=\"join: results.constructorId\">constructors.constructorId</column>",
        "<column purpose=\"filter: champion's time format\">results.time</column>",
        "<output_schema purpose=\"constructor reference name\">text</output_schema>",
        "<output_schema purpose=\"website\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Singapore Grand Prix' and '2009'--><table>races</table>",
        "<!--Required for 'constructor reference name'--><table>constructors</table>",
        "<!--Required for race results and champion identification--><table>results</table>",
        "<!--Filter: '2009 Singapore Grand Prix'--><column>races.year</column>",
        "<!--Filter: '2009 Singapore Grand Prix'--><column>races.name</column>",
        "<!--Join: races.raceId--><column>results.raceId</column>",
        "<!--Identify champion: 'time' in \"minutes:seconds.milliseconds\" format--><column>results.time</column>",
        "<!--Join: results.constructorId--><column>constructors.constructorId</column>",
        "<!--Output: 'constructor reference name'--><column>constructors.constructorRef</column>",
        "<!--Output: 'website'--><column>constructors.url</column>",
        "<!--constructor reference name of the champion--><output_schema>text</output_schema>",
        "<!--website of the champion constructor--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 717,
      "db_id": "superhero",
      "question": "Please list all the superpowers of 3-D Man.",
      "evidence": "3-D Man refers to superhero_name = '3-D Man'; superpowers refers to power_name",
      "SQL": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.superhero_name = '3-D Man'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["superhero", "hero_power", "superpower"],
        "columns": [
          "superpower.power_name",
          "superhero.id",
          "hero_power.hero_id",
          "hero_power.power_id",
          "superpower.id",
          "superhero.superhero_name"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to identify '3-D Man'\">superhero</table>",
        "<table purpose=\"Required to link superheroes with their powers\">hero_power</table>",
        "<table purpose=\"Required to get the names of superpowers\">superpower</table>",
        "<column purpose=\"output: 'list all the superpowers'\">superpower.power_name</column>",
        "<column purpose=\"join: hero_power.hero_id\">superhero.id</column>",
        "<column purpose=\"join: superhero.id\">hero_power.hero_id</column>",
        "<column purpose=\"join: superpower.id\">hero_power.power_id</column>",
        "<column purpose=\"join: hero_power.power_id\">superpower.id</column>",
        "<column purpose=\"filter: '3-D Man'\">superhero.superhero_name</column>",
        "<output_schema purpose=\"list of superpowers\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'superpowers of 3-D Man'--><table>superhero</table>",
        "<!--Required for 'superpowers of 3-D Man'--><table>hero_power</table>",
        "<!--Required for 'superpowers of 3-D Man'--><table>superpower</table>",
        "<!--filter: '3-D Man'--><column>superhero.superhero_name</column>",
        "<!--join: superhero.id--><column>hero_power.hero_id</column>",
        "<!--join: hero_power.power_id--><column>superpower.id</column>",
        "<!--output: 'superpowers'--><column>superpower.power_name</column>",
        "<!--list all the superpowers--><output_schema>text[]</output_schema>"
      ]
    },
    {
      "question_id": 994,
      "db_id": "formula_1",
      "question": "Which constructor scored most points from Monaco Grand Prix between 1980 and 2010? List the score, name and nationality of this team.",
      "evidence": "Monaco Grand Priz refers to the race; race in year between 1980 and 2010",
      "SQL": "SELECT SUM(T1.points), T2.name, T2.nationality FROM constructorResults AS T1 INNER JOIN constructors AS T2 ON T1.constructorId = T2.constructorId INNER JOIN races AS T3 ON T3.raceid = T1.raceid WHERE T3.name = 'Monaco Grand Prix' AND T3.year BETWEEN 1980 AND 2010 GROUP BY T2.name ORDER BY SUM(T1.points) DESC LIMIT 1",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["constructorResults", "constructors", "races"],
        "columns": [
          "constructorResults.points",
          "constructors.name",
          "constructors.nationality",
          "constructorResults.constructorId",
          "constructors.constructorId",
          "constructorResults.raceId",
          "races.raceId",
          "races.name",
          "races.year"
        ],
        "output_schema": ["real", "text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for constructor points\">constructorResults</table>",
        "<table purpose=\"Required for constructor name and nationality\">constructors</table>",
        "<table purpose=\"Required for race information\">races</table>",
        "<column purpose=\"calculate: 'scored most points'\">constructorResults.points</column>",
        "<column purpose=\"output: 'name of this team'\">constructors.name</column>",
        "<column purpose=\"output: 'nationality of this team'\">constructors.nationality</column>",
        "<column purpose=\"join: constructors.constructorId\">constructorResults.constructorId</column>",
        "<column purpose=\"join: constructorResults.constructorId\">constructors.constructorId</column>",
        "<column purpose=\"join: races.raceId\">constructorResults.raceId</column>",
        "<column purpose=\"join: constructorResults.raceId\">races.raceId</column>",
        "<column purpose=\"filter: 'Monaco Grand Prix'\">races.name</column>",
        "<column purpose=\"filter: 'between 1980 and 2010'\">races.year</column>",
        "<output_schema purpose=\"score of the constructor\">real</output_schema>",
        "<output_schema purpose=\"name of the constructor\">text</output_schema>",
        "<output_schema purpose=\"nationality of the constructor\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Monaco Grand Prix'--><table>races</table>",
        "<!--Required for 'constructor scored most points'--><table>constructorResults</table>",
        "<!--Required for 'constructor ... name and nationality'--><table>constructors</table>",
        "<!--filter: 'Monaco Grand Prix'--><column>races.name</column>",
        "<!--filter: 'between 1980 and 2010'--><column>races.year</column>",
        "<!--join: races.raceId--><column>constructorResults.raceId</column>",
        "<!--calculate: 'scored most points'--><column>constructorResults.points</column>",
        "<!--join: constructorResults.constructorId--><column>constructors.constructorId</column>",
        "<!--output: 'name of this team'--><column>constructors.name</column>",
        "<!--output: 'nationality of this team'--><column>constructors.nationality</column>",
        "<!--score of the constructor--><output_schema>real</output_schema>",
        "<!--name of the constructor--><output_schema>text</output_schema>",
        "<!--nationality of the constructor--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1001,
      "db_id": "formula_1",
      "question": "What is full name of the racer who ranked 1st in the 3rd qualifying race held in the Marina Bay Street Circuit in 2008?",
      "evidence": "Ranked 1st in the 3rd qualifying race refer to MIN(q3); 2008 is the year of race; full name of racer = forename, surname",
      "SQL": "SELECT T2.forename, T2.surname FROM qualifying AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 ON T1.raceid = T3.raceid WHERE q3 IS NOT NULL AND T3.year = 2008 AND T3.circuitId IN ( SELECT circuitId FROM circuits WHERE name = 'Marina Bay Street Circuit' ) ORDER BY CAST(SUBSTR(q3, 1, INSTR(q3, ':') - 1) AS INTEGER) * 60 + CAST(SUBSTR(q3, INSTR(q3, ':') + 1, INSTR(q3, '.') - INSTR(q3, ':') - 1) AS REAL) + CAST(SUBSTR(q3, INSTR(q3, '.') + 1) AS REAL) / 1000 ASC LIMIT 1",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["qualifying", "drivers", "races", "circuits"],
        "columns": [
          "circuits.circuitId",
          "circuits.name",
          "drivers.forename",
          "drivers.surname",
          "qualifying.driverId",
          "drivers.driverId",
          "qualifying.raceId",
          "races.raceId",
          "races.year",
          "races.circuitId",
          "qualifying.q3"
        ],
        "output_schema": ["text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains qualifying data for races\">qualifying</table>",
        "<table purpose=\"Contains driver information\">drivers</table>",
        "<table purpose=\"Contains race information\">races</table>",
        "<table purpose=\"Contains circuit information\">circuits</table>",
        "<column purpose=\"join: races.circuitId, filter: 'Marina Bay Street Circuit'\">circuits.circuitId</column>",
        "<column purpose=\"filter: 'Marina Bay Street Circuit'\">circuits.name</column>",
        "<column purpose=\"output: 'full name of the racer'\">drivers.forename</column>",
        "<column purpose=\"output: 'full name of the racer'\">drivers.surname</column>",
        "<column purpose=\"join: drivers.driverId\">qualifying.driverId</column>",
        "<column purpose=\"join: qualifying.driverId\">drivers.driverId</column>",
        "<column purpose=\"join: races.raceId\">qualifying.raceId</column>",
        "<column purpose=\"join: qualifying.raceId\">races.raceId</column>",
        "<column purpose=\"filter: '2008'\">races.year</column>",
        "<column purpose=\"join: circuits.circuitId\">races.circuitId</column>",
        "<column purpose=\"filter and sort: 'ranked 1st in the 3rd qualifying race'\">qualifying.q3</column>",
        "<output_schema purpose=\"forename of the racer\">text</output_schema>",
        "<output_schema purpose=\"surname of the racer\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for race information--><table>races</table>",
        "<!--Required for circuit information--><table>circuits</table>",
        "<!--Required for qualifying information--><table>qualifying</table>",
        "<!--Required for driver information--><table>drivers</table>",
        "<!--Filter: 'Marina Bay Street Circuit'--><column>circuits.name</column>",
        "<!--Join: races.circuitId--><column>circuits.circuitId</column>",
        "<!--Join: circuits.circuitId--><column>races.circuitId</column>",
        "<!--Filter: '2008'--><column>races.year</column>",
        "<!--Join: qualifying.raceId--><column>races.raceId</column>",
        "<!--Join: races.raceId--><column>qualifying.raceId</column>",
        "<!--Filter: '3rd qualifying race' (MIN q3)--><column>qualifying.q3</column>",
        "<!--Join: drivers.driverId--><column>qualifying.driverId</column>",
        "<!--Join: qualifying.driverId--><column>drivers.driverId</column>",
        "<!--Output: 'full name of the racer'--><column>drivers.forename</column>",
        "<!--Output: 'full name of the racer'--><column>drivers.surname</column>",
        "<!--Racer's first name--><output_schema>text</output_schema>",
        "<!--Racer's last name--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1002,
      "db_id": "formula_1",
      "question": "As of the present, what is the full name of the youngest racer? Indicate her nationality and the name of the race to which he/she first joined.",
      "evidence": "full name refers to forename+surname; Youngest racer = MAX(dob)",
      "SQL": "SELECT T1.forename, T1.surname, T1.nationality, T3.name FROM drivers AS T1 INNER JOIN driverStandings AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 on T2.raceId = T3.raceId ORDER BY JULIANDAY(T1.dob) DESC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["drivers", "driverStandings", "races"],
        "columns": [
          "drivers.forename",
          "drivers.surname",
          "drivers.nationality",
          "races.name",
          "drivers.driverId",
          "driverStandings.driverId",
          "driverStandings.raceId",
          "races.raceId",
          "drivers.dob"
        ],
        "output_schema": ["text", "text", "text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains driver information including name, nationality, and date of birth\">drivers</table>",
        "<table purpose=\"Links drivers to races they participated in\">driverStandings</table>",
        "<table purpose=\"Contains race information\">races</table>",
        "<column purpose=\"Part of full name ('forename+surname')\">drivers.forename</column>",
        "<column purpose=\"Part of full name ('forename+surname')\">drivers.surname</column>",
        "<column purpose=\"Required for 'Indicate her nationality'\">drivers.nationality</column>",
        "<column purpose=\"Required for 'name of the race to which he/she first joined'\">races.name</column>",
        "<column purpose=\"Join key with driverStandings\">drivers.driverId</column>",
        "<column purpose=\"Join key with drivers and races\">driverStandings.driverId</column>",
        "<column purpose=\"Join key with races\">driverStandings.raceId</column>",
        "<column purpose=\"Join key with driverStandings\">races.raceId</column>",
        "<column purpose=\"Required to determine 'Youngest racer = MAX(dob)'\">drivers.dob</column>",
        "<output_schema purpose=\"forename of the youngest racer\">text</output_schema>",
        "<output_schema purpose=\"surname of the youngest racer\">text</output_schema>",
        "<output_schema purpose=\"nationality of the youngest racer\">text</output_schema>",
        "<output_schema purpose=\"name of the race to which the youngest racer first joined\">text</output_schema>",
        "<warning>The query might not correctly identify the first race the driver joined. It's using driverStandings, which could include multiple races. To get the first race, you might need to use MIN(races.date) or MIN(races.year) along with MIN(races.round).</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'youngest racer'--><table>drivers</table>",
        "<!--Required for 'name of the race to which he/she first joined'--><table>results</table>",
        "<!--Required for 'name of the race'--><table>races</table>",
        "<!--calculate: 'youngest racer'--><column>drivers.dob</column>",
        "<!--'full name of the youngest racer'--><column>drivers.forename</column>",
        "<!--'full name of the youngest racer'--><column>drivers.surname</column>",
        "<!--'Indicate her nationality'--><column>drivers.nationality</column>",
        "<!--join: drivers.driverId--><column>results.driverId</column>",
        "<!--join: results.raceId--><column>races.raceId</column>",
        "<!--'name of the race to which he/she first joined'--><column>races.name</column>",
        "<!--'full name of the youngest racer'--><output_schema>text</output_schema>",
        "<!--'Indicate her nationality'--><output_schema>text</output_schema>",
        "<!--'name of the race to which he/she first joined'--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1003,
      "db_id": "formula_1",
      "question": "How many accidents did the driver who had the highest number accidents in the Canadian Grand Prix have?",
      "evidence": "number of accidents refers to the number where statusid = 3; Canadian Grand Prix refers to the race of name\n",
      "SQL": "SELECT COUNT(T1.driverId) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN status AS T3 on T1.statusId = T3.statusId WHERE T3.statusId = 3 AND T2.name = 'Canadian Grand Prix' GROUP BY T1.driverId ORDER BY COUNT(T1.driverId) DESC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["results", "races", "status"],
        "columns": [
          "results.driverId",
          "results.raceId",
          "races.raceId",
          "races.name",
          "results.statusId",
          "status.statusId"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains race results and status information\">results</table>",
        "<table purpose=\"Contains race information, including race names\">races</table>",
        "<table purpose=\"Contains status descriptions\">status</table>",
        "<column purpose=\"join: races.raceId, group by: for counting accidents per driver\">results.raceId</column>",
        "<column purpose=\"join: results.raceId\">races.raceId</column>",
        "<column purpose=\"filter: 'Canadian Grand Prix'\">races.name</column>",
        "<column purpose=\"join: status.statusId, filter: accidents (statusId = 3)\">results.statusId</column>",
        "<column purpose=\"join: results.statusId, filter: accidents (statusId = 3)\">status.statusId</column>",
        "<column purpose=\"group by: for counting accidents per driver\">results.driverId</column>",
        "<output_schema purpose=\"count of accidents for the driver with the highest number\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Canadian Grand Prix'--><table>races</table>",
        "<!--Required for driver accidents--><table>results</table>",
        "<!--Required for status description--><table>status</table>",
        "<!--Filter: 'Canadian Grand Prix'--><column>races.name</column>",
        "<!--Join: results.raceId--><column>races.raceId</column>",
        "<!--Join: races.raceId--><column>results.raceId</column>",
        "<!--Filter: 'accidents'--><column>results.statusId</column>",
        "<!--Join: status.statusId--><column>status.statusId</column>",
        "<!--Join: results.statusId--><column>status.status</column>",
        "<!--Required to count accidents per driver--><column>results.driverId</column>",
        "<!--Highest number of accidents--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 1011,
      "db_id": "formula_1",
      "question": "Which top 20 driver created the shortest lap time ever record in a Formula_1 race? Please give them full names.",
      "evidence": "shortest lap time refers to MIN(time); the time format for the shortest lap time is 'MM:SS.mmm' or 'M:SS.mmm'; full name of the driver refers to forename, surname",
      "SQL": "WITH lap_times_in_seconds AS (SELECT driverId, (CASE WHEN SUBSTR(time, 1, INSTR(time, ':') - 1) <> '' THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 ELSE 0 END + CASE WHEN SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) <> '' THEN CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) ELSE 0 END + CASE WHEN SUBSTR(time, INSTR(time, '.') + 1) <> '' THEN CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000 ELSE 0 END) AS time_in_seconds FROM lapTimes) SELECT T2.forename, T2.surname, T1.driverId FROM (SELECT driverId, MIN(time_in_seconds) AS min_time_in_seconds FROM lap_times_in_seconds GROUP BY driverId) AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId ORDER BY T1.min_time_in_seconds ASC LIMIT 20",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["drivers", "lapTimes"],
        "columns": [
          "lapTimes.driverId",
          "lapTimes.time",
          "drivers.forename",
          "drivers.surname",
          "drivers.driverId"
        ],
        "output_schema": ["text", "text", "integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for driver information\">drivers</table>",
        "<table purpose=\"Required for lap time data\">lapTimes</table>",
        "<column purpose=\"join: drivers.driverId, calculate: 'shortest lap time'\">lapTimes.driverId</column>",
        "<column purpose=\"calculate: 'shortest lap time'\">lapTimes.time</column>",
        "<column purpose=\"output: 'full names'\">drivers.forename</column>",
        "<column purpose=\"output: 'full names'\">drivers.surname</column>",
        "<column purpose=\"join: lapTimes.driverId\">drivers.driverId</column>",
        "<output_schema purpose=\"driver's forename\">text</output_schema>",
        "<output_schema purpose=\"driver's surname\">text</output_schema>",
        "<output_schema purpose=\"driver's ID\">integer</output_schema>",
        "<warning>The question asks for the top 20 drivers, but there's no LIMIT or TOP clause in the proposal to restrict the output to 20 rows.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'shortest lap time'--><table>lapTimes</table>",
        "<!--Required for 'driver full names'--><table>drivers</table>",
        "<!--Required for 'Formula_1 race'--><table>races</table>",
        "<!--calculate: 'shortest lap time'--><column>lapTimes.time</column>",
        "<!--join: drivers.driverId--><column>lapTimes.driverId</column>",
        "<!--join: lapTimes.driverId--><column>drivers.driverId</column>",
        "<!--join: races.raceId--><column>lapTimes.raceId</column>",
        "<!--join: lapTimes.raceId--><column>races.raceId</column>",
        "<!--filter: 'top 20 driver'--><column>drivers.driverId</column>",
        "<!--'full names'--><column>drivers.forename</column>",
        "<!--'full names'--><column>drivers.surname</column>",
        "<!--driver full name--><output_schema>text</output_schema>",
        "<!--shortest lap time--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 1014,
      "db_id": "formula_1",
      "question": "Please list the lap records for the circuits in Italy.",
      "evidence": "lap record means the fastest time recorded which refers to time",
      "SQL": "WITH fastest_lap_times AS (SELECT T1.raceId, T1.FastestLapTime, (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) as time_in_seconds FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL ) SELECT T1.FastestLapTime as lap_record FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId INNER JOIN (SELECT MIN(fastest_lap_times.time_in_seconds) as min_time_in_seconds FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T3.country = 'Italy' ) AS T4 ON (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) = T4.min_time_in_seconds LIMIT 1",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["results", "circuits", "races"],
        "columns": [
          "races.raceId",
          "races.circuitId",
          "results.fastestLapTime",
          "results.raceId",
          "circuits.circuitId",
          "circuits.country"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains lap time information\">results</table>",
        "<table purpose=\"Contains circuit information, including country\">circuits</table>",
        "<table purpose=\"Links races to circuits\">races</table>",
        "<column purpose=\"join: links results to races\">races.raceId</column>",
        "<column purpose=\"join: links races to circuits\">races.circuitId</column>",
        "<column purpose=\"calculate: 'lap records' (fastest time recorded)\">results.fastestLapTime</column>",
        "<column purpose=\"join: links results to races\">results.raceId</column>",
        "<column purpose=\"join: links circuits to races\">circuits.circuitId</column>",
        "<column purpose=\"filter: 'circuits in Italy'\">circuits.country</column>",
        "<output_schema purpose=\"lap record (fastest time recorded)\">text</output_schema>",
        "<warning>The proposal is missing circuits.name or a similar column to identify the specific circuits in Italy</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for circuit information--><table>circuits</table>",
        "<!--Required for lap time information--><table>lapTimes</table>",
        "<!--Required to join circuits and lapTimes--><table>races</table>",
        "<!--Filter for circuits in Italy--><column>circuits.country</column>",
        "<!--Join circuits and races--><column>circuits.circuitId</column>",
        "<!--Join circuits and races--><column>races.circuitId</column>",
        "<!--Join races and lapTimes--><column>races.raceId</column>",
        "<!--Join races and lapTimes--><column>lapTimes.raceId</column>",
        "<!--Required for lap record (fastest time)--><column>lapTimes.time</column>",
        "<!--Required for lap record (fastest time)--><column>lapTimes.milliseconds</column>",
        "<!--Required to identify the circuit--><column>circuits.name</column>",
        "<!--Circuit name for output--><output_schema>text</output_schema>",
        "<!--Lap record (fastest time) for output--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 719,
      "db_id": "superhero",
      "question": "Among the superheroes with the super power of \"Super Strength\", how many of them have a height of over 200cm?",
      "evidence": "super power of \"Super Strength\" refers to power_name = 'Super Strength'; a height of over 200cm refers to height_cm > 200",
      "SQL": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Super Strength' AND T1.height_cm > 200",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["superhero", "hero_power", "superpower"],
        "columns": [
          "superhero.id",
          "hero_power.hero_id",
          "hero_power.power_id",
          "superpower.id",
          "superpower.power_name",
          "superhero.height_cm"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero information including height\">superhero</table>",
        "<table purpose=\"Links superheroes to their superpowers\">hero_power</table>",
        "<table purpose=\"Contains superpower information\">superpower</table>",
        "<column purpose=\"join: hero_power.hero_id\">superhero.id</column>",
        "<column purpose=\"join: superhero.id\">hero_power.hero_id</column>",
        "<column purpose=\"join: superpower.id\">hero_power.power_id</column>",
        "<column purpose=\"join: hero_power.power_id\">superpower.id</column>",
        "<column purpose=\"filter: 'super power of Super Strength'\">superpower.power_name</column>",
        "<column purpose=\"filter: 'height of over 200cm'\">superhero.height_cm</column>",
        "<output_schema purpose=\"count of superheroes meeting the criteria\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'superheroes with the super power of \"Super Strength\"'--><table>hero_power</table>",
        "<!--Required for 'superheroes with the super power of \"Super Strength\"'--><table>superpower</table>",
        "<!--Required for 'height of over 200cm'--><table>superhero</table>",
        "<!--join: hero_power.power_id--><column>superpower.id</column>",
        "<!--filter: 'power_name = \"Super Strength\"'--><column>superpower.power_name</column>",
        "<!--join: superhero.id--><column>hero_power.hero_id</column>",
        "<!--filter: 'height of over 200cm'--><column>superhero.height_cm</column>",
        "<!--count of superheroes meeting criteria--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 723,
      "db_id": "superhero",
      "question": "Among the superheroes with blue eyes, how many of them have the super power of \"Agility\"?",
      "evidence": "blue eyes refers to colour = 'Blue' and eye_colour_id = colour.id; super power of \"Agility\" refers to power_name = 'Agility'",
      "SQL": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id INNER JOIN colour AS T4 ON T1.eye_colour_id = T4.id WHERE T3.power_name = 'Agility' AND T4.colour = 'Blue'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["superhero", "hero_power", "colour", "superpower"],
        "columns": [
          "superhero.id",
          "hero_power.hero_id",
          "superhero.eye_colour_id",
          "colour.id",
          "colour.colour",
          "hero_power.power_id",
          "superpower.id",
          "superpower.power_name"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero information, including eye color\">superhero</table>",
        "<table purpose=\"Links superheroes to their superpowers\">hero_power</table>",
        "<table purpose=\"Contains color information, including 'Blue' for eyes\">colour</table>",
        "<table purpose=\"Contains superpower information, including 'Agility'\">superpower</table>",
        "<column purpose=\"join: hero_power.hero_id, filter: blue-eyed superheroes with Agility\">superhero.id</column>",
        "<column purpose=\"join: superhero.id\">hero_power.hero_id</column>",
        "<column purpose=\"join: colour.id, filter: blue-eyed superheroes\">superhero.eye_colour_id</column>",
        "<column purpose=\"join: superhero.eye_colour_id\">colour.id</column>",
        "<column purpose=\"filter: 'Blue' eyes\">colour.colour</column>",
        "<column purpose=\"join: superpower.id\">hero_power.power_id</column>",
        "<column purpose=\"join: hero_power.power_id\">superpower.id</column>",
        "<column purpose=\"filter: 'Agility' superpower\">superpower.power_name</column>",
        "<output_schema purpose=\"count of blue-eyed superheroes with Agility power\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'superheroes with blue eyes'--><table>superhero</table>",
        "<!--Required for 'blue eyes'--><table>colour</table>",
        "<!--Required for 'super power of \"Agility\"'--><table>hero_power</table>",
        "<!--Required for 'super power of \"Agility\"'--><table>superpower</table>",
        "<!--join: superhero.eye_colour_id--><column>colour.id</column>",
        "<!--filter: 'blue eyes'--><column>colour.colour</column>",
        "<!--join: colour.id--><column>superhero.eye_colour_id</column>",
        "<!--join: superhero.id--><column>hero_power.hero_id</column>",
        "<!--join: hero_power.power_id--><column>superpower.id</column>",
        "<!--filter: 'super power of \"Agility\"'--><column>superpower.power_name</column>",
        "<!--count of superheroes with blue eyes and Agility power--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 724,
      "db_id": "superhero",
      "question": "Please list the superhero names of all the superheroes that have blue eyes and blond hair.",
      "evidence": "blue eyes refers to colour = 'Blue' and eye_colour_id = colour.id; blond hair refers to colour = 'Blond' and hair_colour_id = colour.id; super power of \"Agility\" refers to power_name = 'Agility'",
      "SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Blond'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["superhero", "colour"],
        "columns": [
          "superhero.superhero_name",
          "superhero.eye_colour_id",
          "colour.id",
          "colour.colour",
          "superhero.hair_colour_id"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero information including eye and hair color IDs\">superhero</table>",
        "<table purpose=\"Contains color information for eyes and hair\">colour</table>",
        "<column purpose=\"Output: 'superhero names of all the superheroes'\">superhero.superhero_name</column>",
        "<column purpose=\"Join: with colour.id for eye color\">superhero.eye_colour_id</column>",
        "<column purpose=\"Join: with superhero.eye_colour_id and superhero.hair_colour_id\">colour.id</column>",
        "<column purpose=\"Filter: 'Blue' for eyes and 'Blond' for hair\">colour.colour</column>",
        "<column purpose=\"Join: with colour.id for hair color\">superhero.hair_colour_id</column>",
        "<output_schema purpose=\"superhero names are text\">text</output_schema>",
        "<warning>The proposal is missing a reference to the hero_power and superpower tables, which are needed to filter for the \"Agility\" superpower mentioned in the question.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'superhero names'--><table>superhero</table>",
        "<!--Required for 'blue eyes' and 'blond hair'--><table>colour</table>",
        "<!--Required for 'super power of \"Agility\"'--><table>hero_power</table>",
        "<!--Required for 'super power of \"Agility\"'--><table>superpower</table>",
        "<!--'superhero names'--><column>superhero.superhero_name</column>",
        "<!--join: superhero.eye_colour_id--><column>colour.id</column>",
        "<!--filter: 'blue eyes'--><column>colour.colour</column>",
        "<!--join: superhero.hair_colour_id--><column>colour.id</column>",
        "<!--filter: 'blond hair'--><column>colour.colour</column>",
        "<!--join: superhero.id--><column>hero_power.hero_id</column>",
        "<!--join: hero_power.power_id--><column>superpower.id</column>",
        "<!--filter: 'super power of \"Agility\"'--><column>superpower.power_name</column>",
        "<!--'superhero names'--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 726,
      "db_id": "superhero",
      "question": "Rank heroes published by Marvel Comics by their height in descending order.",
      "evidence": "name refers to superhero_name; the tallest hero refers to MAX(height_cm); published by Marvel Comics refers to publisher_name = 'Marvel Comics'",
      "SQL": "SELECT superhero_name, height_cm, RANK() OVER (ORDER BY height_cm DESC) AS HeightRank FROM superhero INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["superhero", "publisher"],
        "columns": [
          "superhero.superhero_name",
          "superhero.height_cm",
          "publisher.id",
          "superhero.publisher_id",
          "publisher.publisher_name"
        ],
        "output_schema": ["text", "integer", "integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero information including name and height\">superhero</table>",
        "<table purpose=\"Contains publisher information to filter for Marvel Comics\">publisher</table>",
        "<column purpose=\"Output: 'name refers to superhero_name'\">superhero.superhero_name</column>",
        "<column purpose=\"Output and ranking: 'Rank heroes ... by their height in descending order'\">superhero.height_cm</column>",
        "<column purpose=\"Join: superhero.publisher_id\">publisher.id</column>",
        "<column purpose=\"Join: publisher.id\">superhero.publisher_id</column>",
        "<column purpose=\"Filter: 'published by Marvel Comics refers to publisher_name = 'Marvel Comics''\">publisher.publisher_name</column>",
        "<output_schema purpose=\"superhero name\">text</output_schema>",
        "<output_schema purpose=\"hero height\">integer</output_schema>",
        "<output_schema purpose=\"rank of hero by height\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'heroes published by Marvel Comics'--><table>superhero</table>",
        "<!--Required for 'published by Marvel Comics'--><table>publisher</table>",
        "<!--Required for hero names--><column>superhero.superhero_name</column>",
        "<!--Required for ranking by height--><column>superhero.height_cm</column>",
        "<!--Join superhero and publisher tables--><column>superhero.publisher_id</column>",
        "<!--Join superhero and publisher tables--><column>publisher.id</column>",
        "<!--Filter for Marvel Comics--><column>publisher.publisher_name</column>",
        "<!--Output: hero name--><output_schema>text</output_schema>",
        "<!--Output: hero height--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 728,
      "db_id": "superhero",
      "question": "Rank superheroes from Marvel Comics by their eye color popularity, starting with the most common color.",
      "evidence": "the superheroes from Marvel Comics refers to publisher_name = 'Marvel Comics'; most common color refers to COUNT(superhero.id) DESC;",
      "SQL": "SELECT colour.colour AS EyeColor, COUNT(superhero.id) AS Count, RANK() OVER (ORDER BY COUNT(superhero.id) DESC) AS PopularityRank FROM superhero INNER JOIN colour ON superhero.eye_colour_id = colour.id INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics' GROUP BY colour.colour",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["superhero", "colour", "publisher"],
        "columns": [
          "colour.colour",
          "superhero.id",
          "colour.id",
          "superhero.eye_colour_id",
          "publisher.id",
          "superhero.publisher_id",
          "publisher.publisher_name"
        ],
        "output_schema": ["text", "integer", "integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero information, including eye color and publisher\">superhero</table>",
        "<table purpose=\"Contains color information for superhero eye colors\">colour</table>",
        "<table purpose=\"Contains publisher information to filter for Marvel Comics\">publisher</table>",
        "<column purpose=\"Output: eye color names\">colour.colour</column>",
        "<column purpose=\"Calculate: count of superheroes for each eye color\">superhero.id</column>",
        "<column purpose=\"Join: with superhero.eye_colour_id\">colour.id</column>",
        "<column purpose=\"Join: with colour.id\">superhero.eye_colour_id</column>",
        "<column purpose=\"Join: with superhero.publisher_id\">publisher.id</column>",
        "<column purpose=\"Join: with publisher.id\">superhero.publisher_id</column>",
        "<column purpose=\"Filter: 'Marvel Comics'\">publisher.publisher_name</column>",
        "<output_schema purpose=\"Eye color names\">text</output_schema>",
        "<output_schema purpose=\"Count of superheroes for each eye color\">integer</output_schema>",
        "<output_schema purpose=\"Popularity rank of eye colors\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'superheroes from Marvel Comics'--><table>superhero</table>",
        "<!--Required for 'publisher_name = Marvel Comics'--><table>publisher</table>",
        "<!--Required for 'eye color'--><table>colour</table>",
        "<!--join: superhero.publisher_id--><column>publisher.id</column>",
        "<!--filter: 'Marvel Comics'--><column>publisher.publisher_name</column>",
        "<!--join: superhero.publisher_id--><column>superhero.publisher_id</column>",
        "<!--join: superhero.eye_colour_id--><column>superhero.eye_colour_id</column>",
        "<!--join: superhero.eye_colour_id--><column>colour.id</column>",
        "<!--'eye color'--><column>colour.colour</column>",
        "<!--count superheroes for ranking--><column>superhero.id</column>",
        "<!--'eye color'--><output_schema>text</output_schema>",
        "<!--'popularity' (count of superheroes)--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 730,
      "db_id": "superhero",
      "question": "List the superheroes from Marvel Comics who have the super power of 'Super Strength'.",
      "evidence": "the superheroes from Marvel Comics refers to publisher_name = 'Marvel Comics'; super power of \"Super Strength\" refers to power_name = 'Super Strength';",
      "SQL": "SELECT superhero_name FROM superhero AS T1 WHERE EXISTS (SELECT 1 FROM hero_power AS T2 INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Super Strength' AND T1.id = T2.hero_id)AND EXISTS (SELECT 1 FROM publisher AS T4 WHERE T4.publisher_name = 'Marvel Comics' AND T1.publisher_id = T4.id)",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["superhero", "hero_power", "superpower", "publisher"],
        "columns": [
          "hero_power.hero_id",
          "hero_power.power_id",
          "superpower.id",
          "superpower.power_name",
          "publisher.id",
          "publisher.publisher_name",
          "superhero.superhero_name",
          "superhero.id",
          "superhero.publisher_id"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero information\">superhero</table>",
        "<table purpose=\"Links superheroes to their powers\">hero_power</table>",
        "<table purpose=\"Contains information about superpowers\">superpower</table>",
        "<table purpose=\"Contains information about publishers\">publisher</table>",
        "<column purpose=\"join: superhero.id\">hero_power.hero_id</column>",
        "<column purpose=\"join: superpower.id\">hero_power.power_id</column>",
        "<column purpose=\"join: hero_power.power_id\">superpower.id</column>",
        "<column purpose=\"filter: 'Super Strength'\">superpower.power_name</column>",
        "<column purpose=\"join: superhero.publisher_id\">publisher.id</column>",
        "<column purpose=\"filter: 'Marvel Comics'\">publisher.publisher_name</column>",
        "<column purpose=\"output: List the superheroes\">superhero.superhero_name</column>",
        "<column purpose=\"join: hero_power.hero_id\">superhero.id</column>",
        "<column purpose=\"join: publisher.id\">superhero.publisher_id</column>",
        "<output_schema purpose=\"superhero names are stored as text\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'superheroes'--><table>superhero</table>",
        "<!--Required for 'from Marvel Comics'--><table>publisher</table>",
        "<!--Required for 'super power of \"Super Strength\"'--><table>superpower</table>",
        "<!--Required to link superheroes and superpowers--><table>hero_power</table>",
        "<!--Join: superhero.publisher_id--><column>publisher.id</column>",
        "<!--Filter: 'from Marvel Comics'--><column>publisher.publisher_name</column>",
        "<!--Join: superhero.id--><column>hero_power.hero_id</column>",
        "<!--Join: hero_power.power_id--><column>superpower.id</column>",
        "<!--Filter: 'super power of \"Super Strength\"'--><column>superpower.power_name</column>",
        "<!--Output: 'List the superheroes'--><column>superhero.superhero_name</column>",
        "<!--List of superheroes--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 732,
      "db_id": "superhero",
      "question": "Which publisher published the slowest superhero?",
      "evidence": "the slowest superhero refers to attribute_name = 'Speed' where MIN(attribute_value); publisher refers to publisher_name",
      "SQL": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN hero_attribute AS T3 ON T1.id = T3.hero_id INNER JOIN attribute AS T4 ON T3.attribute_id = T4.id WHERE T4.attribute_name = 'Speed' ORDER BY T3.attribute_value LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["superhero", "publisher", "hero_attribute", "attribute"],
        "columns": [
          "publisher.publisher_name",
          "superhero.publisher_id",
          "publisher.id",
          "superhero.id",
          "hero_attribute.hero_id",
          "hero_attribute.attribute_id",
          "attribute.id",
          "attribute.attribute_name",
          "hero_attribute.attribute_value"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for superhero information\">superhero</table>",
        "<table purpose=\"Required for publisher information\">publisher</table>",
        "<table purpose=\"Required for hero attribute information\">hero_attribute</table>",
        "<table purpose=\"Required for attribute name information\">attribute</table>",
        "<column purpose=\"output: 'Which publisher published'\">publisher.publisher_name</column>",
        "<column purpose=\"join: publisher.id\">superhero.publisher_id</column>",
        "<column purpose=\"join: superhero.publisher_id\">publisher.id</column>",
        "<column purpose=\"join: hero_attribute.hero_id\">superhero.id</column>",
        "<column purpose=\"join: superhero.id\">hero_attribute.hero_id</column>",
        "<column purpose=\"join: attribute.id\">hero_attribute.attribute_id</column>",
        "<column purpose=\"join: hero_attribute.attribute_id\">attribute.id</column>",
        "<column purpose=\"filter: 'attribute_name = 'Speed''\">attribute.attribute_name</column>",
        "<column purpose=\"calculate: 'MIN(attribute_value)', filter: 'the slowest superhero'\">hero_attribute.attribute_value</column>",
        "<output_schema purpose=\"publisher name of the slowest superhero\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'slowest superhero'--><table>hero_attribute</table>",
        "<!--Required for 'publisher'--><table>publisher</table>",
        "<!--Required to link hero_attribute to superhero--><table>superhero</table>",
        "<!--Required to filter 'Speed' attribute--><table>attribute</table>",
        "<!--join: hero_attribute.hero_id--><column>superhero.id</column>",
        "<!--join: superhero.publisher_id--><column>publisher.id</column>",
        "<!--join: hero_attribute.attribute_id--><column>attribute.id</column>",
        "<!--filter: 'Speed' attribute--><column>attribute.attribute_name</column>",
        "<!--calculate: 'slowest superhero'--><column>hero_attribute.attribute_value</column>",
        "<!--output: 'Which publisher'--><column>publisher.publisher_name</column>",
        "<!--publisher of the slowest superhero--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 733,
      "db_id": "superhero",
      "question": "How many gold-eyed superheroes did Marvel Comics publish?",
      "evidence": "gold-eyed refers to colour = 'Gold' where eye_colour_id = colour.id; superheroes that Marvel Comics published refers to publisher_name = 'Marvel Comics'",
      "SQL": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN colour AS T3 ON T1.eye_colour_id = T3.id WHERE T2.publisher_name = 'Marvel Comics' AND T3.colour = 'Gold'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["superhero", "publisher", "colour"],
        "columns": [
          "superhero.id",
          "superhero.publisher_id",
          "publisher.id",
          "publisher.publisher_name",
          "superhero.eye_colour_id",
          "colour.id",
          "colour.colour"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero data including eye color and publisher information\">superhero</table>",
        "<table purpose=\"Contains publisher information for filtering Marvel Comics\">publisher</table>",
        "<table purpose=\"Contains color information for filtering gold-eyed superheroes\">colour</table>",
        "<column purpose=\"Used for counting unique superheroes\">superhero.id</column>",
        "<column purpose=\"join: publisher.id\">superhero.publisher_id</column>",
        "<column purpose=\"join: superhero.publisher_id\">publisher.id</column>",
        "<column purpose=\"filter: 'Marvel Comics'\">publisher.publisher_name</column>",
        "<column purpose=\"join: colour.id\">superhero.eye_colour_id</column>",
        "<column purpose=\"join: superhero.eye_colour_id\">colour.id</column>",
        "<column purpose=\"filter: 'Gold'\">colour.colour</column>",
        "<output_schema purpose=\"Count of gold-eyed Marvel Comics superheroes\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'superheroes'--><table>superhero</table>",
        "<!--Required for 'gold-eyed'--><table>colour</table>",
        "<!--Required for 'Marvel Comics'--><table>publisher</table>",
        "<!--join: superhero.eye_colour_id--><column>colour.id</column>",
        "<!--filter: 'gold-eyed'--><column>colour.colour</column>",
        "<!--join: colour.id--><column>superhero.eye_colour_id</column>",
        "<!--join: superhero.publisher_id--><column>publisher.id</column>",
        "<!--filter: 'Marvel Comics'--><column>publisher.publisher_name</column>",
        "<!--join: publisher.id--><column>superhero.publisher_id</column>",
        "<!--count of 'gold-eyed superheroes' published by 'Marvel Comics'--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 736,
      "db_id": "superhero",
      "question": "Who is the dumbest superhero?",
      "evidence": "the dumbest superhero refers to MIN(attribute_value) where attribute_name = 'Intelligence'",
      "SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Intelligence' ORDER BY T2.attribute_value LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["superhero", "hero_attribute", "attribute"],
        "columns": [
          "superhero.superhero_name",
          "superhero.id",
          "hero_attribute.hero_id",
          "hero_attribute.attribute_id",
          "attribute.id",
          "attribute.attribute_name",
          "hero_attribute.attribute_value"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero information, including name\">superhero</table>",
        "<table purpose=\"Links superheroes to their attributes\">hero_attribute</table>",
        "<table purpose=\"Contains attribute information, including 'Intelligence'\">attribute</table>",
        "<column purpose=\"Output: name of the dumbest superhero\">superhero.superhero_name</column>",
        "<column purpose=\"Join: superhero.id = hero_attribute.hero_id\">superhero.id</column>",
        "<column purpose=\"Join: superhero.id = hero_attribute.hero_id\">hero_attribute.hero_id</column>",
        "<column purpose=\"Join: hero_attribute.attribute_id = attribute.id\">hero_attribute.attribute_id</column>",
        "<column purpose=\"Join: hero_attribute.attribute_id = attribute.id\">attribute.id</column>",
        "<column purpose=\"Filter: 'Intelligence'\">attribute.attribute_name</column>",
        "<column purpose=\"Sort: MIN(attribute_value)\">hero_attribute.attribute_value</column>",
        "<output_schema purpose=\"Name of the dumbest superhero\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'dumbest superhero'--><table>superhero</table>",
        "<!--Required for 'dumbest superhero'--><table>hero_attribute</table>",
        "<!--Required for 'attribute_name = Intelligence'--><table>attribute</table>",
        "<!--join: superhero.id--><column>hero_attribute.hero_id</column>",
        "<!--join: hero_attribute.hero_id--><column>superhero.id</column>",
        "<!--join: hero_attribute.attribute_id--><column>attribute.id</column>",
        "<!--filter: 'attribute_name = Intelligence'--><column>attribute.attribute_name</column>",
        "<!--calculate: 'MIN(attribute_value)'--><column>hero_attribute.attribute_value</column>",
        "<!--'Who is the dumbest superhero?'--><column>superhero.superhero_name</column>",
        "<!--Name of the dumbest superhero--><output_schema>text</output_schema>",
        "<!--Minimum intelligence value--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 737,
      "db_id": "superhero",
      "question": "What is Copycat's race?",
      "evidence": "Copycat is the superhero_name;",
      "SQL": "SELECT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.superhero_name = 'Copycat'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["superhero", "race"],
        "columns": [
          "race.race",
          "superhero.race_id",
          "race.id",
          "superhero.superhero_name"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero information, including name and race_id\">superhero</table>",
        "<table purpose=\"Contains race information for superheroes\">race</table>",
        "<column purpose=\"Output: 'Copycat's race'\">race.race</column>",
        "<column purpose=\"Join: superhero.race_id = race.id\">superhero.race_id</column>",
        "<column purpose=\"Join: superhero.race_id = race.id\">race.id</column>",
        "<column purpose=\"Filter: 'Copycat is the superhero_name'\">superhero.superhero_name</column>",
        "<output_schema purpose=\"Race of Copycat\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Copycat's race'--><table>superhero</table>",
        "<!--Required to get race name--><table>race</table>",
        "<!--filter: 'Copycat is the superhero_name'--><column>superhero.superhero_name</column>",
        "<!--join: superhero.race_id--><column>race.id</column>",
        "<!--join: race.id--><column>superhero.race_id</column>",
        "<!--output: 'Copycat's race'--><column>race.race</column>",
        "<!--Copycat's race--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 738,
      "db_id": "superhero",
      "question": "Which superheroes have a durability attribute value of less than 50?",
      "evidence": "durability of less than 50 refers to attribute_name = 'Durability' AND attribute_value < 50",
      "SQL": "SELECT superhero_name FROM superhero AS T1 WHERE EXISTS (SELECT 1 FROM hero_attribute AS T2 INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Durability' AND T2.attribute_value < 50 AND T1.id = T2.hero_id)",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["superhero", "hero_attribute", "attribute"],
        "columns": [
          "hero_attribute.hero_id",
          "hero_attribute.attribute_id",
          "attribute.id",
          "attribute.attribute_name",
          "hero_attribute.attribute_value",
          "superhero.superhero_name",
          "superhero.id"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero names and IDs\">superhero</table>",
        "<table purpose=\"Links heroes to their attributes and values\">hero_attribute</table>",
        "<table purpose=\"Contains attribute names\">attribute</table>",
        "<column purpose=\"join: superhero.id\">hero_attribute.hero_id</column>",
        "<column purpose=\"join: attribute.id\">hero_attribute.attribute_id</column>",
        "<column purpose=\"join: hero_attribute.attribute_id\">attribute.id</column>",
        "<column purpose=\"filter: 'durability attribute'\">attribute.attribute_name</column>",
        "<column purpose=\"filter: 'value of less than 50'\">hero_attribute.attribute_value</column>",
        "<column purpose=\"output: 'Which superheroes'\">superhero.superhero_name</column>",
        "<column purpose=\"join: hero_attribute.hero_id\">superhero.id</column>",
        "<output_schema purpose=\"superhero names\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'superheroes'--><table>superhero</table>",
        "<!--Required for 'durability attribute value'--><table>hero_attribute</table>",
        "<!--Required to identify 'durability' attribute--><table>attribute</table>",
        "<!--join: superhero.id--><column>hero_attribute.hero_id</column>",
        "<!--join: hero_attribute.hero_id--><column>superhero.id</column>",
        "<!--join: hero_attribute.attribute_id--><column>attribute.id</column>",
        "<!--filter: 'durability'--><column>attribute.attribute_name</column>",
        "<!--filter: 'less than 50'--><column>hero_attribute.attribute_value</column>",
        "<!--output: superhero names--><column>superhero.superhero_name</column>",
        "<!--list of superheroes--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 739,
      "db_id": "superhero",
      "question": "What are the names of the superheroes with the power of death touch?",
      "evidence": "name of superheroes refers to refers to superhero_name; the power of death touch refers to power_name = 'Death Touch'",
      "SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Death Touch'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["superhero", "hero_power", "superpower"],
        "columns": [
          "superhero.superhero_name",
          "superhero.id",
          "hero_power.hero_id",
          "hero_power.power_id",
          "superpower.id",
          "superpower.power_name"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero names\">superhero</table>",
        "<table purpose=\"Links superheroes to their powers\">hero_power</table>",
        "<table purpose=\"Contains superpower information\">superpower</table>",
        "<column purpose=\"Output: 'names of the superheroes'\">superhero.superhero_name</column>",
        "<column purpose=\"Join: superhero.id = hero_power.hero_id\">superhero.id</column>",
        "<column purpose=\"Join: superhero.id = hero_power.hero_id\">hero_power.hero_id</column>",
        "<column purpose=\"Join: hero_power.power_id = superpower.id\">hero_power.power_id</column>",
        "<column purpose=\"Join: hero_power.power_id = superpower.id\">superpower.id</column>",
        "<column purpose=\"Filter: 'power of death touch'\">superpower.power_name</column>",
        "<output_schema purpose=\"Names of superheroes are text\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'names of the superheroes'--><table>superhero</table>",
        "<!--Required for 'power of death touch'--><table>superpower</table>",
        "<!--Required to link superheroes and powers--><table>hero_power</table>",
        "<!--'names of the superheroes'--><column>superhero.superhero_name</column>",
        "<!--join: superhero.id--><column>hero_power.hero_id</column>",
        "<!--join: hero_power.hero_id--><column>superhero.id</column>",
        "<!--join: hero_power.power_id--><column>superpower.id</column>",
        "<!--filter: 'power of death touch'--><column>superpower.power_name</column>",
        "<!--names of the superheroes with the power of death touch--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 740,
      "db_id": "superhero",
      "question": "How many female superheroes have a strength value of 100?",
      "evidence": "female refers to gender = 'Female'; strength value of 100 refers to attribute_name = 'Strength' AND attribute_value = 100",
      "SQL": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id INNER JOIN gender AS T4 ON T1.gender_id = T4.id WHERE T3.attribute_name = 'Strength' AND T2.attribute_value = 100 AND T4.gender = 'Female'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["superhero", "hero_attribute", "gender", "attribute"],
        "columns": [
          "superhero.id",
          "hero_attribute.hero_id",
          "hero_attribute.attribute_value",
          "superhero.gender_id",
          "gender.id",
          "gender.gender",
          "hero_attribute.attribute_id",
          "attribute.id",
          "attribute.attribute_name"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero information\">superhero</table>",
        "<table purpose=\"Links superheroes to their attributes\">hero_attribute</table>",
        "<table purpose=\"Contains gender information\">gender</table>",
        "<table purpose=\"Contains attribute information\">attribute</table>",
        "<column purpose=\"join: hero_attribute.hero_id, identify unique superheroes\">superhero.id</column>",
        "<column purpose=\"join: superhero.id\">hero_attribute.hero_id</column>",
        "<column purpose=\"filter: 'strength value of 100'\">hero_attribute.attribute_value</column>",
        "<column purpose=\"join: gender.id\">superhero.gender_id</column>",
        "<column purpose=\"join: superhero.gender_id\">gender.id</column>",
        "<column purpose=\"filter: 'female superheroes'\">gender.gender</column>",
        "<column purpose=\"join: attribute.id\">hero_attribute.attribute_id</column>",
        "<column purpose=\"join: hero_attribute.attribute_id\">attribute.id</column>",
        "<column purpose=\"filter: 'strength value'\">attribute.attribute_name</column>",
        "<output_schema purpose=\"count of female superheroes with strength value of 100\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'female superheroes'--><table>superhero</table>",
        "<!--Required for 'female superheroes'--><table>gender</table>",
        "<!--Required for 'strength value'--><table>hero_attribute</table>",
        "<!--Required for 'strength value'--><table>attribute</table>",
        "<!--join: superhero.gender_id--><column>gender.id</column>",
        "<!--filter: 'female'--><column>gender.gender</column>",
        "<!--join: superhero.id--><column>hero_attribute.hero_id</column>",
        "<!--join: hero_attribute.attribute_id--><column>attribute.id</column>",
        "<!--filter: 'strength'--><column>attribute.attribute_name</column>",
        "<!--filter: 'value of 100'--><column>hero_attribute.attribute_value</column>",
        "<!--count of female superheroes with strength 100--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 743,
      "db_id": "superhero",
      "question": "What is the percentage of superheroes who act in their own self-interest or make decisions based on their own moral code? Indicate how many of the said superheroes were published by Marvel Comics.",
      "evidence": "published by Marvel Comics refers to publisher_name = 'Marvel Comics'; superheroes who act in their own self-interest or make decisions based on their own moral code refers to alignment = 'Bad'; calculation = MULTIPLY(DIVIDE(SUM(alignment = 'Bad); count(id)), 100)",
      "SQL": "SELECT (CAST(COUNT(*) AS REAL) * 100 / (SELECT COUNT(*) FROM superhero)), CAST(SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) AS REAL) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN alignment AS T3 ON T3.id = T1.alignment_id WHERE T3.alignment = 'Bad'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["superhero", "publisher", "alignment"],
        "columns": [
          "publisher.publisher_name",
          "superhero.publisher_id",
          "publisher.id",
          "superhero.alignment_id",
          "alignment.id",
          "alignment.alignment"
        ],
        "output_schema": ["real", "real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero data, including alignment and publisher information\">superhero</table>",
        "<table purpose=\"Contains publisher information\">publisher</table>",
        "<table purpose=\"Contains alignment information\">alignment</table>",
        "<column purpose=\"filter: 'published by Marvel Comics'\">publisher.publisher_name</column>",
        "<column purpose=\"join: superhero.publisher_id\">publisher.id</column>",
        "<column purpose=\"join: publisher.id\">superhero.publisher_id</column>",
        "<column purpose=\"join: superhero.alignment_id\">alignment.id</column>",
        "<column purpose=\"join: alignment.id\">superhero.alignment_id</column>",
        "<column purpose=\"filter: 'superheroes who act in their own self-interest or make decisions based on their own moral code'\">alignment.alignment</column>",
        "<output_schema purpose=\"percentage of superheroes with 'Bad' alignment\">real</output_schema>",
        "<output_schema purpose=\"count of 'Bad' alignment superheroes published by Marvel Comics\">real</output_schema>",
        "<warning>The proposal is missing superhero.id, which is needed to count the total number of superheroes for percentage calculation</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for superhero count and alignment info--><table>superhero</table>",
        "<!--Required for alignment info--><table>alignment</table>",
        "<!--Required for publisher info--><table>publisher</table>",
        "<!--Join superhero and alignment tables--><column>superhero.alignment_id</column>",
        "<!--Join superhero and alignment tables--><column>alignment.id</column>",
        "<!--Filter for 'Bad' alignment--><column>alignment.alignment</column>",
        "<!--Join superhero and publisher tables--><column>superhero.publisher_id</column>",
        "<!--Join superhero and publisher tables--><column>publisher.id</column>",
        "<!--Filter for Marvel Comics--><column>publisher.publisher_name</column>",
        "<!--Count of all superheroes--><column>superhero.id</column>",
        "<!--Percentage of 'Bad' alignment superheroes--><output_schema>real</output_schema>",
        "<!--Count of 'Bad' alignment superheroes published by Marvel Comics--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 744,
      "db_id": "superhero",
      "question": "Between DC and Marvel Comics, which publisher has published more superheroes? Find the difference in the number of superheroes they have published.",
      "evidence": "DC refers to publisher_name = 'DC Comics'; Marvel Comics refers to publisher_name = 'Marvel Comics'; calculation = SUBTRACT(SUM(publisher_name = 'Marvel Comics'), SUM(publisher_name = 'DC Comics'))",
      "SQL": "SELECT SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["superhero", "publisher"],
        "columns": [
          "publisher.publisher_name",
          "superhero.publisher_id",
          "publisher.id"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for counting superheroes\">superhero</table>",
        "<table purpose=\"Required for publisher names\">publisher</table>",
        "<column purpose=\"filter: 'DC Comics' and 'Marvel Comics'\">publisher.publisher_name</column>",
        "<column purpose=\"join: publisher.id\">superhero.publisher_id</column>",
        "<column purpose=\"join: superhero.publisher_id\">publisher.id</column>",
        "<output_schema purpose=\"difference in number of superheroes\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'publisher has published more superheroes'--><table>superhero</table>",
        "<!--Required for 'DC Comics' and 'Marvel Comics'--><table>publisher</table>",
        "<!--join: superhero.publisher_id--><column>publisher.id</column>",
        "<!--join: publisher.id--><column>superhero.publisher_id</column>",
        "<!--filter: 'DC Comics' and 'Marvel Comics'--><column>publisher.publisher_name</column>",
        "<!--count: 'number of superheroes'--><column>superhero.id</column>",
        "<!--difference in the number of superheroes--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 745,
      "db_id": "superhero",
      "question": "Give the publisher ID of Star Trek.",
      "evidence": "Star Trek is the publisher_name;",
      "SQL": "SELECT id FROM publisher WHERE publisher_name = 'Star Trek'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["publisher"],
        "columns": ["publisher.id", "publisher.publisher_name"],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to find the publisher ID of Star Trek\">publisher</table>",
        "<column purpose=\"output: 'publisher ID of Star Trek'\">publisher.id</column>",
        "<column purpose=\"filter: 'Star Trek is the publisher_name'\">publisher.publisher_name</column>",
        "<output_schema purpose=\"publisher ID is an integer\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'publisher ID'--><table>publisher</table>",
        "<!--filter: 'Star Trek is the publisher_name'--><column>publisher.publisher_name</column>",
        "<!--'Give the publisher ID'--><column>publisher.id</column>",
        "<!--publisher ID of Star Trek--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 747,
      "db_id": "superhero",
      "question": "What is the total number of superheroes without full name?",
      "evidence": "superheroes without full name refers to full_name IS NULL",
      "SQL": "SELECT COUNT(id) FROM superhero WHERE full_name IS NULL",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["superhero"],
        "columns": ["superhero.id", "superhero.full_name"],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for counting superheroes\">superhero</table>",
        "<column purpose=\"count: 'total number of superheroes'\">superhero.id</column>",
        "<column purpose=\"filter: 'without full name'\">superhero.full_name</column>",
        "<output_schema purpose=\"total number of superheroes without full name\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'total number of superheroes'--><table>superhero</table>",
        "<!--filter: 'without full name'--><column>superhero.full_name</column>",
        "<!--total number of superheroes without full name--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 750,
      "db_id": "superhero",
      "question": "What is the average weight of all female superheroes?",
      "evidence": "female refers to gender = 'Female'; average weight refers to AVG(weight_kg)",
      "SQL": "SELECT AVG(T1.weight_kg) FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T2.gender = 'Female'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["superhero", "gender"],
        "columns": [
          "superhero.weight_kg",
          "superhero.gender_id",
          "gender.id",
          "gender.gender"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero data including weight\">superhero</table>",
        "<table purpose=\"Contains gender information for filtering female superheroes\">gender</table>",
        "<column purpose=\"calculate: 'average weight'\">superhero.weight_kg</column>",
        "<column purpose=\"join: gender.id\">superhero.gender_id</column>",
        "<column purpose=\"join: superhero.gender_id\">gender.id</column>",
        "<column purpose=\"filter: 'female superheroes'\">gender.gender</column>",
        "<output_schema purpose=\"average weight of female superheroes\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'average weight of all female superheroes'--><table>superhero</table>",
        "<!--Required to filter 'female superheroes'--><table>gender</table>",
        "<!--join: superhero.gender_id--><column>gender.id</column>",
        "<!--join: gender.id--><column>superhero.gender_id</column>",
        "<!--filter: 'female'--><column>gender.gender</column>",
        "<!--calculate: 'average weight'--><column>superhero.weight_kg</column>",
        "<!--average weight of female superheroes--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 751,
      "db_id": "superhero",
      "question": "List down at least five superpowers of male superheroes.",
      "evidence": "male refers to gender = 'Male'; superpowers refers to power_name;",
      "SQL": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T3.id = T2.power_id INNER JOIN gender AS T4 ON T4.id = T1.gender_id WHERE T4.gender = 'Male' LIMIT 5",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["superhero", "hero_power", "gender", "superpower"],
        "columns": [
          "superpower.power_name",
          "superhero.id",
          "hero_power.hero_id",
          "superhero.gender_id",
          "gender.id",
          "gender.gender",
          "hero_power.power_id",
          "superpower.id"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for superhero information\">superhero</table>",
        "<table purpose=\"Links superheroes to their powers\">hero_power</table>",
        "<table purpose=\"Contains gender information\">gender</table>",
        "<table purpose=\"Contains superpower information\">superpower</table>",
        "<column purpose=\"Output: 'List down at least five superpowers'\">superpower.power_name</column>",
        "<column purpose=\"Join: superhero.id\">superhero.id</column>",
        "<column purpose=\"Join: superhero.id\">hero_power.hero_id</column>",
        "<column purpose=\"Join: gender.id\">superhero.gender_id</column>",
        "<column purpose=\"Join: superhero.gender_id\">gender.id</column>",
        "<column purpose=\"Filter: 'male superheroes'\">gender.gender</column>",
        "<column purpose=\"Join: superpower.id\">hero_power.power_id</column>",
        "<column purpose=\"Join: hero_power.power_id\">superpower.id</column>",
        "<output_schema purpose=\"List of superpower names\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'superpowers'--><table>superpower</table>",
        "<!--Required for 'male superheroes'--><table>superhero</table>",
        "<!--Required for 'male'--><table>gender</table>",
        "<!--Required to link superheroes and superpowers--><table>hero_power</table>",
        "<!--join: superhero.id--><column>hero_power.hero_id</column>",
        "<!--join: hero_power.hero_id--><column>superhero.id</column>",
        "<!--join: superhero.gender_id--><column>gender.id</column>",
        "<!--join: gender.id--><column>superhero.gender_id</column>",
        "<!--filter: 'male'--><column>gender.gender</column>",
        "<!--join: hero_power.power_id--><column>superpower.id</column>",
        "<!--join: superpower.id--><column>hero_power.power_id</column>",
        "<!--output: 'superpowers'--><column>superpower.power_name</column>",
        "<!--List down at least five superpowers--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 753,
      "db_id": "superhero",
      "question": "Among the superheroes with height from 170 to 190, list the names of the superheroes with no eye color.",
      "evidence": "height from 170 to 190 refers to height_cm BETWEEN 170 AND 190; no eye color refers to colour = 'No Colour'",
      "SQL": "SELECT DISTINCT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.height_cm BETWEEN 170 AND 190 AND T2.colour = 'No Colour'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["superhero", "colour"],
        "columns": [
          "superhero.superhero_name",
          "superhero.eye_colour_id",
          "colour.id",
          "colour.colour",
          "superhero.height_cm"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero information including name, height, and eye color\">superhero</table>",
        "<table purpose=\"Contains color information for superhero attributes\">colour</table>",
        "<column purpose=\"Output: 'list the names of the superheroes'\">superhero.superhero_name</column>",
        "<column purpose=\"Join: link superhero to their eye color\">superhero.eye_colour_id</column>",
        "<column purpose=\"Join: link color to superhero\">colour.id</column>",
        "<column purpose=\"Filter: 'no eye color' (colour = 'No Colour')\">colour.colour</column>",
        "<column purpose=\"Filter: 'height from 170 to 190' (BETWEEN 170 AND 190)\">superhero.height_cm</column>",
        "<output_schema purpose=\"superhero names are text\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for superhero information--><table>superhero</table>",
        "<!--Required for eye color information--><table>colour</table>",
        "<!--Filter: 'height from 170 to 190'--><column>superhero.height_cm</column>",
        "<!--Join: superhero.eye_colour_id--><column>colour.id</column>",
        "<!--Join: colour.id--><column>superhero.eye_colour_id</column>",
        "<!--Filter: 'no eye color'--><column>colour.colour</column>",
        "<!--Output: 'list the names of the superheroes'--><column>superhero.superhero_name</column>",
        "<!--Names of superheroes--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 758,
      "db_id": "superhero",
      "question": "Provide the hair colour of the human superhero who is 185 cm tall.",
      "evidence": "185 cm tall refers to height_cm = 185; human superhero refers to race = 'human'; hair colour refers to colour where hair_colour_id = colour.id;",
      "SQL": "SELECT DISTINCT T3.colour FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T1.height_cm = 185 AND T2.race = 'Human'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["superhero", "race", "colour"],
        "columns": [
          "colour.colour",
          "superhero.race_id",
          "race.id",
          "race.race",
          "superhero.hair_colour_id",
          "colour.id",
          "superhero.height_cm"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero information including height and race\">superhero</table>",
        "<table purpose=\"Provides race information for filtering 'human superhero'\">race</table>",
        "<table purpose=\"Contains hair colour information\">colour</table>",
        "<column purpose=\"output: 'hair colour of the human superhero'\">colour.colour</column>",
        "<column purpose=\"join: race.id\">superhero.race_id</column>",
        "<column purpose=\"join: superhero.race_id\">race.id</column>",
        "<column purpose=\"filter: 'human superhero'\">race.race</column>",
        "<column purpose=\"join: colour.id\">superhero.hair_colour_id</column>",
        "<column purpose=\"join: superhero.hair_colour_id\">colour.id</column>",
        "<column purpose=\"filter: '185 cm tall'\">superhero.height_cm</column>",
        "<output_schema purpose=\"hair colour (text value)\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'human superhero'--><table>superhero</table>",
        "<!--Required for 'human superhero'--><table>race</table>",
        "<!--Required for 'hair colour'--><table>colour</table>",
        "<!--filter: '185 cm tall'--><column>superhero.height_cm</column>",
        "<!--join: superhero.race_id--><column>race.id</column>",
        "<!--filter: 'human superhero'--><column>race.race</column>",
        "<!--join: superhero.hair_colour_id--><column>colour.id</column>",
        "<!--output: 'hair colour'--><column>colour.colour</column>",
        "<!--hair colour of the human superhero who is 185 cm tall--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 760,
      "db_id": "superhero",
      "question": "In superheroes with height between 150 to 180, what is the percentage of heroes published by Marvel Comics?",
      "evidence": "height between 150 to 180 refers to height_cm BETWEEN 150 AND 180; heroes published by Marvel Comics refers to publisher_name = 'Marvel Comics'; calculation = MULTIPLY(DIVIDE(SUM(publisher.id = 13)), COUNT(publisher.id), 100)",
      "SQL": "SELECT CAST(COUNT(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.height_cm BETWEEN 150 AND 180",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["superhero", "publisher"],
        "columns": [
          "publisher.publisher_name",
          "superhero.id",
          "superhero.publisher_id",
          "publisher.id",
          "superhero.height_cm"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for superhero data, including height and publisher information\">superhero</table>",
        "<table purpose=\"Required to get publisher names\">publisher</table>",
        "<column purpose=\"filter: 'heroes published by Marvel Comics'\">publisher.publisher_name</column>",
        "<column purpose=\"count: total number of superheroes\">superhero.id</column>",
        "<column purpose=\"join: superhero.publisher_id\">superhero.publisher_id</column>",
        "<column purpose=\"join: publisher.id\">publisher.id</column>",
        "<column purpose=\"filter: 'height between 150 to 180'\">superhero.height_cm</column>",
        "<output_schema purpose=\"percentage of heroes published by Marvel Comics\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'superheroes with height between 150 to 180'--><table>superhero</table>",
        "<!--Required for 'heroes published by Marvel Comics'--><table>publisher</table>",
        "<!--filter: 'height between 150 to 180'--><column>superhero.height_cm</column>",
        "<!--join: superhero.publisher_id--><column>publisher.id</column>",
        "<!--join: publisher.id--><column>superhero.publisher_id</column>",
        "<!--filter: 'heroes published by Marvel Comics'--><column>publisher.publisher_name</column>",
        "<!--percentage of heroes published by Marvel Comics--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 761,
      "db_id": "superhero",
      "question": "Among the male superheroes, list the super hero names of superheroes with weight greater than the 79% average weight of all superheroes.",
      "evidence": "super hero names refers to superhero_name;male superheros refers to gender = 'Male';Calculation = weight_kg > MULTIPLY(AVG(weight_kg), 0.79)",
      "SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T2.gender = 'Male' AND T1.weight_kg * 100 > ( SELECT AVG(weight_kg) FROM superhero ) * 79",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["superhero", "gender"],
        "columns": [
          "superhero.weight_kg",
          "superhero.superhero_name",
          "superhero.gender_id",
          "gender.id",
          "gender.gender"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero information including weight and name\">superhero</table>",
        "<table purpose=\"Required to filter for male superheroes\">gender</table>",
        "<column purpose=\"calculate: 'weight greater than the 79% average weight', filter: 'weight greater than the 79% average weight'\">superhero.weight_kg</column>",
        "<column purpose=\"output: 'list the super hero names'\">superhero.superhero_name</column>",
        "<column purpose=\"join: gender.id\">superhero.gender_id</column>",
        "<column purpose=\"join: superhero.gender_id\">gender.id</column>",
        "<column purpose=\"filter: 'male superheroes'\">gender.gender</column>",
        "<output_schema purpose=\"list of superhero names\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'male superheroes'--><table>superhero</table>",
        "<!--Required for 'male superheroes'--><table>gender</table>",
        "<!--Required for superhero names--><column>superhero.superhero_name</column>",
        "<!--Required for weight comparison--><column>superhero.weight_kg</column>",
        "<!--Required to filter male superheroes--><column>superhero.gender_id</column>",
        "<!--Required to join with superhero table--><column>gender.id</column>",
        "<!--Required to filter male superheroes--><column>gender.gender</column>",
        "<!--superhero names of superheroes meeting the criteria--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 764,
      "db_id": "superhero",
      "question": "What are the superpowers of heroes with ID 1?",
      "evidence": "superpowers refers to power_name; heroes with ID 1 refers to hero_id = 1;",
      "SQL": "SELECT DISTINCT T2.power_name FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T1.hero_id = 1",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["hero_power", "superpower"],
        "columns": [
          "superpower.power_name",
          "hero_power.power_id",
          "superpower.id",
          "hero_power.hero_id"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to link heroes to their powers\">hero_power</table>",
        "<table purpose=\"Required to get the names of superpowers\">superpower</table>",
        "<column purpose=\"output: 'superpowers refers to power_name'\">superpower.power_name</column>",
        "<column purpose=\"join: superpower.id\">hero_power.power_id</column>",
        "<column purpose=\"join: hero_power.power_id\">superpower.id</column>",
        "<column purpose=\"filter: 'heroes with ID 1 refers to hero_id = 1'\">hero_power.hero_id</column>",
        "<output_schema purpose=\"power names are text\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'heroes with ID 1'--><table>hero_power</table>",
        "<!--Required for 'superpowers'--><table>superpower</table>",
        "<!--filter: 'heroes with ID 1'--><column>hero_power.hero_id</column>",
        "<!--join: hero_power.power_id--><column>superpower.id</column>",
        "<!--'superpowers of heroes'--><column>superpower.power_name</column>",
        "<!--superpowers of heroes with ID 1--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 765,
      "db_id": "superhero",
      "question": "How many heroes have stealth power?",
      "evidence": "stealth power refers to power_name = 'Stealth';",
      "SQL": "SELECT COUNT(T1.hero_id) FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T2.power_name = 'Stealth'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["hero_power", "superpower"],
        "columns": [
          "hero_power.hero_id",
          "hero_power.power_id",
          "superpower.id",
          "superpower.power_name"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to link heroes with their powers\">hero_power</table>",
        "<table purpose=\"Required to identify the 'Stealth' power\">superpower</table>",
        "<column purpose=\"join: superpower.id, calculate: count of heroes with stealth power\">hero_power.hero_id</column>",
        "<column purpose=\"join: superpower.id\">hero_power.power_id</column>",
        "<column purpose=\"join: hero_power.power_id\">superpower.id</column>",
        "<column purpose=\"filter: 'Stealth' power\">superpower.power_name</column>",
        "<output_schema purpose=\"count of heroes with stealth power\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'heroes have stealth power'--><table>hero_power</table>",
        "<!--Required to join hero_power with superpower--><table>superpower</table>",
        "<!--join: hero_power.power_id--><column>superpower.id</column>",
        "<!--join: superpower.id--><column>hero_power.power_id</column>",
        "<!--filter: 'stealth power'--><column>superpower.power_name</column>",
        "<!--count: 'How many heroes'--><column>hero_power.hero_id</column>",
        "<!--count of heroes with stealth power--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 766,
      "db_id": "superhero",
      "question": "What is the hero's full name with the highest attribute in strength?",
      "evidence": "highest attribute in strength refers to MAX(attribute_value) WHERE attribute_name = 'strength';",
      "SQL": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Strength' ORDER BY T2.attribute_value DESC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["superhero", "hero_attribute", "attribute"],
        "columns": [
          "superhero.full_name",
          "superhero.id",
          "hero_attribute.hero_id",
          "hero_attribute.attribute_id",
          "attribute.id",
          "attribute.attribute_name",
          "hero_attribute.attribute_value"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero information, including full name\">superhero</table>",
        "<table purpose=\"Links heroes to their attributes and values\">hero_attribute</table>",
        "<table purpose=\"Contains attribute names, needed to filter for 'Strength'\">attribute</table>",
        "<column purpose=\"Output: 'hero's full name'\">superhero.full_name</column>",
        "<column purpose=\"Join: superhero.id = hero_attribute.hero_id\">superhero.id</column>",
        "<column purpose=\"Join: superhero.id = hero_attribute.hero_id\">hero_attribute.hero_id</column>",
        "<column purpose=\"Join: hero_attribute.attribute_id = attribute.id\">hero_attribute.attribute_id</column>",
        "<column purpose=\"Join: hero_attribute.attribute_id = attribute.id\">attribute.id</column>",
        "<column purpose=\"Filter: 'attribute_name = 'strength''\">attribute.attribute_name</column>",
        "<column purpose=\"Calculate: 'highest attribute in strength'\">hero_attribute.attribute_value</column>",
        "<output_schema purpose=\"Return the hero's full name as text\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'hero's full name'--><table>superhero</table>",
        "<!--Required for 'highest attribute in strength'--><table>hero_attribute</table>",
        "<!--Required to identify 'strength' attribute--><table>attribute</table>",
        "<!--join: superhero.id--><column>hero_attribute.hero_id</column>",
        "<!--join: hero_attribute.hero_id--><column>superhero.id</column>",
        "<!--join: hero_attribute.attribute_id--><column>attribute.id</column>",
        "<!--filter: 'strength'--><column>attribute.attribute_name</column>",
        "<!--calculate: 'highest attribute in strength'--><column>hero_attribute.attribute_value</column>",
        "<!--output: 'hero's full name'--><column>superhero.full_name</column>",
        "<!--hero's full name with highest strength--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 769,
      "db_id": "superhero",
      "question": "Which superhero has the most durability published by Dark Horse Comics?",
      "evidence": "which superhero refers to superhero_name; most durability refers to MAX(attribute_value) WHERE attribute_name = 'durability'; published by Dark Horse Comics refers to publisher_name = 'Dark Horse Comics';",
      "SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T3.id = T2.attribute_id INNER JOIN publisher AS T4 ON T4.id = T1.publisher_id WHERE T4.publisher_name = 'Dark Horse Comics' AND T3.attribute_name = 'Durability' ORDER BY T2.attribute_value DESC LIMIT 1",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["superhero", "hero_attribute", "publisher", "attribute"],
        "columns": [
          "superhero.superhero_name",
          "superhero.id",
          "hero_attribute.hero_id",
          "superhero.publisher_id",
          "publisher.id",
          "publisher.publisher_name",
          "hero_attribute.attribute_id",
          "attribute.id",
          "attribute.attribute_name",
          "hero_attribute.attribute_value"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero information\">superhero</table>",
        "<table purpose=\"Links heroes to their attributes\">hero_attribute</table>",
        "<table purpose=\"Contains publisher information\">publisher</table>",
        "<table purpose=\"Contains attribute information\">attribute</table>",
        "<column purpose=\"Output: 'Which superhero'\">superhero.superhero_name</column>",
        "<column purpose=\"Join: superhero.id = hero_attribute.hero_id\">superhero.id</column>",
        "<column purpose=\"Join: superhero.id = hero_attribute.hero_id\">hero_attribute.hero_id</column>",
        "<column purpose=\"Join: superhero.publisher_id = publisher.id\">superhero.publisher_id</column>",
        "<column purpose=\"Join: superhero.publisher_id = publisher.id\">publisher.id</column>",
        "<column purpose=\"Filter: 'published by Dark Horse Comics'\">publisher.publisher_name</column>",
        "<column purpose=\"Join: hero_attribute.attribute_id = attribute.id\">hero_attribute.attribute_id</column>",
        "<column purpose=\"Join: hero_attribute.attribute_id = attribute.id\">attribute.id</column>",
        "<column purpose=\"Filter: 'durability'\">attribute.attribute_name</column>",
        "<column purpose=\"Calculate: 'most durability'\">hero_attribute.attribute_value</column>",
        "<output_schema purpose=\"superhero name (text)\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'superhero' and 'published by Dark Horse Comics'--><table>superhero</table>",
        "<!--Required for 'most durability'--><table>hero_attribute</table>",
        "<!--Required for 'durability' attribute--><table>attribute</table>",
        "<!--Required for 'published by Dark Horse Comics'--><table>publisher</table>",
        "<!--join: superhero.id--><column>hero_attribute.hero_id</column>",
        "<!--join: hero_attribute.hero_id--><column>superhero.id</column>",
        "<!--join: superhero.publisher_id--><column>publisher.id</column>",
        "<!--join: publisher.id--><column>superhero.publisher_id</column>",
        "<!--join: hero_attribute.attribute_id--><column>attribute.id</column>",
        "<!--join: attribute.id--><column>hero_attribute.attribute_id</column>",
        "<!--filter: 'durability'--><column>attribute.attribute_name</column>",
        "<!--filter: 'Dark Horse Comics'--><column>publisher.publisher_name</column>",
        "<!--calculate: 'most durability'--><column>hero_attribute.attribute_value</column>",
        "<!--output: 'Which superhero'--><column>superhero.superhero_name</column>",
        "<!--superhero name with most durability--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 772,
      "db_id": "superhero",
      "question": "List the eyes, hair and skin colour of all female superheroes published by Dark Horse Comics.",
      "evidence": "eyes refers to eye_colour_id; hair refers to hair_colour_id; skin colour refers to skin_colour_id; female superheroes refers to gender = 'Female'; published by Dark Horse Comics refers to publisher_name = 'Dark Horse Comics';",
      "SQL": "SELECT T1.eye_colour_id, T1.hair_colour_id, T1.skin_colour_id FROM superhero AS T1 INNER JOIN publisher AS T2 ON T2.id = T1.publisher_id INNER JOIN gender AS T3 ON T3.id = T1.gender_id WHERE T2.publisher_name = 'Dark Horse Comics' AND T3.gender = 'Female'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["superhero", "publisher", "gender"],
        "columns": [
          "superhero.eye_colour_id",
          "superhero.hair_colour_id",
          "superhero.skin_colour_id",
          "superhero.publisher_id",
          "publisher.id",
          "publisher.publisher_name",
          "superhero.gender_id",
          "gender.id",
          "gender.gender"
        ],
        "output_schema": ["integer", "integer", "integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero information including eye, hair, and skin color IDs\">superhero</table>",
        "<table purpose=\"Required to filter superheroes by publisher\">publisher</table>",
        "<table purpose=\"Required to filter superheroes by gender\">gender</table>",
        "<column purpose=\"output: 'eyes'\">superhero.eye_colour_id</column>",
        "<column purpose=\"output: 'hair'\">superhero.hair_colour_id</column>",
        "<column purpose=\"output: 'skin colour'\">superhero.skin_colour_id</column>",
        "<column purpose=\"join: publisher.id\">superhero.publisher_id</column>",
        "<column purpose=\"join: superhero.publisher_id\">publisher.id</column>",
        "<column purpose=\"filter: 'published by Dark Horse Comics'\">publisher.publisher_name</column>",
        "<column purpose=\"join: gender.id\">superhero.gender_id</column>",
        "<column purpose=\"join: superhero.gender_id\">gender.id</column>",
        "<column purpose=\"filter: 'female superheroes'\">gender.gender</column>",
        "<output_schema purpose=\"eye colour ID\">integer</output_schema>",
        "<output_schema purpose=\"hair colour ID\">integer</output_schema>",
        "<output_schema purpose=\"skin colour ID\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for superhero information--><table>superhero</table>",
        "<!--Required for gender information--><table>gender</table>",
        "<!--Required for publisher information--><table>publisher</table>",
        "<!--Required for color information--><table>colour</table>",
        "<!--filter: 'female superheroes'--><column>gender.gender</column>",
        "<!--join: superhero.gender_id--><column>gender.id</column>",
        "<!--join: gender.id--><column>superhero.gender_id</column>",
        "<!--filter: 'published by Dark Horse Comics'--><column>publisher.publisher_name</column>",
        "<!--join: superhero.publisher_id--><column>publisher.id</column>",
        "<!--join: publisher.id--><column>superhero.publisher_id</column>",
        "<!--'eyes' (eye_colour_id)--><column>superhero.eye_colour_id</column>",
        "<!--'hair' (hair_colour_id)--><column>superhero.hair_colour_id</column>",
        "<!--'skin colour' (skin_colour_id)--><column>superhero.skin_colour_id</column>",
        "<!--join: superhero.eye_colour_id--><column>colour.id</column>",
        "<!--output: eye colour--><column>colour.colour</column>",
        "<!--superhero name for reference--><column>superhero.superhero_name</column>",
        "<!--superhero name--><output_schema>text</output_schema>",
        "<!--eye colour--><output_schema>text</output_schema>",
        "<!--hair colour--><output_schema>text</output_schema>",
        "<!--skin colour--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 773,
      "db_id": "superhero",
      "question": "Which superhero has the same eyes, hair and skin colour? Indicate the publisher of the superhero.",
      "evidence": "which superhero refers to superhero_name; the same eyes, hair and skin colour refers to hair_colour_id = skin_colour_id AND hair_colour_id = eye_colour_id; publisher refers to publisher_name;",
      "SQL": "SELECT T1.superhero_name, T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.eye_colour_id = T1.hair_colour_id AND T1.eye_colour_id = T1.skin_colour_id",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["superhero", "publisher"],
        "columns": [
          "superhero.superhero_name",
          "publisher.publisher_name",
          "superhero.publisher_id",
          "publisher.id",
          "superhero.eye_colour_id",
          "superhero.hair_colour_id",
          "superhero.skin_colour_id"
        ],
        "output_schema": ["text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero information including name and color attributes\">superhero</table>",
        "<table purpose=\"Contains publisher information\">publisher</table>",
        "<column purpose=\"Output: 'Which superhero'\">superhero.superhero_name</column>",
        "<column purpose=\"Output: 'Indicate the publisher of the superhero'\">publisher.publisher_name</column>",
        "<column purpose=\"Join: superhero.publisher_id\">superhero.publisher_id</column>",
        "<column purpose=\"Join: publisher.id\">publisher.id</column>",
        "<column purpose=\"Filter: 'same eyes, hair and skin colour'\">superhero.eye_colour_id</column>",
        "<column purpose=\"Filter: 'same eyes, hair and skin colour'\">superhero.hair_colour_id</column>",
        "<column purpose=\"Filter: 'same eyes, hair and skin colour'\">superhero.skin_colour_id</column>",
        "<output_schema purpose=\"superhero name\">text</output_schema>",
        "<output_schema purpose=\"publisher name\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--'Which superhero' refers to superhero_name--><table>superhero</table>",
        "<!--'has the same eyes, hair and skin colour' requires comparing these columns--><column>superhero.eye_colour_id</column>",
        "<column>superhero.hair_colour_id</column>",
        "<column>superhero.skin_colour_id</column>",
        "<!--'Indicate the publisher of the superhero' requires joining with publisher table--><table>publisher</table>",
        "<!--Join superhero and publisher tables--><column>superhero.publisher_id</column>",
        "<column>publisher.id</column>",
        "<!--'publisher refers to publisher_name'--><column>publisher.publisher_name</column>",
        "<!--Output superhero name--><output_schema>text</output_schema>",
        "<!--Output publisher name--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 775,
      "db_id": "superhero",
      "question": "What is the percentage of blue female superheroes among all female superheroes?",
      "evidence": "percentage = MULTIPLY(DIVIDE(SUM(colour = 'Blue' WHERE gender = 'Female'), COUNT(gender = 'Female')), 100); blue refers to the color = 'Blue' WHERE skin_colour_id = colour.id; female refers to gender = 'Female';",
      "SQL": "SELECT CAST(COUNT(CASE WHEN T3.colour = 'Blue' THEN T1.id ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id INNER JOIN colour AS T3 ON T1.skin_colour_id = T3.id WHERE T2.gender = 'Female'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["superhero", "gender", "colour"],
        "columns": [
          "colour.colour",
          "superhero.id",
          "superhero.gender_id",
          "gender.id",
          "gender.gender",
          "superhero.skin_colour_id",
          "colour.id"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero data including gender and skin color\">superhero</table>",
        "<table purpose=\"Provides gender information for superheroes\">gender</table>",
        "<table purpose=\"Contains color information for superhero skin\">colour</table>",
        "<column purpose=\"filter: 'blue' skin color\">colour.colour</column>",
        "<column purpose=\"count: unique superheroes\">superhero.id</column>",
        "<column purpose=\"join: superhero.gender_id = gender.id\">superhero.gender_id</column>",
        "<column purpose=\"join: superhero.gender_id = gender.id\">gender.id</column>",
        "<column purpose=\"filter: 'female' superheroes\">gender.gender</column>",
        "<column purpose=\"join: superhero.skin_colour_id = colour.id\">superhero.skin_colour_id</column>",
        "<column purpose=\"join: superhero.skin_colour_id = colour.id\">colour.id</column>",
        "<output_schema purpose=\"percentage of blue female superheroes\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'female superheroes'--><table>superhero</table>",
        "<!--Required for 'female superheroes'--><table>gender</table>",
        "<!--Required for 'blue' superheroes--><table>colour</table>",
        "<!--Join: superhero.gender_id--><column>gender.id</column>",
        "<!--Filter: 'female superheroes'--><column>gender.gender</column>",
        "<!--Join: superhero.gender_id--><column>superhero.gender_id</column>",
        "<!--Join: superhero.skin_colour_id--><column>superhero.skin_colour_id</column>",
        "<!--Join: superhero.skin_colour_id--><column>colour.id</column>",
        "<!--Filter: 'blue' superheroes--><column>colour.colour</column>",
        "<!--Percentage of blue female superheroes--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 779,
      "db_id": "superhero",
      "question": "How many powers does Amazo hero have?",
      "evidence": "Amazo hero refers to superhero_name = 'Amazo';",
      "SQL": "SELECT COUNT(T1.power_id) FROM hero_power AS T1 INNER JOIN superhero AS T2 ON T1.hero_id = T2.id WHERE T2.superhero_name = 'Amazo'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["hero_power", "superhero"],
        "columns": [
          "hero_power.power_id",
          "hero_power.hero_id",
          "superhero.id",
          "superhero.superhero_name"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for counting powers\">hero_power</table>",
        "<table purpose=\"Required to filter by superhero name\">superhero</table>",
        "<column purpose=\"calculate: count of powers\">hero_power.power_id</column>",
        "<column purpose=\"join: superhero.id\">hero_power.hero_id</column>",
        "<column purpose=\"join: hero_power.hero_id\">superhero.id</column>",
        "<column purpose=\"filter: 'Amazo hero'\">superhero.superhero_name</column>",
        "<output_schema purpose=\"count of powers\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Amazo hero'--><table>superhero</table>",
        "<!--Required to count powers--><table>hero_power</table>",
        "<!--filter: 'Amazo hero'--><column>superhero.superhero_name</column>",
        "<!--join: hero_power.hero_id--><column>superhero.id</column>",
        "<!--join: superhero.id--><column>hero_power.hero_id</column>",
        "<!--count: 'How many powers'--><column>hero_power.power_id</column>",
        "<!--number of powers for Amazo--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 781,
      "db_id": "superhero",
      "question": "Provide the heights of the heroes whose eye colours are amber.",
      "evidence": "heights of the heroes refers to height_cm; eye colours are amber refers to colour.colour = 'Amber' WHERE eye_colour_id = colour.id;",
      "SQL": "SELECT T1.height_cm FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T2.colour = 'Amber'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["superhero", "colour"],
        "columns": [
          "superhero.height_cm",
          "superhero.eye_colour_id",
          "colour.id",
          "colour.colour"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains hero information including height and eye color\">superhero</table>",
        "<table purpose=\"Contains color information for eye, hair, and skin\">colour</table>",
        "<column purpose=\"calculate: 'heights of the heroes'\">superhero.height_cm</column>",
        "<column purpose=\"join: colour.id\">superhero.eye_colour_id</column>",
        "<column purpose=\"join: superhero.eye_colour_id\">colour.id</column>",
        "<column purpose=\"filter: 'eye colours are amber'\">colour.colour</column>",
        "<output_schema purpose=\"heights of the heroes\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'heights of the heroes'--><table>superhero</table>",
        "<!--Required for 'eye colours are amber'--><table>colour</table>",
        "<!--heights of the heroes--><column>superhero.height_cm</column>",
        "<!--join: superhero.eye_colour_id--><column>colour.id</column>",
        "<!--join: colour.id--><column>superhero.eye_colour_id</column>",
        "<!--filter: 'eye colours are amber'--><column>colour.colour</column>",
        "<!--heights of the heroes whose eye colours are amber--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 782,
      "db_id": "superhero",
      "question": "List the heroes' names whose eyes and hair colours are both black.",
      "evidence": "heroes' names refers to superhero_name; eyes and hair colours are both black refers to eye_colour_id AND hair_colour_id WHERE colour.colour = 'Black';",
      "SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id AND T1.hair_colour_id = T2.id WHERE T2.colour = 'Black'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["superhero", "colour"],
        "columns": [
          "superhero.superhero_name",
          "superhero.eye_colour_id",
          "colour.id",
          "superhero.hair_colour_id",
          "colour.colour"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero information including name and color IDs\">superhero</table>",
        "<table purpose=\"Contains color information for eyes and hair\">colour</table>",
        "<column purpose=\"Output: 'heroes' names'\">superhero.superhero_name</column>",
        "<column purpose=\"Join: with colour.id for eye color\">superhero.eye_colour_id</column>",
        "<column purpose=\"Join: with superhero.eye_colour_id and superhero.hair_colour_id\">colour.id</column>",
        "<column purpose=\"Join: with colour.id for hair color\">superhero.hair_colour_id</column>",
        "<column purpose=\"Filter: 'eyes and hair colours are both black'\">colour.colour</column>",
        "<output_schema purpose=\"List of superhero names\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'heroes' names'--><table>superhero</table>",
        "<!--Required for 'eyes and hair colours'--><table>colour</table>",
        "<!--'heroes' names'--><column>superhero.superhero_name</column>",
        "<!--join: colour.id for eyes--><column>superhero.eye_colour_id</column>",
        "<!--join: colour.id for hair--><column>superhero.hair_colour_id</column>",
        "<!--filter: 'eyes and hair colours are both black'--><column>colour.id</column>",
        "<!--filter: 'eyes and hair colours are both black'--><column>colour.colour</column>",
        "<!--List the heroes' names--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 785,
      "db_id": "superhero",
      "question": "Describe the names of neutral alignment superheroes.",
      "evidence": "names of superheroes refers to superhero_name; neutral alignment refers to alignment = 'Neutral';",
      "SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["superhero", "alignment"],
        "columns": [
          "superhero.superhero_name",
          "superhero.alignment_id",
          "alignment.id",
          "alignment.alignment"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero information, including names and alignment IDs\">superhero</table>",
        "<table purpose=\"Contains alignment information, needed to filter for 'Neutral' alignment\">alignment</table>",
        "<column purpose=\"output: 'names of neutral alignment superheroes'\">superhero.superhero_name</column>",
        "<column purpose=\"join: alignment.id\">superhero.alignment_id</column>",
        "<column purpose=\"join: superhero.alignment_id\">alignment.id</column>",
        "<column purpose=\"filter: 'neutral alignment'\">alignment.alignment</column>",
        "<output_schema purpose=\"superhero names are text\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'names of superheroes'--><table>superhero</table>",
        "<!--Required for 'neutral alignment'--><table>alignment</table>",
        "<!--'names of superheroes refers to superhero_name'--><column>superhero.superhero_name</column>",
        "<!--join: superhero.alignment_id--><column>alignment.id</column>",
        "<!--join: alignment.id--><column>superhero.alignment_id</column>",
        "<!--'neutral alignment refers to alignment = 'Neutral''--><column>alignment.alignment</column>",
        "<!--'Describe the names of neutral alignment superheroes'--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 786,
      "db_id": "superhero",
      "question": "How many heroes have the highest attribute value in strength?",
      "evidence": "highest attribute value in strength refers to MAX(attribute_value) WHERE attribute_name = 'Strength';",
      "SQL": "SELECT COUNT(T1.hero_id) FROM hero_attribute AS T1 INNER JOIN attribute AS T2 ON T1.attribute_id = T2.id WHERE T2.attribute_name = 'Strength' AND T1.attribute_value = ( SELECT MAX(attribute_value) FROM hero_attribute )",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["hero_attribute", "attribute"],
        "columns": [
          "hero_attribute.attribute_value",
          "hero_attribute.hero_id",
          "hero_attribute.attribute_id",
          "attribute.id",
          "attribute.attribute_name"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains hero attribute data, including strength values\">hero_attribute</table>",
        "<table purpose=\"Provides attribute names for filtering\">attribute</table>",
        "<column purpose=\"calculate: 'highest attribute value in strength', filter: MAX(attribute_value)\">hero_attribute.attribute_value</column>",
        "<column purpose=\"count: 'How many heroes'\">hero_attribute.hero_id</column>",
        "<column purpose=\"join: attribute.id\">hero_attribute.attribute_id</column>",
        "<column purpose=\"join: hero_attribute.attribute_id\">attribute.id</column>",
        "<column purpose=\"filter: 'strength'\">attribute.attribute_name</column>",
        "<output_schema purpose=\"count of heroes with highest strength\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'heroes' and 'attribute value in strength'--><table>hero_attribute</table>",
        "<!--Required for 'attribute value in strength'--><table>attribute</table>",
        "<!--Required for 'heroes'--><table>superhero</table>",
        "<!--join: hero_attribute.hero_id--><column>superhero.id</column>",
        "<!--join: hero_attribute.hero_id--><column>hero_attribute.hero_id</column>",
        "<!--join: hero_attribute.attribute_id--><column>attribute.id</column>",
        "<!--join: attribute.id--><column>hero_attribute.attribute_id</column>",
        "<!--filter: 'attribute_name = 'Strength''--><column>attribute.attribute_name</column>",
        "<!--calculate: 'highest attribute value in strength'--><column>hero_attribute.attribute_value</column>",
        "<!--count of heroes with highest strength--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 788,
      "db_id": "superhero",
      "question": "How many percent of female heroes were published by Marvel Comics?",
      "evidence": "percent = MULTIPLY(DIVIDE(SUM(gender = 'Female' WHERE publisher_name = 'Marvel Comics'), COUNT(publisher_name = 'Marvel Comics')), 100); female heroes refers to gender = 'Female'; Marvel Comics refers to publisher_name = 'Marvel Comics';",
      "SQL": "SELECT CAST(COUNT(CASE WHEN T3.gender = 'Female' AND T2.publisher_name = 'Marvel Comics' THEN 1 ELSE NULL END) AS REAL) / COUNT(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE NULL END) * 100 FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["superhero", "publisher", "gender"],
        "columns": [
          "publisher.publisher_name",
          "gender.gender",
          "superhero.publisher_id",
          "publisher.id",
          "superhero.gender_id",
          "gender.id"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for superhero information\">superhero</table>",
        "<table purpose=\"Required for publisher information\">publisher</table>",
        "<table purpose=\"Required for gender information\">gender</table>",
        "<column purpose=\"filter: 'Marvel Comics'\">publisher.publisher_name</column>",
        "<column purpose=\"filter: 'Female'\">gender.gender</column>",
        "<column purpose=\"join: publisher.id\">superhero.publisher_id</column>",
        "<column purpose=\"join: superhero.publisher_id\">publisher.id</column>",
        "<column purpose=\"join: gender.id\">superhero.gender_id</column>",
        "<column purpose=\"join: superhero.gender_id\">gender.id</column>",
        "<output_schema purpose=\"percentage of female heroes published by Marvel Comics\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'female heroes'--><table>superhero</table>",
        "<!--Required for 'gender = Female'--><table>gender</table>",
        "<!--Required for 'published by Marvel Comics'--><table>publisher</table>",
        "<!--join: superhero.gender_id--><column>gender.id</column>",
        "<!--filter: 'female heroes'--><column>gender.gender</column>",
        "<!--join: gender.id--><column>superhero.gender_id</column>",
        "<!--join: superhero.publisher_id--><column>publisher.id</column>",
        "<!--filter: 'Marvel Comics'--><column>publisher.publisher_name</column>",
        "<!--join: publisher.id--><column>superhero.publisher_id</column>",
        "<!--percent of female heroes published by Marvel Comics--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 790,
      "db_id": "superhero",
      "question": "Calculate the difference between Emil Blonsky's weight and Charles Chandler's weight.",
      "evidence": "difference = SUBTRACT(SUM(weight_kg WHERE full_name = 'Emil Blonsky'), SUM(weight_kg WHERE full_name = 'Charles Chandler')); Emil Blonsky is the full name of superhero; Charles Chandler is the full name of superhero;",
      "SQL": "SELECT ( SELECT weight_kg FROM superhero WHERE full_name LIKE 'Emil Blonsky' ) - ( SELECT weight_kg FROM superhero WHERE full_name LIKE 'Charles Chandler' ) AS CALCULATE",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["superhero"],
        "columns": ["superhero.weight_kg", "superhero.full_name"],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains the weight and full name information for superheroes\">superhero</table>",
        "<column purpose=\"calculate: difference between weights\">superhero.weight_kg</column>",
        "<column purpose=\"filter: to identify 'Emil Blonsky' and 'Charles Chandler'\">superhero.full_name</column>",
        "<output_schema purpose=\"difference between weights (in kg)\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Emil Blonsky's weight' and 'Charles Chandler's weight'--><table>superhero</table>",
        "<!--filter: 'Emil Blonsky' and 'Charles Chandler'--><column>superhero.full_name</column>",
        "<!--calculate: difference in weight--><column>superhero.weight_kg</column>",
        "<!--difference in weight between Emil Blonsky and Charles Chandler--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 791,
      "db_id": "superhero",
      "question": "Calculate the average height for all superhero.",
      "evidence": "average = DIVIDE(SUM(height_cm), COUNT(all heros));",
      "SQL": "SELECT CAST(SUM(height_cm) AS REAL) / COUNT(id) FROM superhero",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["superhero"],
        "columns": ["superhero.height_cm", "superhero.id"],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for calculating average height of superheroes\">superhero</table>",
        "<column purpose=\"calculate: sum of heights for average calculation\">superhero.height_cm</column>",
        "<column purpose=\"calculate: count of all heroes for average calculation\">superhero.id</column>",
        "<output_schema purpose=\"average height as a real number\">real</output_schema>",
        "<warning>The query includes NULL values in the average calculation, which might skew the results. Consider using COALESCE or filtering out NULL values.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'average height for all superhero'--><table>superhero</table>",
        "<!--calculate: 'SUM(height_cm)'--><column>superhero.height_cm</column>",
        "<!--calculate: 'COUNT(all heros)'--><column>superhero.id</column>",
        "<!--average height for all superhero--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 792,
      "db_id": "superhero",
      "question": "What is Abomination's superpower?",
      "evidence": "Abomination refers to superhero_name = 'Abomination'; superpower refers to power_name;",
      "SQL": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.superhero_name = 'Abomination'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["superhero", "hero_power", "superpower"],
        "columns": [
          "superpower.power_name",
          "superhero.id",
          "hero_power.hero_id",
          "hero_power.power_id",
          "superpower.id",
          "superhero.superhero_name"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to find Abomination's information\">superhero</table>",
        "<table purpose=\"Required to link superhero to superpower\">hero_power</table>",
        "<table purpose=\"Required to get superpower information\">superpower</table>",
        "<column purpose=\"output: 'Abomination's superpower'\">superpower.power_name</column>",
        "<column purpose=\"join: hero_power.hero_id\">superhero.id</column>",
        "<column purpose=\"join: superhero.id\">hero_power.hero_id</column>",
        "<column purpose=\"join: superpower.id\">hero_power.power_id</column>",
        "<column purpose=\"join: hero_power.power_id\">superpower.id</column>",
        "<column purpose=\"filter: 'Abomination refers to superhero_name = 'Abomination''\">superhero.superhero_name</column>",
        "<output_schema purpose=\"superpower name\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Abomination's superpower'--><table>superhero</table>",
        "<!--Required for 'Abomination's superpower'--><table>hero_power</table>",
        "<!--Required for 'Abomination's superpower'--><table>superpower</table>",
        "<!--filter: 'Abomination refers to superhero_name = 'Abomination''--><column>superhero.superhero_name</column>",
        "<!--join: superhero.id--><column>hero_power.hero_id</column>",
        "<!--join: hero_power.power_id--><column>superpower.id</column>",
        "<!--output: 'superpower refers to power_name'--><column>superpower.power_name</column>",
        "<!--Abomination's superpower--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 794,
      "db_id": "superhero",
      "question": "Which hero was the fastest?",
      "evidence": "which hero refers to superhero_name; fastest refers to MAX(attribute_value) WHERE attribute_name = 'Speed';",
      "SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Speed' ORDER BY T2.attribute_value DESC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["superhero", "hero_attribute", "attribute"],
        "columns": [
          "superhero.superhero_name",
          "superhero.id",
          "hero_attribute.hero_id",
          "hero_attribute.attribute_id",
          "attribute.id",
          "attribute.attribute_name",
          "hero_attribute.attribute_value"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero information, including names\">superhero</table>",
        "<table purpose=\"Links heroes to their attributes and values\">hero_attribute</table>",
        "<table purpose=\"Contains attribute names, including 'Speed'\">attribute</table>",
        "<column purpose=\"output: 'Which hero was the fastest?'\">superhero.superhero_name</column>",
        "<column purpose=\"join: hero_attribute.hero_id\">superhero.id</column>",
        "<column purpose=\"join: superhero.id\">hero_attribute.hero_id</column>",
        "<column purpose=\"join: attribute.id\">hero_attribute.attribute_id</column>",
        "<column purpose=\"join: hero_attribute.attribute_id\">attribute.id</column>",
        "<column purpose=\"filter: 'fastest refers to MAX(attribute_value) WHERE attribute_name = 'Speed''\">attribute.attribute_name</column>",
        "<column purpose=\"calculate: 'fastest refers to MAX(attribute_value)'\">hero_attribute.attribute_value</column>",
        "<output_schema purpose=\"superhero name of the fastest hero\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'hero' and 'superhero_name'--><table>superhero</table>",
        "<!--Required for 'fastest' and 'Speed' attribute--><table>hero_attribute</table>",
        "<!--Required to get 'Speed' attribute--><table>attribute</table>",
        "<!--join: superhero.id--><column>hero_attribute.hero_id</column>",
        "<!--join: hero_attribute.hero_id--><column>superhero.id</column>",
        "<!--join: hero_attribute.attribute_id--><column>attribute.id</column>",
        "<!--filter: 'Speed' attribute--><column>attribute.attribute_name</column>",
        "<!--calculate: 'fastest' (MAX speed)--><column>hero_attribute.attribute_value</column>",
        "<!--'Which hero'--><column>superhero.superhero_name</column>",
        "<!--superhero name of the fastest hero--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 796,
      "db_id": "superhero",
      "question": "State all of 3-D Man's attributes along with their values.",
      "evidence": "3-D Man is the superhero_name. attributes refers to attribute_name; values refers to attribute_value;",
      "SQL": "SELECT T3.attribute_name, T2.attribute_value FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T1.superhero_name = '3-D Man'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["superhero", "hero_attribute", "attribute"],
        "columns": [
          "attribute.attribute_name",
          "hero_attribute.attribute_value",
          "superhero.id",
          "hero_attribute.hero_id",
          "hero_attribute.attribute_id",
          "attribute.id",
          "superhero.superhero_name"
        ],
        "output_schema": ["text", "integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero information, including the name '3-D Man'\">superhero</table>",
        "<table purpose=\"Links heroes to their attributes and values\">hero_attribute</table>",
        "<table purpose=\"Contains attribute names\">attribute</table>",
        "<column purpose=\"Output: 'attributes refers to attribute_name'\">attribute.attribute_name</column>",
        "<column purpose=\"Output: 'values refers to attribute_value'\">hero_attribute.attribute_value</column>",
        "<column purpose=\"Join: superhero.id = hero_attribute.hero_id\">superhero.id</column>",
        "<column purpose=\"Join: superhero.id = hero_attribute.hero_id\">hero_attribute.hero_id</column>",
        "<column purpose=\"Join: hero_attribute.attribute_id = attribute.id\">hero_attribute.attribute_id</column>",
        "<column purpose=\"Join: hero_attribute.attribute_id = attribute.id\">attribute.id</column>",
        "<column purpose=\"Filter: '3-D Man is the superhero_name'\">superhero.superhero_name</column>",
        "<output_schema purpose=\"Output: attribute names\">text</output_schema>",
        "<output_schema purpose=\"Output: attribute values\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for '3-D Man's attributes'--><table>superhero</table>",
        "<!--Required for 'attributes'--><table>hero_attribute</table>",
        "<!--Required for 'attribute_name'--><table>attribute</table>",
        "<!--filter: '3-D Man is the superhero_name'--><column>superhero.superhero_name</column>",
        "<!--join: superhero.id--><column>hero_attribute.hero_id</column>",
        "<!--join: hero_attribute.attribute_id--><column>attribute.id</column>",
        "<!--output: 'attributes refers to attribute_name'--><column>attribute.attribute_name</column>",
        "<!--output: 'values refers to attribute_value'--><column>hero_attribute.attribute_value</column>",
        "<!--attribute names--><output_schema>text</output_schema>",
        "<!--attribute values--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 797,
      "db_id": "superhero",
      "question": "Which superheroes have blue eyes with brown hair?",
      "evidence": "which superheroes refers to superhero_name; blue eyes refers to color = 'Blue' and color.id = eye_colour_id; brown hair refers to color = 'Brown' and color.id = hair_colour_id;",
      "SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Brown'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["superhero", "colour"],
        "columns": [
          "superhero.superhero_name",
          "superhero.eye_colour_id",
          "colour.id",
          "colour.colour",
          "superhero.hair_colour_id"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero information including eye and hair color IDs\">superhero</table>",
        "<table purpose=\"Contains color information for eyes and hair\">colour</table>",
        "<column purpose=\"Output: 'Which superheroes'\">superhero.superhero_name</column>",
        "<column purpose=\"Join: with colour.id for eye color\">superhero.eye_colour_id</column>",
        "<column purpose=\"Join: with superhero.eye_colour_id and superhero.hair_colour_id\">colour.id</column>",
        "<column purpose=\"Filter: 'Blue' for eyes and 'Brown' for hair\">colour.colour</column>",
        "<column purpose=\"Join: with colour.id for hair color\">superhero.hair_colour_id</column>",
        "<output_schema purpose=\"superhero names with blue eyes and brown hair\">text</output_schema>",
        "<warning>The colour table needs to be joined twice, once for eye color and once for hair color. The current proposal doesn't clearly indicate this.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'superheroes'--><table>superhero</table>",
        "<!--Required for 'blue eyes'--><table>colour</table>",
        "<!--Required for 'brown hair'--><table>colour</table>",
        "<!--'superheroes' refers to superhero_name--><column>superhero.superhero_name</column>",
        "<!--join: superhero.eye_colour_id--><column>colour.id</column>",
        "<!--filter: 'blue eyes'--><column>colour.colour</column>",
        "<!--join: superhero.hair_colour_id--><column>colour.id</column>",
        "<!--filter: 'brown hair'--><column>colour.colour</column>",
        "<!--join: colour.id for eye color--><column>superhero.eye_colour_id</column>",
        "<!--join: colour.id for hair color--><column>superhero.hair_colour_id</column>",
        "<!--superheroes with blue eyes and brown hair--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 798,
      "db_id": "superhero",
      "question": "What is the publisher for Hawkman, Karate Kid and Speedy?",
      "evidence": "publisher refers to publisher_name; Hawkman refers to superhero_name = 'Hawkman'; Karate Kid refers to superhero_name = 'Karate Kid'; Speedy refers to superhero_name = 'Speedy';",
      "SQL": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name IN ('Hawkman', 'Karate Kid', 'Speedy')",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["superhero", "publisher"],
        "columns": [
          "publisher.publisher_name",
          "superhero.publisher_id",
          "publisher.id",
          "superhero.superhero_name"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero information including their names and publisher IDs\">superhero</table>",
        "<table purpose=\"Contains publisher information\">publisher</table>",
        "<column purpose=\"Output: 'publisher for Hawkman, Karate Kid and Speedy'\">publisher.publisher_name</column>",
        "<column purpose=\"Join: links superhero to publisher\">superhero.publisher_id</column>",
        "<column purpose=\"Join: links publisher to superhero\">publisher.id</column>",
        "<column purpose=\"Filter: to select 'Hawkman', 'Karate Kid', and 'Speedy'\">superhero.superhero_name</column>",
        "<output_schema purpose=\"Publisher names are stored as text\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'publisher for Hawkman, Karate Kid and Speedy'--><table>superhero</table>",
        "<!--Required for 'publisher_name'--><table>publisher</table>",
        "<!--Filter: 'Hawkman, Karate Kid and Speedy'--><column>superhero.superhero_name</column>",
        "<!--Join: superhero.publisher_id--><column>publisher.id</column>",
        "<!--Join: publisher.id--><column>superhero.publisher_id</column>",
        "<!--Output: 'publisher for Hawkman, Karate Kid and Speedy'--><column>publisher.publisher_name</column>",
        "<!--superhero name--><output_schema>text</output_schema>",
        "<!--publisher name for each superhero--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 800,
      "db_id": "superhero",
      "question": "Calculate the percentage of superheroes with blue eyes.",
      "evidence": "percentage = MULTIPLY(DIVIDE(SUM(superhero_name WHERE color = 'Blue'), COUNT(superhero_name)), 100.0); blue eyes refers to color = 'Blue' and color.id =  eye_colour_id = 7;",
      "SQL": "SELECT CAST(COUNT(CASE WHEN T2.colour = 'Blue' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["superhero", "colour"],
        "columns": [
          "colour.colour",
          "superhero.id",
          "superhero.eye_colour_id",
          "colour.id"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for counting superheroes and their eye colors\">superhero</table>",
        "<table purpose=\"Required for matching eye color IDs to color names\">colour</table>",
        "<column purpose=\"filter: 'blue eyes'\">colour.colour</column>",
        "<column purpose=\"calculate: total number of superheroes\">superhero.id</column>",
        "<column purpose=\"join: colour.id\">superhero.eye_colour_id</column>",
        "<column purpose=\"join: superhero.eye_colour_id\">colour.id</column>",
        "<output_schema purpose=\"percentage of superheroes with blue eyes\">real</output_schema>",
        "<warning>The proposal is missing a specific reference to 'Blue' eye color in the filter condition.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for superhero count and eye color--><table>superhero</table>",
        "<!--Required for eye color information--><table>colour</table>",
        "<!--Join superhero and colour tables--><column>superhero.eye_colour_id</column>",
        "<!--Join superhero and colour tables--><column>colour.id</column>",
        "<!--Filter for blue eyes--><column>colour.colour</column>",
        "<!--Count of superheroes--><column>superhero.superhero_name</column>",
        "<!--Percentage of superheroes with blue eyes--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 801,
      "db_id": "superhero",
      "question": "Find the ratio between male superheroes and female superheroes.",
      "evidence": "ratio = DIVIDE(SUM(gender_id = 1) / SUM(gender_id = 2)); male superheroes refers to gender = 'Female'; female superheroes refers to gender = 'Male';",
      "SQL": "SELECT CAST(COUNT(CASE WHEN T2.gender = 'Male' THEN T1.id ELSE NULL END) AS REAL) / COUNT(CASE WHEN T2.gender = 'Female' THEN T1.id ELSE NULL END) FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["superhero", "gender"],
        "columns": [
          "gender.gender",
          "superhero.id",
          "superhero.gender_id",
          "gender.id"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for superhero information\">superhero</table>",
        "<table purpose=\"Required for gender information\">gender</table>",
        "<column purpose=\"filter: 'male superheroes' and 'female superheroes'\">gender.gender</column>",
        "<column purpose=\"count: number of superheroes for each gender\">superhero.id</column>",
        "<column purpose=\"join: superhero.gender_id\">superhero.gender_id</column>",
        "<column purpose=\"join: gender.id\">gender.id</column>",
        "<output_schema purpose=\"ratio between male and female superheroes\">real</output_schema>",
        "<error>The question states that male superheroes refers to gender = 'Female' and female superheroes refers to gender = 'Male', which is incorrect and contradicts common understanding. This appears to be an error in the question.</error>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for superhero gender information--><table>superhero</table>",
        "<!--Required to map gender_id to gender text--><table>gender</table>",
        "<!--Join superhero and gender tables--><column>superhero.gender_id</column>",
        "<!--Join superhero and gender tables--><column>gender.id</column>",
        "<!--Filter for male and female superheroes--><column>gender.gender</column>",
        "<!--Count male and female superheroes--><column>superhero.id</column>",
        "<!--Ratio of male to female superheroes--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 806,
      "db_id": "superhero",
      "question": "Provide the eye colour of the superhero who has Karen Beecher-Duncan as their full name.",
      "evidence": "eye colour refers to colour.colour where eye_colour_id = colour.id; Karen Beecher-Duncan is the full name of superhero;",
      "SQL": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.full_name = 'Karen Beecher-Duncan'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["superhero", "colour"],
        "columns": [
          "colour.colour",
          "superhero.eye_colour_id",
          "colour.id",
          "superhero.full_name"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero information including full name and eye color ID\">superhero</table>",
        "<table purpose=\"Contains color information for superhero attributes\">colour</table>",
        "<column purpose=\"Output: 'eye colour of the superhero'\">colour.colour</column>",
        "<column purpose=\"Join: superhero.eye_colour_id = colour.id\">superhero.eye_colour_id</column>",
        "<column purpose=\"Join: superhero.eye_colour_id = colour.id\">colour.id</column>",
        "<column purpose=\"Filter: 'Karen Beecher-Duncan as their full name'\">superhero.full_name</column>",
        "<output_schema purpose=\"Eye colour is stored as text in the colour table\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for superhero information--><table>superhero</table>",
        "<!--Required for eye colour information--><table>colour</table>",
        "<!--Filter: 'Karen Beecher-Duncan as their full name'--><column>superhero.full_name</column>",
        "<!--Join: superhero.eye_colour_id--><column>superhero.eye_colour_id</column>",
        "<!--Join: colour.id--><column>colour.id</column>",
        "<!--Output: 'eye colour'--><column>colour.colour</column>",
        "<!--Eye colour of the superhero--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 819,
      "db_id": "superhero",
      "question": "In superheroes with missing weight data, calculate the difference between the number of superheroes with blue eyes and no eye color.",
      "evidence": "missing weight data refers to weight_kg = 0 OR T1.weight_kg = NULL; difference = SUBTRACT(SUM(colour.id = 7), SUM(colour.id = 1)); blue eyes refers to eye_colour_id WHERE colour.id = 7; no eye color refers to eye_colour_id WHERE colour.id = 1;",
      "SQL": "SELECT SUM(CASE WHEN T2.id = 7 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.id = 1 THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.weight_kg = 0 OR T1.weight_kg is NULL",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["superhero", "colour"],
        "columns": [
          "colour.id",
          "superhero.eye_colour_id",
          "superhero.weight_kg"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for superhero data, including weight and eye color\">superhero</table>",
        "<table purpose=\"Required for eye color information\">colour</table>",
        "<column purpose=\"filter: 'blue eyes' (id=7) and 'no eye color' (id=1)\">colour.id</column>",
        "<column purpose=\"join: superhero.eye_colour_id = colour.id\">superhero.eye_colour_id</column>",
        "<column purpose=\"filter: 'missing weight data'\">superhero.weight_kg</column>",
        "<output_schema purpose=\"difference between number of superheroes with blue eyes and no eye color\">integer</output_schema>",
        "<warning>The proposal is missing an explicit join condition between superhero and colour tables. This should be specified to ensure correct results.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'superheroes with missing weight data'--><table>superhero</table>",
        "<!--Required for 'blue eyes' and 'no eye color'--><table>colour</table>",
        "<!--filter: 'missing weight data'--><column>superhero.weight_kg</column>",
        "<!--join: superhero.eye_colour_id--><column>colour.id</column>",
        "<!--join: colour.id--><column>superhero.eye_colour_id</column>",
        "<!--filter: 'blue eyes' and 'no eye color'--><column>colour.colour</column>",
        "<!--calculate difference between blue eyes and no eye color--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 822,
      "db_id": "superhero",
      "question": "How many green-skinned villains are there in the superhero universe?",
      "evidence": "green-skinned refers to colour.colour = 'Green' WHERE skin_colour_id = colour.id; villains refers to alignment = 'Bad';",
      "SQL": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id INNER JOIN colour AS T3 ON T1.skin_colour_id = T3.id WHERE T2.alignment = 'Bad' AND T3.colour = 'Green'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["superhero", "alignment", "colour"],
        "columns": [
          "superhero.id",
          "superhero.alignment_id",
          "alignment.id",
          "alignment.alignment",
          "superhero.skin_colour_id",
          "colour.id",
          "colour.colour"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero data including alignment and skin color\">superhero</table>",
        "<table purpose=\"Provides alignment information for superheroes\">alignment</table>",
        "<table purpose=\"Contains color information for superhero attributes\">colour</table>",
        "<column purpose=\"join: alignment.id, filter: villains\">superhero.alignment_id</column>",
        "<column purpose=\"join: superhero.alignment_id\">alignment.id</column>",
        "<column purpose=\"filter: villains\">alignment.alignment</column>",
        "<column purpose=\"join: colour.id, filter: green-skinned\">superhero.skin_colour_id</column>",
        "<column purpose=\"join: superhero.skin_colour_id\">colour.id</column>",
        "<column purpose=\"filter: green-skinned\">colour.colour</column>",
        "<column purpose=\"calculate: count of green-skinned villains\">superhero.id</column>",
        "<output_schema purpose=\"count of green-skinned villains\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'green-skinned'--><table>superhero</table>",
        "<!--Required for 'green-skinned'--><table>colour</table>",
        "<!--Required for 'villains'--><table>alignment</table>",
        "<!--join: superhero.skin_colour_id--><column>colour.id</column>",
        "<!--filter: 'green-skinned'--><column>colour.colour</column>",
        "<!--join: superhero.skin_colour_id--><column>superhero.skin_colour_id</column>",
        "<!--join: superhero.alignment_id--><column>alignment.id</column>",
        "<!--filter: 'villains'--><column>alignment.alignment</column>",
        "<!--join: alignment.id--><column>superhero.alignment_id</column>",
        "<!--count of green-skinned villains--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 824,
      "db_id": "superhero",
      "question": "Identify superheroes who can control wind and list their names in alphabetical order.",
      "evidence": "superheroes refers to superhero_name; can control wind refers to power_name = 'Wind Control';",
      "SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Wind Control' ORDER BY T1.superhero_name",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["superhero", "hero_power", "superpower"],
        "columns": [
          "superhero.superhero_name",
          "superhero.id",
          "hero_power.hero_id",
          "hero_power.power_id",
          "superpower.id",
          "superpower.power_name"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero names and IDs\">superhero</table>",
        "<table purpose=\"Links superheroes to their powers\">hero_power</table>",
        "<table purpose=\"Contains superpower names and IDs\">superpower</table>",
        "<column purpose=\"Output: 'list their names'\">superhero.superhero_name</column>",
        "<column purpose=\"Join: superhero.id = hero_power.hero_id\">superhero.id</column>",
        "<column purpose=\"Join: superhero.id = hero_power.hero_id\">hero_power.hero_id</column>",
        "<column purpose=\"Join: hero_power.power_id = superpower.id\">hero_power.power_id</column>",
        "<column purpose=\"Join: hero_power.power_id = superpower.id\">superpower.id</column>",
        "<column purpose=\"Filter: 'can control wind refers to power_name = 'Wind Control''\">superpower.power_name</column>",
        "<output_schema purpose=\"List of superhero names\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'superheroes'--><table>superhero</table>",
        "<!--Required for 'can control wind'--><table>superpower</table>",
        "<!--Required to link superheroes and superpowers--><table>hero_power</table>",
        "<!--superhero names--><column>superhero.superhero_name</column>",
        "<!--join: superhero.id--><column>hero_power.hero_id</column>",
        "<!--join: hero_power.power_id--><column>superpower.id</column>",
        "<!--filter: 'can control wind'--><column>superpower.power_name</column>",
        "<!--list of superhero names--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 825,
      "db_id": "superhero",
      "question": "Identify the gender of the superhero who has the ability of Phoenix Force.",
      "evidence": "ability of Phoenix Force refers to power_name = 'Phoenix Force';",
      "SQL": "SELECT T4.gender FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id INNER JOIN gender AS T4 ON T1.gender_id = T4.id WHERE T3.power_name = 'Phoenix Force'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["superhero", "hero_power", "gender", "superpower"],
        "columns": [
          "gender.gender",
          "superhero.id",
          "hero_power.hero_id",
          "superhero.gender_id",
          "gender.id",
          "hero_power.power_id",
          "superpower.id",
          "superpower.power_name"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains superhero information including gender_id\">superhero</table>",
        "<table purpose=\"Links superheroes to their powers\">hero_power</table>",
        "<table purpose=\"Contains gender information\">gender</table>",
        "<table purpose=\"Contains superpower information\">superpower</table>",
        "<column purpose=\"Output: 'Identify the gender of the superhero'\">gender.gender</column>",
        "<column purpose=\"Join: superhero.id = hero_power.hero_id\">superhero.id</column>",
        "<column purpose=\"Join: superhero.id = hero_power.hero_id\">hero_power.hero_id</column>",
        "<column purpose=\"Join: superhero.gender_id = gender.id\">superhero.gender_id</column>",
        "<column purpose=\"Join: superhero.gender_id = gender.id\">gender.id</column>",
        "<column purpose=\"Join: hero_power.power_id = superpower.id\">hero_power.power_id</column>",
        "<column purpose=\"Join: hero_power.power_id = superpower.id\">superpower.id</column>",
        "<column purpose=\"Filter: 'ability of Phoenix Force refers to power_name = 'Phoenix Force''\">superpower.power_name</column>",
        "<output_schema purpose=\"Gender of the superhero with Phoenix Force ability\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for superhero information--><table>superhero</table>",
        "<!--Required for power information--><table>hero_power</table>",
        "<!--Required for power name--><table>superpower</table>",
        "<!--Required for gender information--><table>gender</table>",
        "<!--Join: superhero.id--><column>hero_power.hero_id</column>",
        "<!--Join: hero_power.hero_id--><column>superhero.id</column>",
        "<!--Join: hero_power.power_id--><column>superpower.id</column>",
        "<!--Filter: 'ability of Phoenix Force'--><column>superpower.power_name</column>",
        "<!--Join: superhero.gender_id--><column>gender.id</column>",
        "<!--Output: 'Identify the gender'--><column>gender.gender</column>",
        "<!--Gender of the superhero with Phoenix Force--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 829,
      "db_id": "superhero",
      "question": "Which publisher created more superheroes: DC or Marvel Comics? Find the difference in the number of superheroes.",
      "evidence": "DC refers to publisher_name = 'DC Comics'; Marvel Comics refers to publisher_name = 'Marvel Comics'; difference = SUBTRACT(SUM(publisher_name = 'DC Comics'), SUM(publisher_name = 'Marvel Comics'));",
      "SQL": "SELECT SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["superhero", "publisher"],
        "columns": [
          "publisher.publisher_name",
          "superhero.publisher_id",
          "publisher.id"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for counting superheroes\">superhero</table>",
        "<table purpose=\"Required for publisher names\">publisher</table>",
        "<column purpose=\"filter: 'DC Comics' and 'Marvel Comics'\">publisher.publisher_name</column>",
        "<column purpose=\"join: publisher.id\">superhero.publisher_id</column>",
        "<column purpose=\"join: superhero.publisher_id\">publisher.id</column>",
        "<output_schema purpose=\"difference in the number of superheroes\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for superhero count by publisher--><table>superhero</table>",
        "<!--Required for publisher names--><table>publisher</table>",
        "<!--Join: superhero.publisher_id--><column>publisher.id</column>",
        "<!--Join: publisher.id--><column>superhero.publisher_id</column>",
        "<!--Filter: 'DC Comics' and 'Marvel Comics'--><column>publisher.publisher_name</column>",
        "<!--Count of superheroes--><column>superhero.id</column>",
        "<!--Difference in number of superheroes--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 531,
      "db_id": "codebase_community",
      "question": "Which user has a higher reputation, Harlan or Jarrod Dixon?",
      "evidence": "\"Harlan\" and \"Jarrod Dixon\" are both DisplayName; highest reputation refers to Max(Reputation)",
      "SQL": "SELECT DisplayName FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon') AND Reputation = ( SELECT MAX(Reputation) FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon') )",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["users"],
        "columns": ["users.Reputation", "users.DisplayName"],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains user information including DisplayName and Reputation\">users</table>",
        "<column purpose=\"filter and calculate: 'higher reputation', 'highest reputation refers to Max(Reputation)'\">users.Reputation</column>",
        "<column purpose=\"filter: 'Harlan or Jarrod Dixon'\">users.DisplayName</column>",
        "<output_schema purpose=\"Return the DisplayName of the user with higher reputation\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for user information--><table>users</table>",
        "<!--Filter for \"Harlan\" and \"Jarrod Dixon\"--><column>users.DisplayName</column>",
        "<!--Compare reputation--><column>users.Reputation</column>",
        "<!--Output the higher reputation user--><output_schema>text</output_schema>",
        "<!--Output the higher reputation value--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 532,
      "db_id": "codebase_community",
      "question": "Please list the display names of all the users whose accounts were created in the year 2011.",
      "evidence": "account created in the year 2011 refers to year(CreationDate) = 2011",
      "SQL": "SELECT DisplayName FROM users WHERE STRFTIME('%Y', CreationDate) = '2011'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["users"],
        "columns": ["users.DisplayName", "users.CreationDate"],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains user information including account creation dates and display names\">users</table>",
        "<column purpose=\"Output: 'list the display names of all the users'\">users.DisplayName</column>",
        "<column purpose=\"Filter: 'accounts were created in the year 2011'\">users.CreationDate</column>",
        "<output_schema purpose=\"Display names are of text type\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for user information--><table>users</table>",
        "<!--Filter: 'accounts were created in the year 2011'--><column>users.CreationDate</column>",
        "<!--Output: 'display names of all the users'--><column>users.DisplayName</column>",
        "<!--List of display names--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 533,
      "db_id": "codebase_community",
      "question": "How many users last accessed the website after 2014/9/1?",
      "evidence": "last accessed after 2014/9/1 refers to LastAccessDate > '2014-09-01'",
      "SQL": "SELECT COUNT(Id) FROM users WHERE date(LastAccessDate) > '2014-09-01'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["users"],
        "columns": ["users.Id", "users.LastAccessDate"],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains user information including LastAccessDate\">users</table>",
        "<column purpose=\"Used for counting unique users\">users.Id</column>",
        "<column purpose=\"Filter: 'last accessed after 2014/9/1'\">users.LastAccessDate</column>",
        "<output_schema purpose=\"Count of users who last accessed after 2014/9/1\">integer</output_schema>",
        "<warning>The COUNT(*) function could be used instead of COUNT(Id) for efficiency, as Id is the primary key and cannot be null.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'users' information--><table>users</table>",
        "<!--Filter: 'last accessed after 2014/9/1'--><column>users.LastAccessDate</column>",
        "<!--Count of users meeting the criteria--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 539,
      "db_id": "codebase_community",
      "question": "Who is the owner of the post \"Eliciting priors from experts\"?",
      "evidence": "\"Eliciting priors from experts\" is the Title of post; owner refers to DisplayName",
      "SQL": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Eliciting priors from experts'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["posts", "users"],
        "columns": [
          "users.DisplayName",
          "posts.OwnerUserId",
          "users.Id",
          "posts.Title"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains the post information, including the title and owner user ID\">posts</table>",
        "<table purpose=\"Contains user information, including display name\">users</table>",
        "<column purpose=\"Output: 'owner refers to DisplayName'\">users.DisplayName</column>",
        "<column purpose=\"Join: link posts to users\">posts.OwnerUserId</column>",
        "<column purpose=\"Join: link users to posts\">users.Id</column>",
        "<column purpose=\"Filter: 'Eliciting priors from experts' is the Title of post\">posts.Title</column>",
        "<output_schema purpose=\"DisplayName is of type text\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for post information--><table>posts</table>",
        "<!--Required to get owner information--><table>users</table>",
        "<!--Filter: \"Eliciting priors from experts\"--><column>posts.Title</column>",
        "<!--Join: posts.OwnerUserId--><column>users.Id</column>",
        "<!--Join: users.Id--><column>posts.OwnerUserId</column>",
        "<!--Owner refers to DisplayName--><column>users.DisplayName</column>",
        "<!--Owner of the post--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 537,
      "db_id": "codebase_community",
      "question": "How many posts does the user csgillespie own?",
      "evidence": "\"csgillespie\" is the DisplayName of user",
      "SQL": "SELECT COUNT(T1.id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["posts", "users"],
        "columns": [
          "posts.Id",
          "posts.OwnerUserId",
          "users.Id",
          "users.DisplayName"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains post information\">posts</table>",
        "<table purpose=\"Contains user information\">users</table>",
        "<column purpose=\"join: users.Id\">posts.OwnerUserId</column>",
        "<column purpose=\"join: posts.OwnerUserId\">users.Id</column>",
        "<column purpose=\"filter: 'csgillespie' is the DisplayName of user\">users.DisplayName</column>",
        "<column purpose=\"calculate: count of posts\">posts.Id</column>",
        "<output_schema purpose=\"count of posts owned by csgillespie\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'posts' and 'user csgillespie'--><table>posts</table>",
        "<!--Required for 'user csgillespie'--><table>users</table>",
        "<!--join: users.Id--><column>posts.OwnerUserId</column>",
        "<!--join: posts.OwnerUserId--><column>users.Id</column>",
        "<!--filter: 'csgillespie'--><column>users.DisplayName</column>",
        "<!--count: 'How many posts'--><column>posts.Id</column>",
        "<!--How many posts--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 544,
      "db_id": "codebase_community",
      "question": "What is the display name of the user who last edited the post \"Examples for teaching: Correlation does not mean causation\"?",
      "evidence": "\"Examples for teaching: Correlation does not mean causation\" is the Title of post; user who last edited refers to LastEditorUserId",
      "SQL": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id WHERE T1.Title = 'Examples for teaching: Correlation does not mean causation'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["posts", "users"],
        "columns": [
          "users.DisplayName",
          "posts.LastEditorUserId",
          "users.Id",
          "posts.Title"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains the post information, including the title and last editor\">posts</table>",
        "<table purpose=\"Contains user information, including display names\">users</table>",
        "<column purpose=\"Output: display name of the user who last edited the post\">users.DisplayName</column>",
        "<column purpose=\"Join: links the post to the user who last edited it\">posts.LastEditorUserId</column>",
        "<column purpose=\"Join: matches with posts.LastEditorUserId\">users.Id</column>",
        "<column purpose=\"Filter: to find the specific post with the given title\">posts.Title</column>",
        "<output_schema purpose=\"The display name of the user is a text field\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for post title--><table>posts</table>",
        "<!--Required for user display name--><table>users</table>",
        "<!--Filter: \"Examples for teaching: Correlation does not mean causation\"--><column>posts.Title</column>",
        "<!--Join: posts.LastEditorUserId--><column>users.Id</column>",
        "<!--Join: users.Id--><column>posts.LastEditorUserId</column>",
        "<!--Output: \"display name of the user who last edited\"--><column>users.DisplayName</column>",
        "<!--Display name of the user--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 547,
      "db_id": "codebase_community",
      "question": "Among the posts owned by an elder user, how many of them have a score of over 19?",
      "evidence": "elder users refers to Age > 65; Score of over 19 refers to Score > = 20",
      "SQL": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Score >= 20 AND T2.Age > 65",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["posts", "users"],
        "columns": [
          "posts.Id",
          "posts.OwnerUserId",
          "users.Id",
          "users.Age",
          "posts.Score"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains post information, including scores and owner IDs\">posts</table>",
        "<table purpose=\"Contains user information, including age\">users</table>",
        "<column purpose=\"join: posts.OwnerUserId\">posts.Id</column>",
        "<column purpose=\"join: users.Id\">posts.OwnerUserId</column>",
        "<column purpose=\"join: posts.OwnerUserId\">users.Id</column>",
        "<column purpose=\"filter: 'elder user (Age > 65)'\">users.Age</column>",
        "<column purpose=\"filter: 'score of over 19 (Score >= 20)'\">posts.Score</column>",
        "<output_schema purpose=\"count of posts meeting the criteria\">integer</output_schema>",
        "<warning>posts.Id is not necessary for this query. The COUNT(*) function can be used instead.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'posts owned by an elder user'--><table>posts</table>",
        "<!--Required for 'posts owned by an elder user'--><table>users</table>",
        "<!--join: posts.OwnerUserId--><column>users.Id</column>",
        "<!--join: users.Id--><column>posts.OwnerUserId</column>",
        "<!--filter: 'elder user' (Age > 65)--><column>users.Age</column>",
        "<!--filter: 'score of over 19' (Score >= 20)--><column>posts.Score</column>",
        "<!--count of posts meeting criteria--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 549,
      "db_id": "codebase_community",
      "question": "From which post is the tag \"bayesian\" excerpted from? Please give the body of the post.",
      "evidence": "\"bayesian\" is the TagName; excerpt from refers to ExcerptPostId",
      "SQL": "SELECT T2.Body FROM tags AS T1 INNER JOIN posts AS T2 ON T2.Id = T1.ExcerptPostId WHERE T1.TagName = 'bayesian'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["tags", "posts"],
        "columns": [
          "posts.Body",
          "tags.ExcerptPostId",
          "posts.Id",
          "tags.TagName"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to find the 'bayesian' tag\">tags</table>",
        "<table purpose=\"Required to get the body of the post\">posts</table>",
        "<column purpose=\"output: 'body of the post'\">posts.Body</column>",
        "<column purpose=\"join: posts.Id\">tags.ExcerptPostId</column>",
        "<column purpose=\"join: tags.ExcerptPostId\">posts.Id</column>",
        "<column purpose=\"filter: 'bayesian' tag\">tags.TagName</column>",
        "<output_schema purpose=\"body of the post\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'tag \"bayesian\"'--><table>tags</table>",
        "<!--Required for post body--><table>posts</table>",
        "<!--Filter: 'tag \"bayesian\"'--><column>tags.TagName</column>",
        "<!--Join: tags.ExcerptPostId--><column>tags.ExcerptPostId</column>",
        "<!--Join: posts.Id--><column>posts.Id</column>",
        "<!--Output: 'body of the post'--><column>posts.Body</column>",
        "<!--Body of the post--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 555,
      "db_id": "codebase_community",
      "question": "What is the average score of the posts owned by the user csgillespie?",
      "evidence": "\"csgillespie\" is the DisplayName of user; average score refers to AVG(Score)",
      "SQL": "SELECT AVG(T1.Score) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["posts", "users"],
        "columns": [
          "posts.Score",
          "posts.OwnerUserId",
          "users.Id",
          "users.DisplayName"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains post information including scores\">posts</table>",
        "<table purpose=\"Contains user information including display names\">users</table>",
        "<column purpose=\"calculate: 'average score of the posts'\">posts.Score</column>",
        "<column purpose=\"join: users.Id\">posts.OwnerUserId</column>",
        "<column purpose=\"join: posts.OwnerUserId\">users.Id</column>",
        "<column purpose=\"filter: 'owned by the user csgillespie'\">users.DisplayName</column>",
        "<output_schema purpose=\"average score of the posts\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'posts owned by the user'--><table>posts</table>",
        "<!--Required to find the user 'csgillespie'--><table>users</table>",
        "<!--join: users.Id--><column>posts.OwnerUserId</column>",
        "<!--join: posts.OwnerUserId--><column>users.Id</column>",
        "<!--filter: 'csgillespie'--><column>users.DisplayName</column>",
        "<!--calculate: 'average score'--><column>posts.Score</column>",
        "<!--average score of posts--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 557,
      "db_id": "codebase_community",
      "question": "Among the posts with a score of over 5, what is the percentage of them being owned by an elder user?",
      "evidence": "score of over 5 refers to Score > 5; elder user refers to Age > 65; percentage = Divide (Count(Id where Age>65), Count(Id)) * 100",
      "SQL": "SELECT CAST(SUM(IIF(T2.Age > 65, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Score > 5",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["posts", "users"],
        "columns": [
          "users.Age",
          "posts.Id",
          "posts.OwnerUserId",
          "users.Id",
          "posts.Score"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for post information and filtering by score\">posts</table>",
        "<table purpose=\"Required for user age information\">users</table>",
        "<column purpose=\"filter: 'elder user refers to Age > 65'\">users.Age</column>",
        "<column purpose=\"calculate: count of posts for percentage calculation\">posts.Id</column>",
        "<column purpose=\"join: posts.OwnerUserId\">posts.OwnerUserId</column>",
        "<column purpose=\"join: users.Id\">users.Id</column>",
        "<column purpose=\"filter: 'score of over 5 refers to Score > 5'\">posts.Score</column>",
        "<output_schema purpose=\"percentage calculation result\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'posts with a score of over 5'--><table>posts</table>",
        "<!--Required for 'owned by an elder user'--><table>users</table>",
        "<!--filter: 'score of over 5'--><column>posts.Score</column>",
        "<!--join: users.Id--><column>posts.OwnerUserId</column>",
        "<!--join: posts.OwnerUserId--><column>users.Id</column>",
        "<!--filter: 'elder user'--><column>users.Age</column>",
        "<!--count posts--><column>posts.Id</column>",
        "<!--percentage of posts owned by elder users--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 563,
      "db_id": "codebase_community",
      "question": "User No.3025 gave a comment at 20:29:39 on 2014/4/23 to a post, how many favorite counts did that post get?",
      "evidence": "user no. 3025 refers to UserId = '3025'; comment at 20:29:39 on 2014/4/23 refers to CreationDate = '2014/4/23 20:29:39.0'",
      "SQL": "SELECT T1.FavoriteCount FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T2.CreationDate = '2014-04-23 20:29:39.0' AND T2.UserId = 3025",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["posts", "comments"],
        "columns": [
          "posts.FavoriteCount",
          "posts.Id",
          "comments.PostId",
          "comments.CreationDate",
          "comments.UserId"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to get the favorite count of the post\">posts</table>",
        "<table purpose=\"Required to find the specific comment by User No.3025\">comments</table>",
        "<column purpose=\"calculate: 'how many favorite counts did that post get?'\">posts.FavoriteCount</column>",
        "<column purpose=\"join: comments.PostId\">posts.Id</column>",
        "<column purpose=\"join: posts.Id\">comments.PostId</column>",
        "<column purpose=\"filter: 'comment at 20:29:39 on 2014/4/23'\">comments.CreationDate</column>",
        "<column purpose=\"filter: 'User No.3025'\">comments.UserId</column>",
        "<output_schema purpose=\"favorite count of the post\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for user comment information--><table>comments</table>",
        "<!--Required for post favorite count--><table>posts</table>",
        "<!--Filter: \"User No.3025\"--><column>comments.UserId</column>",
        "<!--Filter: \"at 20:29:39 on 2014/4/23\"--><column>comments.CreationDate</column>",
        "<!--Join: comments.PostId--><column>posts.Id</column>",
        "<!--Join: posts.Id--><column>comments.PostId</column>",
        "<!--Output: \"how many favorite counts did that post get?\"--><column>posts.FavoriteCount</column>",
        "<!--Favorite count of the post--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 565,
      "db_id": "codebase_community",
      "question": "User No.23853 gave a comment to a post at 9:08:18 on 2013/7/12, was that post well-finished?",
      "evidence": "user no. 23853 refers to UserId = '23853'; at 9:08:18 on 2013/7/12 refers to CreationDate = '2013-07-12 09:08:18.0'; not well-finished refers to ClosedDate IS NULL and vice versa",
      "SQL": "SELECT IIF(T2.ClosedDate IS NULL, 'NOT well-finished', 'well-finished') AS resylt FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.UserId = 23853 AND T1.CreationDate = '2013-07-12 09:08:18.0'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["comments", "posts"],
        "columns": [
          "posts.ClosedDate",
          "comments.PostId",
          "posts.Id",
          "comments.CreationDate",
          "comments.UserId"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains comment information for the specified user and date\">comments</table>",
        "<table purpose=\"Contains post information to determine if the post is well-finished\">posts</table>",
        "<column purpose=\"Determine if the post is well-finished\">posts.ClosedDate</column>",
        "<column purpose=\"Join: link comments to posts\">comments.PostId</column>",
        "<column purpose=\"Join: link posts to comments\">posts.Id</column>",
        "<column purpose=\"Filter: specify the exact date and time of the comment\">comments.CreationDate</column>",
        "<column purpose=\"Filter: specify the user who made the comment\">comments.UserId</column>",
        "<output_schema purpose=\"Return whether the post is well-finished or not\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for user comment information--><table>comments</table>",
        "<!--Required for post information--><table>posts</table>",
        "<!--Filter: \"User No.23853\"--><column>comments.UserId</column>",
        "<!--Filter: \"at 9:08:18 on 2013/7/12\"--><column>comments.CreationDate</column>",
        "<!--Join: comments.PostId--><column>posts.Id</column>",
        "<!--Check: \"was that post well-finished?\"--><column>posts.ClosedDate</column>",
        "<!--Answer: whether the post was well-finished--><output_schema>boolean</output_schema>"
      ]
    },
    {
      "question_id": 567,
      "db_id": "codebase_community",
      "question": "For the user with the display name of \"Tiago Pasqualini\", how many posts did he/she own?",
      "evidence": "\"Tiago Pasqualini\" is the DisplayName;",
      "SQL": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.DisplayName = 'Tiago Pasqualini'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["users", "posts"],
        "columns": ["users.Id", "posts.OwnerUserId", "users.DisplayName"],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to get user information\">users</table>",
        "<table purpose=\"Required to count posts owned by the user\">posts</table>",
        "<column purpose=\"join: posts.OwnerUserId\">users.Id</column>",
        "<column purpose=\"join: users.Id\">posts.OwnerUserId</column>",
        "<column purpose=\"filter: 'Tiago Pasqualini'\">users.DisplayName</column>",
        "<column purpose=\"calculate: count of posts\">posts.Id</column>",
        "<output_schema purpose=\"count of posts owned by Tiago Pasqualini\">integer</output_schema>",
        "<error>The proposal is missing posts.Id column, which is necessary for counting the number of posts</error>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for user information--><table>users</table>",
        "<!--Required for post ownership information--><table>posts</table>",
        "<!--Filter: 'with the display name of \"Tiago Pasqualini\"'--><column>users.DisplayName</column>",
        "<!--Join: users.Id--><column>users.Id</column>",
        "<!--Join: posts.OwnerUserId--><column>posts.OwnerUserId</column>",
        "<!--Count: 'how many posts did he/she own?'--><column>posts.Id</column>",
        "<!--Number of posts owned by \"Tiago Pasqualini\"--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 568,
      "db_id": "codebase_community",
      "question": "Provide the display name of the user who made the vote No.6347.",
      "evidence": "vote no. 6347 refers to Id = '6347'",
      "SQL": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.UserId WHERE T2.Id = 6347",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["users", "votes"],
        "columns": ["users.DisplayName", "users.Id", "votes.UserId", "votes.Id"],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains user information, including display name\">users</table>",
        "<table purpose=\"Contains vote information, including vote ID\">votes</table>",
        "<column purpose=\"Output: display name of the user who made the vote\">users.DisplayName</column>",
        "<column purpose=\"Join: to connect users with votes\">users.Id</column>",
        "<column purpose=\"Join: to connect votes with users\">votes.UserId</column>",
        "<column purpose=\"Filter: to identify the specific vote (No. 6347)\">votes.Id</column>",
        "<output_schema purpose=\"Display name of the user is a text field\">text</output_schema>",
        "<warning>The join between users and votes might not return a result for all votes. The votes.UserId column is 91.2% null, which means many votes don't have an associated user.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for finding the vote--><table>votes</table>",
        "<!--Required for getting user information--><table>users</table>",
        "<!--Filter for vote No.6347--><column>votes.Id</column>",
        "<!--Join votes with users--><column>votes.UserId</column>",
        "<!--Join votes with users--><column>users.Id</column>",
        "<!--Display name of the user--><column>users.DisplayName</column>",
        "<!--Display name of the user who made the vote--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 571,
      "db_id": "codebase_community",
      "question": "For the user No.24, how many times is the number of his/her posts compared to his/her votes?",
      "evidence": "user no. 24 refers to UserId = OwnerUserId = '24'; times of his/her post than votes = Divide (Count(post.Id), Count(votes.Id))",
      "SQL": "SELECT CAST(COUNT(DISTINCT T2.Id) AS REAL) / COUNT(DISTINCT T1.Id) FROM votes AS T1 INNER JOIN posts AS T2 ON T1.UserId = T2.OwnerUserId WHERE T1.UserId = 24",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["votes", "posts"],
        "columns": ["posts.Id", "votes.Id", "votes.UserId", "posts.OwnerUserId"],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for counting user's votes\">votes</table>",
        "<table purpose=\"Required for counting user's posts\">posts</table>",
        "<column purpose=\"calculate: count of user's posts\">posts.Id</column>",
        "<column purpose=\"calculate: count of user's votes\">votes.Id</column>",
        "<column purpose=\"filter: 'user No.24', join: posts.OwnerUserId\">votes.UserId</column>",
        "<column purpose=\"filter: 'user No.24', join: votes.UserId\">posts.OwnerUserId</column>",
        "<output_schema purpose=\"ratio of posts to votes\">real</output_schema>",
        "<warning>The SQL query uses INNER JOIN, which may exclude posts or votes if there's no match. Consider using LEFT JOINs to ensure all posts and votes are counted.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for user's posts--><table>posts</table>",
        "<!--Required for user's votes--><table>votes</table>",
        "<!--Filter for user No.24--><column>posts.OwnerUserId</column>",
        "<!--Count user's posts--><column>posts.Id</column>",
        "<!--Filter for user No.24--><column>votes.UserId</column>",
        "<!--Count user's votes--><column>votes.Id</column>",
        "<!--Ratio of posts to votes--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 572,
      "db_id": "codebase_community",
      "question": "How many views did the post titled 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer' get?",
      "evidence": "\"Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer\" is the Title of post; views refers to ViewCount",
      "SQL": "SELECT ViewCount FROM posts WHERE Title = 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["posts"],
        "columns": ["posts.ViewCount", "posts.Title"],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains the post information including title and view count\">posts</table>",
        "<column purpose=\"filter: 'titled Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer'\">posts.Title</column>",
        "<column purpose=\"calculate: 'How many views'\">posts.ViewCount</column>",
        "<output_schema purpose=\"Number of views for the specified post\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for post information--><table>posts</table>",
        "<!--Filter: 'titled \"Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer\"'--><column>posts.Title</column>",
        "<!--Retrieve: 'How many views'--><column>posts.ViewCount</column>",
        "<!--Number of views for the specific post--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 573,
      "db_id": "codebase_community",
      "question": "Write the contents of comments with a score of 17.",
      "evidence": "score of 17 refers to Score = 17; contents of comments refers to Text",
      "SQL": "SELECT Text FROM comments WHERE Score = 17",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["comments"],
        "columns": ["comments.Text", "comments.Score"],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'contents of comments'\">comments</table>",
        "<column purpose=\"output: 'contents of comments refers to Text'\">comments.Text</column>",
        "<column purpose=\"filter: 'score of 17 refers to Score = 17'\">comments.Score</column>",
        "<output_schema purpose=\"contents of comments (Text column)\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'contents of comments'--><table>comments</table>",
        "<!--filter: 'with a score of 17'--><column>comments.Score</column>",
        "<!--'contents of comments refers to Text'--><column>comments.Text</column>",
        "<!--contents of comments--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 576,
      "db_id": "codebase_community",
      "question": "Name the user that commented 'thank you user93!'",
      "evidence": "\"thank you user93\" is the Text of comment; user refers to DisplayName",
      "SQL": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.UserId WHERE T2.Text = 'thank you user93!'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["users", "comments"],
        "columns": [
          "users.DisplayName",
          "users.Id",
          "comments.UserId",
          "comments.Text"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to get user information\">users</table>",
        "<table purpose=\"Required to find the specific comment\">comments</table>",
        "<column purpose=\"output: 'Name the user'\">users.DisplayName</column>",
        "<column purpose=\"join: comments.UserId\">users.Id</column>",
        "<column purpose=\"join: users.Id\">comments.UserId</column>",
        "<column purpose=\"filter: 'thank you user93!'\">comments.Text</column>",
        "<output_schema purpose=\"user's display name\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for comment text--><table>comments</table>",
        "<!--Required to get user name--><table>users</table>",
        "<!--Filter: 'thank you user93!'--><column>comments.Text</column>",
        "<!--Join: comments.UserId--><column>users.Id</column>",
        "<!--Join: users.Id--><column>comments.UserId</column>",
        "<!--Output: 'Name the user'--><column>users.DisplayName</column>",
        "<!--Name of the user--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 578,
      "db_id": "codebase_community",
      "question": "Which user made a post titled 'Understanding what Dassault iSight is doing?' and how much is the reputation of the user?",
      "evidence": "\"Understanding what Dassault iSight is doing?\" is the Title of post; user refers to DisplayName;",
      "SQL": "SELECT T1.DisplayName, T1.Reputation FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.Title = 'Understanding what Dassault iSight is doing?'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["users", "posts"],
        "columns": [
          "users.DisplayName",
          "users.Reputation",
          "users.Id",
          "posts.OwnerUserId",
          "posts.Title"
        ],
        "output_schema": ["text", "integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains user information including DisplayName and Reputation\">users</table>",
        "<table purpose=\"Contains post information including Title and OwnerUserId\">posts</table>",
        "<column purpose=\"Output: 'Which user made a post'\">users.DisplayName</column>",
        "<column purpose=\"Output: 'how much is the reputation of the user'\">users.Reputation</column>",
        "<column purpose=\"Join: users.Id = posts.OwnerUserId\">users.Id</column>",
        "<column purpose=\"Join: users.Id = posts.OwnerUserId\">posts.OwnerUserId</column>",
        "<column purpose=\"Filter: 'Understanding what Dassault iSight is doing?'\">posts.Title</column>",
        "<output_schema purpose=\"DisplayName of the user who made the post\">text</output_schema>",
        "<output_schema purpose=\"Reputation of the user who made the post\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for post title and user information--><table>posts</table>",
        "<!--Required for user reputation--><table>users</table>",
        "<!--Filter: 'titled \"Understanding what Dassault iSight is doing?\"'--><column>posts.Title</column>",
        "<!--Join: posts.OwnerUserId--><column>posts.OwnerUserId</column>",
        "<!--Join: users.Id--><column>users.Id</column>",
        "<!--Output: 'Which user made a post'--><column>users.DisplayName</column>",
        "<!--Output: 'how much is the reputation of the user'--><column>users.Reputation</column>",
        "<!--User who made the post--><output_schema>text</output_schema>",
        "<!--Reputation of the user--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 581,
      "db_id": "codebase_community",
      "question": "Who is the owner of the post titled 'Open source tools for visualizing multi-dimensional data?'",
      "evidence": "'Open source tools for visualizing multi-dimensional data' is the Title of Post; owner refers to DisplayName;",
      "SQL": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Open source tools for visualizing multi-dimensional data?'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["posts", "users"],
        "columns": [
          "users.DisplayName",
          "posts.OwnerUserId",
          "users.Id",
          "posts.Title"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains the post information, including the title and owner user ID\">posts</table>",
        "<table purpose=\"Contains user information, including display name\">users</table>",
        "<column purpose=\"output: 'owner refers to DisplayName'\">users.DisplayName</column>",
        "<column purpose=\"join: link posts to users\">posts.OwnerUserId</column>",
        "<column purpose=\"join: link users to posts\">users.Id</column>",
        "<column purpose=\"filter: 'post titled Open source tools for visualizing multi-dimensional data?'\">posts.Title</column>",
        "<output_schema purpose=\"DisplayName of the owner\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'post titled'--><table>posts</table>",
        "<!--Required for 'owner'--><table>users</table>",
        "<!--filter: 'titled \"Open source tools for visualizing multi-dimensional data?\"'--><column>posts.Title</column>",
        "<!--join: posts.OwnerUserId--><column>posts.OwnerUserId</column>",
        "<!--join: users.Id--><column>users.Id</column>",
        "<!--'owner refers to DisplayName'--><column>users.DisplayName</column>",
        "<!--owner of the post--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 584,
      "db_id": "codebase_community",
      "question": "Write all the comments left by users who edited the post titled 'Why square the difference instead of taking the absolute value in standard deviation?'",
      "evidence": "\"Why square the difference instead of taking the absolute value in standard deviation?\" is the Title of post;",
      "SQL": "SELECT T2.Comment FROM posts AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.PostId WHERE T1.Title = 'Why square the difference instead of taking the absolute value in standard deviation?'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["posts", "postHistory"],
        "columns": [
          "postHistory.Comment",
          "posts.Id",
          "postHistory.PostId",
          "posts.Title"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to find the post with the specified title\">posts</table>",
        "<table purpose=\"Required to get the comments from post history\">postHistory</table>",
        "<column purpose=\"output: 'Write all the comments'\">postHistory.Comment</column>",
        "<column purpose=\"join: postHistory.PostId\">posts.Id</column>",
        "<column purpose=\"join: posts.Id\">postHistory.PostId</column>",
        "<column purpose=\"filter: 'post titled 'Why square the difference instead of taking the absolute value in standard deviation?''\">posts.Title</column>",
        "<output_schema purpose=\"comments left by users\">text</output_schema>",
        "<error>The proposal is missing postHistory.UserId column to filter for users who edited the post</error>",
        "<error>The proposal is missing a join with the users table to ensure we're only getting comments from actual users (not system edits)</error>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for post title--><table>posts</table>",
        "<!--Required for comments--><table>comments</table>",
        "<!--Required for post history (edits)--><table>postHistory</table>",
        "<!--Filter: 'titled \"Why square the difference instead of taking the absolute value in standard deviation?\"'--><column>posts.Title</column>",
        "<!--Join: posts.Id--><column>comments.PostId</column>",
        "<!--Join: posts.Id--><column>postHistory.PostId</column>",
        "<!--Identify users who edited the post--><column>postHistory.UserId</column>",
        "<!--Join: postHistory.UserId--><column>comments.UserId</column>",
        "<!--Output: comments left by users--><column>comments.Text</column>",
        "<!--Output: comment text--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 586,
      "db_id": "codebase_community",
      "question": "Which user added a bounty amount of 50 to the post title mentioning variance?",
      "evidence": "bounty amount of 50 refers to BountyAmount = 50; user refers to DisplayName; title mentioning variance refers to Title include 'variance'",
      "SQL": "SELECT T3.DisplayName, T1.Title FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId INNER JOIN users AS T3 ON T3.Id = T2.UserId WHERE T2.BountyAmount = 50 AND T1.Title LIKE '%variance%'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["posts", "votes", "users"],
        "columns": [
          "users.DisplayName",
          "posts.Title",
          "posts.Id",
          "votes.PostId",
          "votes.BountyAmount",
          "votes.UserId",
          "users.Id"
        ],
        "output_schema": ["text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains post information, including titles\">posts</table>",
        "<table purpose=\"Contains vote information, including bounty amounts\">votes</table>",
        "<table purpose=\"Contains user information, including display names\">users</table>",
        "<column purpose=\"Output: user who added the bounty\">users.DisplayName</column>",
        "<column purpose=\"Filter: title mentioning variance; Output: post title\">posts.Title</column>",
        "<column purpose=\"Join: posts.Id with votes.PostId\">posts.Id</column>",
        "<column purpose=\"Join: votes.PostId with posts.Id\">votes.PostId</column>",
        "<column purpose=\"Filter: bounty amount of 50\">votes.BountyAmount</column>",
        "<column purpose=\"Join: votes.UserId with users.Id\">votes.UserId</column>",
        "<column purpose=\"Join: users.Id with votes.UserId\">users.Id</column>",
        "<output_schema purpose=\"User's display name\">text</output_schema>",
        "<output_schema purpose=\"Post title\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'bounty amount of 50'--><table>votes</table>",
        "<!--Required for 'user' and 'DisplayName'--><table>users</table>",
        "<!--Required for 'post title mentioning variance'--><table>posts</table>",
        "<!--filter: 'bounty amount of 50'--><column>votes.BountyAmount</column>",
        "<!--join: votes.PostId--><column>posts.Id</column>",
        "<!--join: votes.UserId--><column>users.Id</column>",
        "<!--filter: 'title mentioning variance'--><column>posts.Title</column>",
        "<!--output: 'Which user'--><column>users.DisplayName</column>",
        "<!--user who added bounty--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 587,
      "db_id": "codebase_community",
      "question": "Calculate the average view count of each post tagged as 'humor' and list the title and the comment of each post.",
      "evidence": "tagged as  'humor' refers to tag = '<humor>'; comment of the post refers to Text; average view count = AVG(ViewCount)",
      "SQL": "SELECT AVG(T2.ViewCount), T2.Title, T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T2.Id = T1.PostId  WHERE T2.Tags = '<humor>' GROUP BY T2.Title, T1.Text ",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["comments", "posts"],
        "columns": [
          "posts.ViewCount",
          "posts.Title",
          "comments.Text",
          "comments.PostId",
          "posts.Id",
          "posts.Tags"
        ],
        "output_schema": ["real", "text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for comment data\">comments</table>",
        "<table purpose=\"Required for post data including view count, title, and tags\">posts</table>",
        "<column purpose=\"calculate: 'average view count'\">posts.ViewCount</column>",
        "<column purpose=\"output: 'list the title'\">posts.Title</column>",
        "<column purpose=\"output: 'comment of each post'\">comments.Text</column>",
        "<column purpose=\"join: posts.Id\">comments.PostId</column>",
        "<column purpose=\"join: comments.PostId\">posts.Id</column>",
        "<column purpose=\"filter: 'tagged as humor'\">posts.Tags</column>",
        "<output_schema purpose=\"average view count\">real</output_schema>",
        "<output_schema purpose=\"title of the post\">text</output_schema>",
        "<output_schema purpose=\"comment of the post\">text</output_schema>",
        "<warning>The proposed SQL query may not correctly calculate the average view count per post. It's grouping by both title and comment text, which could lead to multiple rows per post if a post has multiple comments. Consider using a subquery or CTE to calculate the average view count per post first, then joining with comments.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'post tagged as humor'--><table>posts</table>",
        "<!--Required for 'average view count'--><column>posts.ViewCount</column>",
        "<!--Required for 'tagged as humor'--><column>posts.Tags</column>",
        "<!--Required for 'list the title'--><column>posts.Title</column>",
        "<!--Required for 'comment of the post'--><table>comments</table>",
        "<!--Join posts and comments--><column>posts.Id</column>",
        "<!--Join posts and comments--><column>comments.PostId</column>",
        "<!--Required for 'comment of the post'--><column>comments.Text</column>",
        "<!--Average view count--><output_schema>real</output_schema>",
        "<!--Title of the post--><output_schema>text</output_schema>",
        "<!--Comment of the post--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 592,
      "db_id": "codebase_community",
      "question": "How many users are awarded with more than 5 badges?",
      "evidence": "more than 5 badges refers to Count (Name) > 5; user refers to UserId",
      "SQL": "SELECT COUNT(UserId) FROM ( SELECT UserId, COUNT(Name) AS num FROM badges GROUP BY UserId ) T WHERE T.num > 5",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["badges"],
        "columns": ["badges.UserId", "badges.Name"],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for counting badges per user\">badges</table>",
        "<column purpose=\"join: group by user, calculate: count distinct users\">badges.UserId</column>",
        "<column purpose=\"filter: 'more than 5 badges'\">badges.Name</column>",
        "<output_schema purpose=\"count of users with more than 5 badges\">integer</output_schema>",
        "<warning>The proposal is missing an explicit COUNT or aggregation function, which is needed to count the number of users. However, this might be intentionally left for the SQL implementation.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'users are awarded with badges'--><table>badges</table>",
        "<!--Required to count badges per user--><column>badges.UserId</column>",
        "<!--Required to count badges per user--><column>badges.Name</column>",
        "<!--Count of users with more than 5 badges--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 595,
      "db_id": "codebase_community",
      "question": "Which user have only one post history per post and having at least 1000 views?",
      "evidence": "having at least 1000 view refers to Views > = 1000; user refers to UserId",
      "SQL": "SELECT T2.UserId FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T3.ViewCount >= 1000 GROUP BY T2.UserId HAVING COUNT(DISTINCT T2.PostHistoryTypeId) = 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["users", "postHistory", "posts"],
        "columns": [
          "postHistory.UserId",
          "users.Id",
          "postHistory.PostId",
          "posts.Id",
          "posts.ViewCount",
          "postHistory.PostHistoryTypeId"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for user information\">users</table>",
        "<table purpose=\"Required for post history information\">postHistory</table>",
        "<table purpose=\"Required for post view count\">posts</table>",
        "<column purpose=\"join: users.Id, filter: 'user have only one post history per post'\">postHistory.UserId</column>",
        "<column purpose=\"join: postHistory.UserId\">users.Id</column>",
        "<column purpose=\"join: posts.Id\">postHistory.PostId</column>",
        "<column purpose=\"join: postHistory.PostId\">posts.Id</column>",
        "<column purpose=\"filter: 'having at least 1000 views'\">posts.ViewCount</column>",
        "<column purpose=\"filter: 'only one post history per post'\">postHistory.PostHistoryTypeId</column>",
        "<output_schema purpose=\"Return user IDs\">integer</output_schema>",
        "<warning>The proposed SQL query uses GROUP BY and HAVING clauses, which are not explicitly mentioned in the table and column list. These are important for the \"only one post history per post\" condition.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'post history per post'--><table>postHistory</table>",
        "<!--Required for 'views'--><table>posts</table>",
        "<!--Required for 'user'--><table>users</table>",
        "<!--join: posts.Id--><column>postHistory.PostId</column>",
        "<!--join: postHistory.PostId--><column>posts.Id</column>",
        "<!--filter: 'having at least 1000 views'--><column>posts.ViewCount</column>",
        "<!--group by: 'per post'--><column>postHistory.PostId</column>",
        "<!--count: 'only one post history'--><column>postHistory.Id</column>",
        "<!--join: users.Id--><column>postHistory.UserId</column>",
        "<!--join: postHistory.UserId--><column>users.Id</column>",
        "<!--output: 'Which user'--><column>users.Id</column>",
        "<!--user with one post history per post and at least 1000 views--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 598,
      "db_id": "codebase_community",
      "question": "What is the percentage difference of student badges given during 2010 and 2011?",
      "evidence": "student badges refers to badge's name = 'Student'; during 2010 refers to Year(Date) = 2010; during 2011 refers to Year(Date) = 2011; percentage difference = Subtract (Divide(Count(Name where Year(Date) = 2010), Count (Name)) *100, Divide(Count(Name where Year(Date) = 2011), Count(Name)) * 100)",
      "SQL": "SELECT CAST(SUM(IIF(STRFTIME('%Y', Date) = '2010', 1, 0)) AS REAL) * 100 / COUNT(Id) - CAST(SUM(IIF(STRFTIME('%Y', Date) = '2011', 1, 0)) AS REAL) * 100 / COUNT(Id) FROM badges WHERE Name = 'Student'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["badges"],
        "columns": ["badges.Date", "badges.Id", "badges.Name"],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for counting 'Student' badges and filtering by year\">badges</table>",
        "<column purpose=\"filter: 'during 2010' and 'during 2011'\">badges.Date</column>",
        "<column purpose=\"calculate: total count of badges for percentage calculation\">badges.Id</column>",
        "<column purpose=\"filter: 'student badges'\">badges.Name</column>",
        "<output_schema purpose=\"percentage difference calculation result\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'student badges'--><table>badges</table>",
        "<!--Filter: 'student badges'--><column>badges.Name</column>",
        "<!--Filter: 'during 2010 and 2011'--><column>badges.Date</column>",
        "<!--Calculate: 'Count(Name)'--><column>badges.Name</column>",
        "<!--Percentage difference of student badges given during 2010 and 2011--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 604,
      "db_id": "codebase_community",
      "question": "What is the average of the up votes and the average user age for users creating more than 10 posts?",
      "evidence": "creating more than 10 post refers to Count (UserId) > 10; average of the up votes = Divide (Sum(UpVotes), Count (UserId)); average age = Divide (Sum(Age), Count(UserId))",
      "SQL": "SELECT AVG(T1.UpVotes), AVG(T1.Age) FROM users AS T1 INNER JOIN ( SELECT OwnerUserId, COUNT(*) AS post_count FROM posts GROUP BY OwnerUserId HAVING post_count > 10) AS T2 ON T1.Id = T2.OwnerUserId",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["users", "posts"],
        "columns": [
          "posts.OwnerUserId",
          "users.UpVotes",
          "users.Age",
          "users.Id"
        ],
        "output_schema": ["real", "real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for user information including UpVotes and Age\">users</table>",
        "<table purpose=\"Required to count posts per user\">posts</table>",
        "<column purpose=\"join: users.Id, filter: 'creating more than 10 posts'\">posts.OwnerUserId</column>",
        "<column purpose=\"calculate: 'average of the up votes'\">users.UpVotes</column>",
        "<column purpose=\"calculate: 'average user age'\">users.Age</column>",
        "<column purpose=\"join: posts.OwnerUserId\">users.Id</column>",
        "<output_schema purpose=\"average of the up votes\">real</output_schema>",
        "<output_schema purpose=\"average user age\">real</output_schema>",
        "<warning>The proposal is missing a COUNT or GROUP BY operation on posts.OwnerUserId to determine users with more than 10 posts</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for user information and post count--><table>users</table>",
        "<!--Required for counting posts per user--><table>posts</table>",
        "<!--Join users and posts--><column>users.Id</column>",
        "<!--Join users and posts--><column>posts.OwnerUserId</column>",
        "<!--Calculate average up votes--><column>users.UpVotes</column>",
        "<!--Calculate average age--><column>users.Age</column>",
        "<!--Average of up votes--><output_schema>real</output_schema>",
        "<!--Average user age--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 629,
      "db_id": "codebase_community",
      "question": "Calculate the ratio of votes in 2010 and 2011.",
      "evidence": "DIVIDE(COUNT(Id where YEAR(CreationDate) = 2010), COUNT(Id where YEAR(CreationDate) = 2011)) FROM votes;",
      "SQL": "SELECT CAST(SUM(IIF(STRFTIME('%Y', CreationDate) = '2010', 1, 0)) AS REAL) / SUM(IIF(STRFTIME('%Y', CreationDate) = '2011', 1, 0)) FROM votes",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["votes"],
        "columns": ["votes.CreationDate"],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for calculating the ratio of votes in 2010 and 2011\">votes</table>",
        "<column purpose=\"filter: used to determine votes in 2010 and 2011\">votes.CreationDate</column>",
        "<column purpose=\"calculate: used to count votes for each year\">votes.Id</column>",
        "<output_schema purpose=\"ratio of votes in 2010 and 2011\">real</output_schema>",
        "<error>votes.Id is missing from the proposal but is necessary for counting votes</error>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for vote counts in 2010 and 2011--><table>votes</table>",
        "<!--Filter votes by year and count--><column>votes.CreationDate</column>",
        "<!--Count votes--><column>votes.Id</column>",
        "<!--Ratio of votes in 2010 and 2011--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 633,
      "db_id": "codebase_community",
      "question": "Which post by slashnick has the most answers count? State the post ID.",
      "evidence": "most answers count refers to MAX(AnswerCount); post by slashnick refers to DisplayName = 'slashnick';",
      "SQL": "SELECT T2.PostId FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T1.DisplayName = 'slashnick' ORDER BY T3.AnswerCount DESC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["users", "postHistory", "posts"],
        "columns": [
          "postHistory.PostId",
          "users.Id",
          "postHistory.UserId",
          "posts.Id",
          "users.DisplayName",
          "posts.AnswerCount"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"To get user information for 'slashnick'\">users</table>",
        "<table purpose=\"To link users to posts\">postHistory</table>",
        "<table purpose=\"To get post information including answer count\">posts</table>",
        "<column purpose=\"join: users.Id, output: post ID\">postHistory.PostId</column>",
        "<column purpose=\"join: postHistory.UserId\">users.Id</column>",
        "<column purpose=\"join: users.Id\">postHistory.UserId</column>",
        "<column purpose=\"join: postHistory.PostId\">posts.Id</column>",
        "<column purpose=\"filter: 'post by slashnick'\">users.DisplayName</column>",
        "<column purpose=\"sort: 'most answers count'\">posts.AnswerCount</column>",
        "<output_schema purpose=\"post ID with most answers\">integer</output_schema>",
        "<error>The query is incorrect. It should join users directly with posts using posts.OwnerUserId instead of going through postHistory.</error>",
        "<warning>The query might return incorrect results if a user has edited a post they didn't create, as it's using postHistory to link users and posts.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'post by slashnick'--><table>users</table>",
        "<!--Required for 'post' and 'answers count'--><table>posts</table>",
        "<!--Filter: 'by slashnick'--><column>users.DisplayName</column>",
        "<!--Join: users.Id--><column>posts.OwnerUserId</column>",
        "<!--Join: posts.OwnerUserId--><column>users.Id</column>",
        "<!--Calculate: 'most answers count'--><column>posts.AnswerCount</column>",
        "<!--Output: 'State the post ID'--><column>posts.Id</column>",
        "<!--State the post ID--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 634,
      "db_id": "codebase_community",
      "question": "Among posts by Harvey Motulsky and Noah Snyder, which one has higher popularity?",
      "evidence": "Has higher popularity means the post has higher view count ; calculation = MAX(SUM(ViewCount)) where DisplayName = 'Harvey Motulsky' OR DisplayName = 'Noah Snyder';",
      "SQL": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T1.DisplayName = 'Harvey Motulsky' OR T1.DisplayName = 'Noah Snyder' GROUP BY T1.DisplayName ORDER BY SUM(T3.ViewCount) DESC LIMIT 1",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["users", "postHistory", "posts"],
        "columns": [
          "users.DisplayName",
          "users.Id",
          "postHistory.UserId",
          "postHistory.PostId",
          "posts.Id",
          "posts.ViewCount"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for user information and filtering by DisplayName\">users</table>",
        "<table purpose=\"Required to link users to posts\">postHistory</table>",
        "<table purpose=\"Required for post view count information\">posts</table>",
        "<column purpose=\"filter: 'Harvey Motulsky' and 'Noah Snyder', output: result\">users.DisplayName</column>",
        "<column purpose=\"join: postHistory.UserId\">users.Id</column>",
        "<column purpose=\"join: users.Id\">postHistory.UserId</column>",
        "<column purpose=\"join: posts.Id\">postHistory.PostId</column>",
        "<column purpose=\"join: postHistory.PostId\">posts.Id</column>",
        "<column purpose=\"calculate: 'higher popularity'\">posts.ViewCount</column>",
        "<output_schema purpose=\"Display name of the user with higher popularity\">text</output_schema>",
        "<warning>The proposed solution doesn't account for the possibility that a user might have multiple posts. Consider using MAX(SUM(ViewCount)) instead of just SUM(ViewCount) to accurately compare the most popular posts between the two users.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for post information and view count--><table>posts</table>",
        "<!--Required for user information--><table>users</table>",
        "<!--Join posts and users tables--><column>posts.OwnerUserId</column>",
        "<!--Join posts and users tables--><column>users.Id</column>",
        "<!--Filter for specific users--><column>users.DisplayName</column>",
        "<!--Calculate popularity--><column>posts.ViewCount</column>",
        "<!--Most popular user--><output_schema>text</output_schema>",
        "<!--Highest view count--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 637,
      "db_id": "codebase_community",
      "question": "State all the tags used by Mark Meckes in his posts that doesn't have comments.",
      "evidence": "used by Mark Meckes refers to DisplayName = 'Mark Meckes'; Doen't have comments refers to CommentCount = 0;",
      "SQL": "SELECT T3.Tags FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T3.Id = T2.PostId WHERE T1.DisplayName = 'Mark Meckes' AND T3.CommentCount = 0",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["users", "postHistory", "posts"],
        "columns": [
          "posts.Tags",
          "users.Id",
          "postHistory.UserId",
          "postHistory.PostId",
          "posts.Id",
          "posts.CommentCount",
          "users.DisplayName"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"To get user information for 'Mark Meckes'\">users</table>",
        "<table purpose=\"To link users to posts\">postHistory</table>",
        "<table purpose=\"To get post information including tags and comment count\">posts</table>",
        "<column purpose=\"output: 'State all the tags used by Mark Meckes'\">posts.Tags</column>",
        "<column purpose=\"join: postHistory.UserId\">users.Id</column>",
        "<column purpose=\"join: users.Id\">postHistory.UserId</column>",
        "<column purpose=\"join: posts.Id\">postHistory.PostId</column>",
        "<column purpose=\"join: postHistory.PostId\">posts.Id</column>",
        "<column purpose=\"filter: 'doesn't have comments'\">posts.CommentCount</column>",
        "<column purpose=\"filter: 'Mark Meckes'\">users.DisplayName</column>",
        "<output_schema purpose=\"tags are stored as text\">text</output_schema>",
        "<warning>The proposed query may not capture all posts by Mark Meckes. Consider using posts.OwnerUserId instead of joining through postHistory, as postHistory might not include all posts.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'tags used by Mark Meckes'--><table>posts</table>",
        "<!--Required for 'tags used by Mark Meckes'--><table>users</table>",
        "<!--Required to filter 'Mark Meckes'--><column>users.DisplayName</column>",
        "<!--Required to join users and posts--><column>users.Id</column>",
        "<!--Required to join users and posts--><column>posts.OwnerUserId</column>",
        "<!--Required to filter 'doesn't have comments'--><column>posts.CommentCount</column>",
        "<!--Required for 'tags used'--><column>posts.Tags</column>",
        "<!--State all the tags--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 639,
      "db_id": "codebase_community",
      "question": "Based on posts posted by Community, calculate the percentage of posts that use the R language.",
      "evidence": "DIVIDE(COUNT(PostId WHERE TagName = 'r')), (COUNT(PostId WHERE DisplayName = 'Community')) as percentage; R language refers to tagname = 'r'",
      "SQL": "SELECT CAST(SUM(IIF(T3.TagName = 'r', 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN tags AS T3 ON T3.ExcerptPostId = T2.PostId WHERE T1.DisplayName = 'Community'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["users", "postHistory", "tags"],
        "columns": [
          "tags.TagName",
          "users.Id",
          "postHistory.UserId",
          "postHistory.PostId",
          "tags.ExcerptPostId",
          "users.DisplayName"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"To get information about Community user\">users</table>",
        "<table purpose=\"To link users to posts\">postHistory</table>",
        "<table purpose=\"To check for R language tag\">tags</table>",
        "<column purpose=\"filter: 'R language refers to tagname = 'r''\">tags.TagName</column>",
        "<column purpose=\"join: postHistory.UserId\">users.Id</column>",
        "<column purpose=\"join: users.Id\">postHistory.UserId</column>",
        "<column purpose=\"join: tags.ExcerptPostId\">postHistory.PostId</column>",
        "<column purpose=\"join: postHistory.PostId\">tags.ExcerptPostId</column>",
        "<column purpose=\"filter: 'posts posted by Community'\">users.DisplayName</column>",
        "<output_schema purpose=\"percentage of posts that use the R language\">real</output_schema>",
        "<error>The proposal is missing the posts table, which is necessary to accurately count the number of posts by Community.</error>",
        "<error>The join between postHistory and tags using ExcerptPostId is incorrect. Tags should be joined with posts directly.</error>",
        "<warning>The proposed schema may not accurately count all posts by Community. Consider using the posts table and joining it with users directly.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for posts by Community--><table>posts</table>",
        "<!--Required for tag information--><table>tags</table>",
        "<!--Join posts and tags--><table>postTags</table>",
        "<!--Filter posts by Community user--><column>posts.OwnerDisplayName</column>",
        "<!--Join posts and tags--><column>posts.Id</column>",
        "<!--Join posts and tags--><column>postTags.PostId</column>",
        "<!--Join tags and postTags--><column>tags.Id</column>",
        "<!--Join tags and postTags--><column>postTags.TagId</column>",
        "<!--Filter for R language tag--><column>tags.TagName</column>",
        "<!--Calculate percentage of R posts--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 640,
      "db_id": "codebase_community",
      "question": "Calculate the difference in view count from post posted by Mornington and view count from posts posted by Amos.",
      "evidence": "calculation = SUBTRACT(SUM(ViewCount where DisplayName = 'Mornington'), SUM(ViewCount where DisplayName = 'Amos'));",
      "SQL": "SELECT SUM(IIF(T1.DisplayName = 'Mornington', T3.ViewCount, 0)) - SUM(IIF(T1.DisplayName = 'Amos', T3.ViewCount, 0)) AS diff FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T3.Id = T2.PostId",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["users", "postHistory", "posts"],
        "columns": [
          "users.DisplayName",
          "posts.ViewCount",
          "users.Id",
          "postHistory.UserId",
          "postHistory.PostId",
          "posts.Id"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for user information, including DisplayName\">users</table>",
        "<table purpose=\"Required to link users to posts\">postHistory</table>",
        "<table purpose=\"Required for post information, including ViewCount\">posts</table>",
        "<column purpose=\"filter: 'Mornington' and 'Amos'\">users.DisplayName</column>",
        "<column purpose=\"calculate: difference in view count\">posts.ViewCount</column>",
        "<column purpose=\"join: users.Id = postHistory.UserId\">users.Id</column>",
        "<column purpose=\"join: users.Id = postHistory.UserId\">postHistory.UserId</column>",
        "<column purpose=\"join: postHistory.PostId = posts.Id\">postHistory.PostId</column>",
        "<column purpose=\"join: postHistory.PostId = posts.Id\">posts.Id</column>",
        "<output_schema purpose=\"difference in view count\">integer</output_schema>",
        "<warning>The query assumes that postHistory is needed to link users to posts. However, it might be more direct to use the posts.OwnerUserId to link users to posts, which could simplify the query and potentially be more accurate.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'posts posted by Mornington and Amos'--><table>posts</table>",
        "<!--Required for user information--><table>users</table>",
        "<!--Calculate: 'SUM(ViewCount)'--><column>posts.ViewCount</column>",
        "<!--Join: posts.OwnerUserId--><column>users.Id</column>",
        "<!--Join: users.Id--><column>posts.OwnerUserId</column>",
        "<!--Filter: 'posts posted by Mornington and Amos'--><column>users.DisplayName</column>",
        "<!--Difference in view count--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 665,
      "db_id": "codebase_community",
      "question": "What is the average monthly number of links created in 2010 for posts that have no more than 2 answers?",
      "evidence": "calculation = DIVIDE(COUNT(Id where YEAR(CreationDate) = 2010 and AnswerCount < = 2), 12)",
      "SQL": "SELECT CAST(COUNT(T1.Id) AS REAL) / 12 FROM postLinks AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.AnswerCount <= 2 AND STRFTIME('%Y', T1.CreationDate) = '2010'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["postLinks", "posts"],
        "columns": [
          "postLinks.Id",
          "postLinks.PostId",
          "posts.Id",
          "posts.AnswerCount",
          "postLinks.CreationDate"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for counting links and filtering by creation date\">postLinks</table>",
        "<table purpose=\"Required for filtering by answer count\">posts</table>",
        "<column purpose=\"calculate: count of links\">postLinks.Id</column>",
        "<column purpose=\"join: posts.Id\">postLinks.PostId</column>",
        "<column purpose=\"join: postLinks.PostId\">posts.Id</column>",
        "<column purpose=\"filter: 'no more than 2 answers'\">posts.AnswerCount</column>",
        "<column purpose=\"filter: 'in 2010'\">postLinks.CreationDate</column>",
        "<output_schema purpose=\"average monthly number of links\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'links created'--><table>postLinks</table>",
        "<!--Required for 'posts that have no more than 2 answers'--><table>posts</table>",
        "<!--filter: 'in 2010'--><column>postLinks.CreationDate</column>",
        "<!--join: posts.Id--><column>postLinks.PostId</column>",
        "<!--join: postLinks.PostId--><column>posts.Id</column>",
        "<!--filter: 'no more than 2 answers'--><column>posts.AnswerCount</column>",
        "<!--count: 'number of links created'--><column>postLinks.Id</column>",
        "<!--average monthly number of links created in 2010--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 669,
      "db_id": "codebase_community",
      "question": "When did 'chl' cast its first vote in a post?",
      "evidence": "DisplayName = 'chl'; cast its first vote refers to MIN(CreationDate);",
      "SQL": "SELECT T2.CreationDate FROM users AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'chl' ORDER BY T2.CreationDate LIMIT 1",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["users", "votes"],
        "columns": [
          "votes.CreationDate",
          "users.Id",
          "votes.UserId",
          "users.DisplayName"
        ],
        "output_schema": ["date"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"To get user information for 'chl'\">users</table>",
        "<table purpose=\"To get voting information\">votes</table>",
        "<column purpose=\"calculate: 'When did ... cast its first vote', filter: MIN(CreationDate)\">votes.CreationDate</column>",
        "<column purpose=\"join: votes.UserId\">users.Id</column>",
        "<column purpose=\"join: users.Id\">votes.UserId</column>",
        "<column purpose=\"filter: 'chl'\">users.DisplayName</column>",
        "<output_schema purpose=\"Date of first vote\">date</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for user information--><table>users</table>",
        "<!--Required for vote information--><table>votes</table>",
        "<!--Join users and votes tables--><column>users.Id</column>",
        "<!--Join users and votes tables--><column>votes.UserId</column>",
        "<!--Filter for user 'chl'--><column>users.DisplayName</column>",
        "<!--Find the first vote date--><column>votes.CreationDate</column>",
        "<!--Date of first vote--><output_schema>date</output_schema>"
      ]
    },
    {
      "question_id": 671,
      "db_id": "codebase_community",
      "question": "What is the display name of the user who acquired the first Autobiographer badge?",
      "evidence": "Autobiographer is the name of the badge; acquired the first refers to MIN(Date);",
      "SQL": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.\"Name\" = 'Autobiographer' ORDER BY T2.Date LIMIT 1",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["users", "badges"],
        "columns": [
          "users.DisplayName",
          "users.Id",
          "badges.UserId",
          "badges.Name",
          "badges.Date"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to get user information\">users</table>",
        "<table purpose=\"Required to get badge information\">badges</table>",
        "<column purpose=\"output: 'display name of the user'\">users.DisplayName</column>",
        "<column purpose=\"join: badges.UserId\">users.Id</column>",
        "<column purpose=\"join: users.Id\">badges.UserId</column>",
        "<column purpose=\"filter: 'Autobiographer badge'\">badges.Name</column>",
        "<column purpose=\"sort: 'acquired the first'\">badges.Date</column>",
        "<output_schema purpose=\"display name of the user\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Autobiographer badge'--><table>badges</table>",
        "<!--Required to get user's display name--><table>users</table>",
        "<!--Filter for 'Autobiographer' badge--><column>badges.Name</column>",
        "<!--Find the earliest badge award date--><column>badges.Date</column>",
        "<!--Join badges with users--><column>badges.UserId</column>",
        "<!--Join badges with users--><column>users.Id</column>",
        "<!--Get user's display name--><column>users.DisplayName</column>",
        "<!--Display name of the user--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 672,
      "db_id": "codebase_community",
      "question": "Among the users located in United Kingdom, how many users whose post have a total favorite amount of 4 or more?",
      "evidence": "favorite amount of 4 or more refers to FavoriteCount > = 4; Location = 'United Kingdom';",
      "SQL": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.Location = 'United Kingdom' AND T2.FavoriteCount >= 4",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["users", "posts"],
        "columns": [
          "users.Id",
          "posts.OwnerUserId",
          "posts.FavoriteCount",
          "users.Location"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains user information, including location\">users</table>",
        "<table purpose=\"Contains post information, including favorite count\">posts</table>",
        "<column purpose=\"join: posts.OwnerUserId\">users.Id</column>",
        "<column purpose=\"join: users.Id\">posts.OwnerUserId</column>",
        "<column purpose=\"filter: 'favorite amount of 4 or more'\">posts.FavoriteCount</column>",
        "<column purpose=\"filter: 'located in United Kingdom'\">users.Location</column>",
        "<output_schema purpose=\"count of users meeting the criteria\">integer</output_schema>",
        "<warning>The query might double-count users if they have multiple posts with FavoriteCount >= 4. Consider using DISTINCT in the COUNT or grouping by user ID to avoid this.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for user information and location--><table>users</table>",
        "<!--Required for post information and favorite count--><table>posts</table>",
        "<!--Filter: 'located in United Kingdom'--><column>users.Location</column>",
        "<!--Join: users.Id with posts.OwnerUserId--><column>users.Id</column>",
        "<!--Join: posts.OwnerUserId with users.Id--><column>posts.OwnerUserId</column>",
        "<!--Filter: 'favorite amount of 4 or more'--><column>posts.FavoriteCount</column>",
        "<!--Count of users meeting the criteria--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 678,
      "db_id": "codebase_community",
      "question": "Which post by Harvey Motulsky has the most views? Please give the id and title of this post.",
      "evidence": "DisplayName = 'Harvey Motulsky'; the most views refer to MAX(ViewCount);",
      "SQL": "SELECT T2.Id, T2.Title FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.DisplayName = 'Harvey Motulsky' ORDER BY T2.ViewCount DESC LIMIT 1",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["users", "posts"],
        "columns": [
          "posts.Id",
          "posts.Title",
          "users.Id",
          "posts.OwnerUserId",
          "users.DisplayName",
          "posts.ViewCount"
        ],
        "output_schema": ["integer", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"To get user information for Harvey Motulsky\">users</table>",
        "<table purpose=\"To get post information including views and title\">posts</table>",
        "<column purpose=\"output: 'id of this post'\">posts.Id</column>",
        "<column purpose=\"output: 'title of this post'\">posts.Title</column>",
        "<column purpose=\"join: posts.OwnerUserId\">users.Id</column>",
        "<column purpose=\"join: users.Id\">posts.OwnerUserId</column>",
        "<column purpose=\"filter: 'Harvey Motulsky'\">users.DisplayName</column>",
        "<column purpose=\"sort: 'the most views'\">posts.ViewCount</column>",
        "<output_schema purpose=\"id of the post with most views\">integer</output_schema>",
        "<output_schema purpose=\"title of the post with most views\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for post information--><table>posts</table>",
        "<!--Required to filter by author--><table>users</table>",
        "<!--join: posts.OwnerUserId--><column>users.Id</column>",
        "<!--filter: 'Harvey Motulsky'--><column>users.DisplayName</column>",
        "<!--join: users.Id--><column>posts.OwnerUserId</column>",
        "<!--calculate: 'the most views'--><column>posts.ViewCount</column>",
        "<!--'id of this post'--><column>posts.Id</column>",
        "<!--'title of this post'--><column>posts.Title</column>",
        "<!--id of the post--><output_schema>integer</output_schema>",
        "<!--title of the post--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 682,
      "db_id": "codebase_community",
      "question": "Which is the most valuable post in 2010? Please give its id and the owner's display name.",
      "evidence": "the most valuable post in 2010 refers to MAX(FavoriteCount) where year(CreationDate) = 2010;",
      "SQL": "SELECT T2.OwnerUserId, T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE STRFTIME('%Y', T1.CreationDate) = '2010' ORDER BY T2.FavoriteCount DESC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["users", "posts"],
        "columns": [
          "posts.OwnerUserId",
          "users.DisplayName",
          "users.Id",
          "users.CreationDate",
          "posts.FavoriteCount"
        ],
        "output_schema": ["integer", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for user information\">users</table>",
        "<table purpose=\"Required for post information\">posts</table>",
        "<column purpose=\"join: users.Id\">posts.OwnerUserId</column>",
        "<column purpose=\"output: 'owner's display name'\">users.DisplayName</column>",
        "<column purpose=\"join: posts.OwnerUserId\">users.Id</column>",
        "<error>users.CreationDate should not be used. The question asks for posts created in 2010, not users created in 2010.</error>",
        "<column purpose=\"filter: 'in 2010', calculate: 'most valuable post'\">posts.CreationDate</column>",
        "<column purpose=\"calculate: 'most valuable post'\">posts.FavoriteCount</column>",
        "<column purpose=\"output: 'give its id'\">posts.Id</column>",
        "<output_schema purpose=\"post id\">integer</output_schema>",
        "<output_schema purpose=\"owner's display name\">text</output_schema>",
        "<error>The SQL query does not match the question. It should select posts.Id instead of posts.OwnerUserId, and filter on posts.CreationDate instead of users.CreationDate.</error>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'most valuable post in 2010'--><table>posts</table>",
        "<!--filter: 'in 2010'--><column>posts.CreationDate</column>",
        "<!--calculate: 'MAX(FavoriteCount)'--><column>posts.FavoriteCount</column>",
        "<!--'give its id'--><column>posts.Id</column>",
        "<!--'owner's display name'--><column>posts.OwnerDisplayName</column>",
        "<!--If OwnerDisplayName is null, we need to join with users table--><table>users</table>",
        "<!--join: posts.OwnerUserId--><column>posts.OwnerUserId</column>",
        "<!--join: users.Id--><column>users.Id</column>",
        "<!--'owner's display name' (if null in posts table)--><column>users.DisplayName</column>",
        "<!--'give its id'--><output_schema>integer</output_schema>",
        "<!--'owner's display name'--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 683,
      "db_id": "codebase_community",
      "question": "What is the percentage of posts whose owners had a reputation of over 1000 in 2011?",
      "evidence": "percentage = DIVIDE(COUNT(Id where YEAR(CreationDate) = 2011 and Reputation > 1000), COUNT(Id) ) * 100;",
      "SQL": "SELECT CAST(SUM(IIF(STRFTIME('%Y', T2.CreaionDate) = '2011' AND T1.Reputation > 1000, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["users", "posts"],
        "columns": [
          "users.Reputation",
          "posts.CreaionDate",
          "users.Id",
          "posts.OwnerUserId"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for user reputation data\">users</table>",
        "<table purpose=\"Required for post creation dates and owner information\">posts</table>",
        "<column purpose=\"filter: 'reputation of over 1000'\">users.Reputation</column>",
        "<column purpose=\"filter: 'in 2011'\">posts.CreaionDate</column>",
        "<warning>The column name 'CreaionDate' appears to be misspelled. It should be 'CreationDate'.</warning>",
        "<column purpose=\"join: posts.OwnerUserId\">users.Id</column>",
        "<column purpose=\"join: users.Id\">posts.OwnerUserId</column>",
        "<output_schema purpose=\"percentage calculation result\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for post information--><table>posts</table>",
        "<!--Required for user reputation--><table>users</table>",
        "<!--Filter: 'in 2011'--><column>posts.CreaionDate</column>",
        "<!--Join: posts.OwnerUserId--><column>posts.OwnerUserId</column>",
        "<!--Join: users.Id--><column>users.Id</column>",
        "<!--Filter: 'reputation of over 1000'--><column>users.Reputation</column>",
        "<!--Count posts--><column>posts.Id</column>",
        "<!--Percentage of posts--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 685,
      "db_id": "codebase_community",
      "question": "Identify the total views on the post 'Computer Game Datasets'. Name the user who posted it last time.",
      "evidence": "total views refer to ViewCount; Name the user refers to DisplayName; post 'Computer Game Datasets' refers to Text = 'Computer Game Datasets';",
      "SQL": "SELECT T2.ViewCount, T3.DisplayName FROM postHistory AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id INNER JOIN users AS T3 ON T2.LastEditorUserId = T3.Id WHERE T1.Text = 'Computer Game Datasets'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["postHistory", "posts", "users"],
        "columns": [
          "posts.ViewCount",
          "users.DisplayName",
          "postHistory.PostId",
          "posts.Id",
          "posts.LastEditorUserId",
          "users.Id",
          "postHistory.Text"
        ],
        "output_schema": ["integer", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains the post history information, including the text of the post\">postHistory</table>",
        "<table purpose=\"Contains the post information, including view count\">posts</table>",
        "<table purpose=\"Contains user information, including display name\">users</table>",
        "<column purpose=\"calculate: 'total views on the post'\">posts.ViewCount</column>",
        "<column purpose=\"output: 'Name the user who posted it last time'\">users.DisplayName</column>",
        "<column purpose=\"join: posts.Id\">postHistory.PostId</column>",
        "<column purpose=\"join: postHistory.PostId\">posts.Id</column>",
        "<column purpose=\"join: users.Id\">posts.LastEditorUserId</column>",
        "<column purpose=\"join: posts.LastEditorUserId\">users.Id</column>",
        "<column purpose=\"filter: 'post 'Computer Game Datasets''\">postHistory.Text</column>",
        "<output_schema purpose=\"total views on the post\">integer</output_schema>",
        "<output_schema purpose=\"Name the user who posted it last time\">text</output_schema>",
        "<warning>The query assumes that the most recent edit in postHistory corresponds to the 'last time' the post was edited. This may not always be true if the postHistory table doesn't contain all edits or if there's a more direct way to get the last editor from the posts table.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'post Computer Game Datasets'--><table>posts</table>",
        "<!--Required to get the user who posted it last time--><table>users</table>",
        "<!--Filter: 'post Computer Game Datasets'--><column>posts.Title</column>",
        "<!--Calculate: 'total views'--><column>posts.ViewCount</column>",
        "<!--Join: posts.LastEditorUserId--><column>users.Id</column>",
        "<!--Output: 'Name the user'--><column>users.DisplayName</column>",
        "<!--Total views on the post--><output_schema>integer</output_schema>",
        "<!--Name of the user who posted it last time--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 687,
      "db_id": "codebase_community",
      "question": "How many comments were added to the post with the highest score?",
      "evidence": "the highest score refers to MAX(Score);",
      "SQL": "SELECT COUNT(T2.Id) FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId GROUP BY T1.Id ORDER BY T1.Score DESC LIMIT 1",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["posts", "comments"],
        "columns": ["comments.Id", "posts.Id", "comments.PostId", "posts.Score"],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'post with the highest score'\">posts</table>",
        "<table purpose=\"Required for 'comments were added to the post'\">comments</table>",
        "<column purpose=\"calculate: count of comments\">comments.Id</column>",
        "<column purpose=\"join: posts.Id\">posts.Id</column>",
        "<column purpose=\"join: comments.PostId\">comments.PostId</column>",
        "<column purpose=\"filter: 'highest score'\">posts.Score</column>",
        "<output_schema purpose=\"count of comments\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'highest score'--><table>posts</table>",
        "<!--Required for 'comments'--><table>comments</table>",
        "<!--Calculate: 'highest score'--><column>posts.Score</column>",
        "<!--Join: posts.Id--><column>comments.PostId</column>",
        "<!--Join: comments.PostId--><column>posts.Id</column>",
        "<!--Count: 'How many comments'--><column>comments.Id</column>",
        "<!--Number of comments for the post with the highest score--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 694,
      "db_id": "codebase_community",
      "question": "Provide the text of the latest 10 comments to the post with the title 'Analysing wind data with R' and the display name of the user who left it.",
      "evidence": "the latest comment refers to MAX(CreationDate);",
      "SQL": "SELECT T3.Text, T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId INNER JOIN comments AS T3 ON T2.Id = T3.PostId WHERE T2.Title = 'Analysing wind data with R' ORDER BY T1.CreationDate DESC LIMIT 10",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["users", "posts", "comments"],
        "columns": [
          "comments.Text",
          "users.DisplayName",
          "users.Id",
          "posts.OwnerUserId",
          "posts.Title",
          "posts.Id",
          "comments.PostId",
          "users.CreationDate"
        ],
        "output_schema": ["text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for user display name\">users</table>",
        "<table purpose=\"Required to filter by post title\">posts</table>",
        "<table purpose=\"Required for comment text\">comments</table>",
        "<column purpose=\"output: 'text of the latest 10 comments'\">comments.Text</column>",
        "<column purpose=\"output: 'display name of the user who left it'\">users.DisplayName</column>",
        "<column purpose=\"join: posts.OwnerUserId\">users.Id</column>",
        "<column purpose=\"join: users.Id\">posts.OwnerUserId</column>",
        "<column purpose=\"filter: 'post with the title 'Analysing wind data with R''\">posts.Title</column>",
        "<column purpose=\"join: comments.PostId\">posts.Id</column>",
        "<column purpose=\"join: posts.Id\">comments.PostId</column>",
        "<column warning=\"This column is not needed. The question asks for the latest comments, which should use comments.CreationDate, not users.CreationDate\">users.CreationDate</column>",
        "<error>Missing column: comments.CreationDate is required to determine 'the latest 10 comments'</error>",
        "<output_schema purpose=\"comment text\">text</output_schema>",
        "<output_schema purpose=\"user display name\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'post with the title'--><table>posts</table>",
        "<!--Required for 'comments to the post'--><table>comments</table>",
        "<!--Required for 'display name of the user'--><table>users</table>",
        "<!--filter: 'with the title \"Analysing wind data with R\"'--><column>posts.Title</column>",
        "<!--join: comments.PostId--><column>posts.Id</column>",
        "<!--join: posts.Id--><column>comments.PostId</column>",
        "<!--sort: 'the latest 10 comments'--><column>comments.CreationDate</column>",
        "<!--output: 'text of the comments'--><column>comments.Text</column>",
        "<!--join: comments.UserId--><column>users.Id</column>",
        "<!--join: users.Id--><column>comments.UserId</column>",
        "<!--output: 'display name of the user'--><column>users.DisplayName</column>",
        "<!--text of the comment--><output_schema>text</output_schema>",
        "<!--display name of the user--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 701,
      "db_id": "codebase_community",
      "question": "Among all the posts posted by the most influential user, identify the percentage with a score above 50.",
      "evidence": "The higher reputation the user has the more influence; percentage = DIVIDE(COUNT(stats_posts.Id where Score > 50 and MAX(Reputation))), COUNT(stats_posts.Id where MAX(Reputation));",
      "SQL": "SELECT CAST(SUM(CASE WHEN T2.Score > 50 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Id) FROM users T1 INNER JOIN posts T2 ON T1.Id = T2.OwnerUserId INNER JOIN ( SELECT MAX(Reputation) AS max_reputation FROM users ) T3 ON T1.Reputation = T3.max_reputation",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["users", "posts"],
        "columns": [
          "users.Reputation",
          "posts.Score",
          "users.Id",
          "posts.OwnerUserId"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to identify the most influential user and their posts\">users</table>",
        "<table purpose=\"Required to get post scores for the most influential user\">posts</table>",
        "<column purpose=\"filter: identify 'the most influential user'\">users.Reputation</column>",
        "<column purpose=\"filter: 'score above 50'\">posts.Score</column>",
        "<column purpose=\"join: posts.OwnerUserId\">users.Id</column>",
        "<column purpose=\"join: users.Id\">posts.OwnerUserId</column>",
        "<output_schema purpose=\"percentage of posts with score above 50\">real</output_schema>",
        "<warning>The proposal is missing posts.Id, which is needed to count the total number of posts by the most influential user</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'posts posted by the most influential user'--><table>posts</table>",
        "<!--Required for 'most influential user'--><table>users</table>",
        "<!--join: posts.OwnerUserId--><column>users.Id</column>",
        "<!--join: users.Id--><column>posts.OwnerUserId</column>",
        "<!--calculate: 'most influential user'--><column>users.Reputation</column>",
        "<!--filter: 'posts with a score above 50'--><column>posts.Score</column>",
        "<!--count: 'posts posted by the most influential user'--><column>posts.Id</column>",
        "<!--percentage of posts with score above 50--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 704,
      "db_id": "codebase_community",
      "question": "What is the excerpt post ID and wiki post ID of the tag named sample?",
      "evidence": "tag named sample refers to TagName = 'sample';",
      "SQL": "SELECT ExcerptPostId, WikiPostId FROM tags WHERE TagName = 'sample'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["tags"],
        "columns": ["tags.ExcerptPostId", "tags.WikiPostId", "tags.TagName"],
        "output_schema": ["integer", "integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains tag information, including 'sample' tag\">tags</table>",
        "<column purpose=\"output: 'excerpt post ID'\">tags.ExcerptPostId</column>",
        "<column purpose=\"output: 'wiki post ID'\">tags.WikiPostId</column>",
        "<column purpose=\"filter: 'tag named sample'\">tags.TagName</column>",
        "<output_schema purpose=\"excerpt post ID\">integer</output_schema>",
        "<output_schema purpose=\"wiki post ID\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'tag named sample'--><table>tags</table>",
        "<!--filter: 'tag named sample'--><column>tags.TagName</column>",
        "<!--output: 'excerpt post ID'--><column>tags.ExcerptPostId</column>",
        "<!--output: 'wiki post ID'--><column>tags.WikiPostId</column>",
        "<!--excerpt post ID--><output_schema>integer</output_schema>",
        "<!--wiki post ID--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 705,
      "db_id": "codebase_community",
      "question": "Give the user's reputation and up vote number of the user that commented \"fine, you win :)\".",
      "evidence": "Text = 'fine, you win :)';",
      "SQL": "SELECT T2.Reputation, T2.UpVotes FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Text = 'fine, you win :)'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["comments", "users"],
        "columns": [
          "users.Reputation",
          "users.UpVotes",
          "comments.UserId",
          "users.Id",
          "comments.Text"
        ],
        "output_schema": ["integer", "integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains the comment text to search for\">comments</table>",
        "<table purpose=\"Contains user reputation and upvote information\">users</table>",
        "<column purpose=\"Output: 'user's reputation'\">users.Reputation</column>",
        "<column purpose=\"Output: 'up vote number'\">users.UpVotes</column>",
        "<column purpose=\"Join: link comments to users\">comments.UserId</column>",
        "<column purpose=\"Join: link users to comments\">users.Id</column>",
        "<column purpose=\"Filter: 'Text = 'fine, you win :)''\">comments.Text</column>",
        "<output_schema purpose=\"User's reputation\">integer</output_schema>",
        "<output_schema purpose=\"User's up vote number\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for finding the comment--><table>comments</table>",
        "<!--Required for getting user information--><table>users</table>",
        "<!--Filter: 'Text = \"fine, you win :)\"'--><column>comments.Text</column>",
        "<!--Join: comments.UserId--><column>comments.UserId</column>",
        "<!--Join: users.Id--><column>users.Id</column>",
        "<!--Output: 'user's reputation'--><column>users.Reputation</column>",
        "<!--Output: 'up vote number'--><column>users.UpVotes</column>",
        "<!--User's reputation--><output_schema>integer</output_schema>",
        "<!--User's up vote number--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 707,
      "db_id": "codebase_community",
      "question": "Among the posts with views ranging from 100 to 150, what is the comment with the highest score?",
      "evidence": "views ranging from 100 to 150 refers to ViewCount BETWEEN 100 and 150; comment with the highest score refers to Text where MAX(Score);",
      "SQL": "SELECT Text FROM comments WHERE PostId IN ( SELECT Id FROM posts WHERE ViewCount BETWEEN 100 AND 150 ) ORDER BY Score DESC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["comments", "posts"],
        "columns": [
          "posts.Id",
          "posts.ViewCount",
          "comments.Text",
          "comments.Score",
          "comments.PostId"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'comment with the highest score'\">comments</table>",
        "<table purpose=\"Required for filtering posts 'with views ranging from 100 to 150'\">posts</table>",
        "<column purpose=\"join: comments.PostId\">posts.Id</column>",
        "<column purpose=\"filter: 'views ranging from 100 to 150'\">posts.ViewCount</column>",
        "<column purpose=\"output: 'what is the comment'\">comments.Text</column>",
        "<column purpose=\"calculate: 'highest score'\">comments.Score</column>",
        "<column purpose=\"join: posts.Id\">comments.PostId</column>",
        "<output_schema purpose=\"comment text with highest score\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'posts with views ranging from 100 to 150'--><table>posts</table>",
        "<!--Required for 'comment with the highest score'--><table>comments</table>",
        "<!--filter: 'views ranging from 100 to 150'--><column>posts.ViewCount</column>",
        "<!--join: posts.Id--><column>comments.PostId</column>",
        "<!--join: comments.PostId--><column>posts.Id</column>",
        "<!--calculate: 'comment with the highest score'--><column>comments.Score</column>",
        "<!--output: 'comment with the highest score'--><column>comments.Text</column>",
        "<!--comment with the highest score--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 710,
      "db_id": "codebase_community",
      "question": "In posts with 1 comment, how many of the comments have 0 score?",
      "evidence": "in posts with 1 comment refers to CommentCount = 1;",
      "SQL": "SELECT COUNT(T1.id) FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.CommentCount = 1 AND T2.Score = 0",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["comments", "posts"],
        "columns": [
          "comments.Id",
          "comments.PostId",
          "posts.Id",
          "posts.CommentCount",
          "posts.Score"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for comment information\">comments</table>",
        "<table purpose=\"Required for post information and filtering\">posts</table>",
        "<column purpose=\"count: 'how many of the comments'\">comments.Id</column>",
        "<column purpose=\"join: posts.Id\">comments.PostId</column>",
        "<column purpose=\"join: comments.PostId\">posts.Id</column>",
        "<column purpose=\"filter: 'posts with 1 comment'\">posts.CommentCount</column>",
        "<error>posts.Score should be comments.Score. The question asks about comment scores, not post scores.</error>",
        "<column purpose=\"filter: 'comments have 0 score'\">comments.Score</column>",
        "<output_schema purpose=\"count of comments with 0 score\">integer</output_schema>",
        "<warning>The SQL query provided does not match the question. It's counting posts with 1 comment and 0 score, not comments with 0 score on posts with 1 comment.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'posts with 1 comment'--><table>posts</table>",
        "<!--Required for comment details--><table>comments</table>",
        "<!--Filter: 'posts with 1 comment'--><column>posts.CommentCount</column>",
        "<!--Join: posts.Id--><column>comments.PostId</column>",
        "<!--Join: comments.PostId--><column>posts.Id</column>",
        "<!--Filter: 'comments have 0 score'--><column>comments.Score</column>",
        "<!--Count of comments with 0 score--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 716,
      "db_id": "codebase_community",
      "question": "Among the comments with scores between 5 to 10, what is the percentage of the users with 0 up votes?",
      "evidence": "percentage = DIVIDE(COUNT(UserId where UpVotes = 0 and Score BETWEEN 5 and 10))*100, (COUNT(UserId where Score BETWEEN 5 and 10));",
      "SQL": "SELECT CAST(SUM(IIF(T1.UpVotes = 0, 1, 0)) AS REAL) * 100/ COUNT(T1.Id) AS per FROM users AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.UserId WHERE T2.Score BETWEEN 5 AND 10",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["users", "comments"],
        "columns": [
          "users.UpVotes",
          "users.Id",
          "comments.UserId",
          "comments.Score"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for user information and UpVotes count\">users</table>",
        "<table purpose=\"Required for comment scores\">comments</table>",
        "<column purpose=\"filter: 'users with 0 up votes'\">users.UpVotes</column>",
        "<column purpose=\"join: comments.UserId\">users.Id</column>",
        "<column purpose=\"join: users.Id\">comments.UserId</column>",
        "<column purpose=\"filter: 'scores between 5 to 10'\">comments.Score</column>",
        "<output_schema purpose=\"percentage calculation result\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for comment scores--><table>comments</table>",
        "<!--Required for user upvotes--><table>users</table>",
        "<!--Filter: 'scores between 5 to 10'--><column>comments.Score</column>",
        "<!--Join: comments.UserId--><column>comments.UserId</column>",
        "<!--Join: users.Id--><column>users.Id</column>",
        "<!--Filter: 'users with 0 up votes'--><column>users.UpVotes</column>",
        "<!--Percentage of users with 0 up votes--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 340,
      "db_id": "card_games",
      "question": "Which are the cards that have incredibly powerful foils.",
      "evidence": "incredibly poweful foils refers to cardKingdomFoilId is not null AND cardKingdomId is not null",
      "SQL": "SELECT id FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["cards"],
        "columns": ["cards.id", "cards.cardKingdomFoilId", "cards.cardKingdomId"],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains the card information, including foil and non-foil identifiers\">cards</table>",
        "<column purpose=\"Output: Identifier for cards with powerful foils\">cards.id</column>",
        "<column purpose=\"Filter: Check for non-null foil identifier\">cards.cardKingdomFoilId</column>",
        "<column purpose=\"Filter: Check for non-null non-foil identifier\">cards.cardKingdomId</column>",
        "<output_schema purpose=\"Card identifier\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'cards that have incredibly powerful foils'--><table>cards</table>",
        "<!--filter: 'cardKingdomFoilId is not null'--><column>cards.cardKingdomFoilId</column>",
        "<!--filter: 'cardKingdomId is not null'--><column>cards.cardKingdomId</column>",
        "<!--output: card names with powerful foils--><column>cards.name</column>",
        "<!--card names with powerful foils--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 341,
      "db_id": "card_games",
      "question": "What are the borderless cards available without powerful foils?",
      "evidence": "borderless' refers to borderColor; poweful foils refers to cardKingdomFoilId paired with cardKingdomId AND cardKingdomId is not null",
      "SQL": "SELECT id FROM cards WHERE borderColor = 'borderless' AND (cardKingdomId IS NULL OR cardKingdomId IS NULL)",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["cards"],
        "columns": ["cards.id", "cards.borderColor", "cards.cardKingdomId"],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for querying card information\">cards</table>",
        "<column purpose=\"output: card identifier\">cards.id</column>",
        "<column purpose=\"filter: 'borderless cards'\">cards.borderColor</column>",
        "<column purpose=\"filter: 'without powerful foils'\">cards.cardKingdomId</column>",
        "<column purpose=\"filter: 'without powerful foils'\" warning=\"The user's definition of 'powerful foils' involves both cardKingdomFoilId and cardKingdomId\">cards.cardKingdomFoilId</column>",
        "<output_schema purpose=\"card identifier\">integer</output_schema>",
        "<error>The SQL query does not match the question. It should check for cardKingdomFoilId IS NULL, not cardKingdomId IS NULL twice.</error>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'borderless cards'--><table>cards</table>",
        "<!--filter: 'borderless'--><column>cards.borderColor</column>",
        "<!--filter: 'without powerful foils'--><column>cards.cardKingdomFoilId</column>",
        "<!--filter: 'without powerful foils'--><column>cards.cardKingdomId</column>",
        "<!--output: card names--><column>cards.name</column>",
        "<!--borderless cards without powerful foils--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 344,
      "db_id": "card_games",
      "question": "List all the mythic rarity print cards banned in gladiator format.",
      "evidence": "mythic rarity printing refers to rarity = 'mythic'; card banned refers to status = 'Banned'; in gladiator format refers to format = 'gladiator';",
      "SQL": "SELECT DISTINCT T1.id FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'gladiator' AND T2.status = 'Banned' AND T1.rarity = 'mythic'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["cards", "legalities"],
        "columns": [
          "cards.id",
          "cards.uuid",
          "legalities.uuid",
          "legalities.format",
          "legalities.status",
          "cards.rarity"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains card information, including rarity\">cards</table>",
        "<table purpose=\"Contains legality information for different formats\">legalities</table>",
        "<column purpose=\"output: unique identifier for each card, join: cards.uuid\">cards.id</column>",
        "<column purpose=\"join: legalities.uuid\">cards.uuid</column>",
        "<column purpose=\"join: cards.uuid\">legalities.uuid</column>",
        "<column purpose=\"filter: 'in gladiator format'\">legalities.format</column>",
        "<column purpose=\"filter: 'banned'\">legalities.status</column>",
        "<column purpose=\"filter: 'mythic rarity'\">cards.rarity</column>",
        "<output_schema purpose=\"list of card IDs\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'mythic rarity print cards'--><table>cards</table>",
        "<!--Required for 'banned in gladiator format'--><table>legalities</table>",
        "<!--filter: 'mythic rarity'--><column>cards.rarity</column>",
        "<!--join: cards.uuid--><column>legalities.uuid</column>",
        "<!--join: legalities.uuid--><column>cards.uuid</column>",
        "<!--filter: 'in gladiator format'--><column>legalities.format</column>",
        "<!--filter: 'banned'--><column>legalities.status</column>",
        "<!--List all the mythic rarity print cards banned in gladiator format--><column>cards.name</column>",
        "<!--List all the mythic rarity print cards banned in gladiator format--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 345,
      "db_id": "card_games",
      "question": "For artifact type of cards that do not have multiple faces on the same card, state its legalities status for vintage play format.",
      "evidence": "Artifact type of cards refers to types = 'Artifact'; card does not have multiple faces on the same card refers to side is NULL'; vintage play format refers to format = 'vintage';",
      "SQL": "SELECT DISTINCT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.type = 'Artifact' AND T2.format = 'vintage' AND T1.side IS NULL",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["cards", "legalities"],
        "columns": [
          "legalities.status",
          "cards.uuid",
          "legalities.uuid",
          "legalities.format",
          "cards.side",
          "cards.type"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains card information, including type and side\">cards</table>",
        "<table purpose=\"Contains legality information for different formats\">legalities</table>",
        "<column purpose=\"Output: legalities status for vintage format\">legalities.status</column>",
        "<column purpose=\"Join: link cards to legalities\">cards.uuid</column>",
        "<column purpose=\"Join: link legalities to cards\">legalities.uuid</column>",
        "<column purpose=\"Filter: 'vintage play format'\">legalities.format</column>",
        "<column purpose=\"Filter: 'do not have multiple faces on the same card'\">cards.side</column>",
        "<column purpose=\"Filter: 'Artifact type of cards'\">cards.type</column>",
        "<output_schema purpose=\"Status of legality for vintage format\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'artifact type of cards'--><table>cards</table>",
        "<!--Required for legalities status--><table>legalities</table>",
        "<!--filter: 'artifact type of cards'--><column>cards.types</column>",
        "<!--filter: 'do not have multiple faces on the same card'--><column>cards.side</column>",
        "<!--join: cards.uuid--><column>cards.uuid</column>",
        "<!--join: legalities.uuid--><column>legalities.uuid</column>",
        "<!--filter: 'vintage play format'--><column>legalities.format</column>",
        "<!--output: card name--><column>cards.name</column>",
        "<!--output: legalities status for vintage format--><column>legalities.status</column>",
        "<!--card name--><output_schema>text</output_schema>",
        "<!--legalities status for vintage format--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 346,
      "db_id": "card_games",
      "question": "List all the card id and artist with unknown power which are legal for commander play format.",
      "evidence": "unknown power refers to power = '*' or POWER IS NULL; commander play format refers to format = 'commander'; legal for commander play format refers to format = 'commander' where status = 'Legal'",
      "SQL": "SELECT T1.id, T1.artist FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Legal' AND T2.format = 'commander' AND (T1.power IS NULL OR T1.power = '*')",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["cards", "legalities"],
        "columns": [
          "cards.id",
          "cards.artist",
          "cards.uuid",
          "legalities.uuid",
          "legalities.format",
          "legalities.status",
          "cards.power"
        ],
        "output_schema": ["integer", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains card information including id, artist, and power\">cards</table>",
        "<table purpose=\"Contains legality information for different formats\">legalities</table>",
        "<column purpose=\"output: 'List all the card id'\">cards.id</column>",
        "<column purpose=\"output: 'List all the ... artist'\">cards.artist</column>",
        "<column purpose=\"join: legalities.uuid\">cards.uuid</column>",
        "<column purpose=\"join: cards.uuid\">legalities.uuid</column>",
        "<column purpose=\"filter: 'commander play format'\">legalities.format</column>",
        "<column purpose=\"filter: 'legal for commander play format'\">legalities.status</column>",
        "<column purpose=\"filter: 'unknown power'\">cards.power</column>",
        "<output_schema purpose=\"card id\">integer</output_schema>",
        "<output_schema purpose=\"artist name\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for card id and artist--><table>cards</table>",
        "<!--Required for legality information--><table>legalities</table>",
        "<!--card id--><column>cards.id</column>",
        "<!--artist name--><column>cards.artist</column>",
        "<!--unknown power condition--><column>cards.power</column>",
        "<!--join: cards.uuid--><column>cards.uuid</column>",
        "<!--join: legalities.uuid--><column>legalities.uuid</column>",
        "<!--filter: commander format--><column>legalities.format</column>",
        "<!--filter: legal status--><column>legalities.status</column>",
        "<!--card id--><output_schema>integer</output_schema>",
        "<!--artist name--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 347,
      "db_id": "card_games",
      "question": "Find all cards illustrated by Stephen Daniel and describe the text of the ruling of these cards. State if these cards have missing or degraded properties and values.",
      "evidence": "cards have missing or degraded properties and value refers to hasContentWarning = 1; 'Stephen Daniele' is artist; Find all cards refers to return card id",
      "SQL": "SELECT T1.id, T2.text, T1.hasContentWarning FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Stephen Daniele'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["cards", "rulings"],
        "columns": [
          "cards.id",
          "rulings.text",
          "cards.hasContentWarning",
          "cards.uuid",
          "rulings.uuid",
          "cards.artist"
        ],
        "output_schema": ["integer", "text", "integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for finding cards and their properties\">cards</table>",
        "<table purpose=\"Required for describing the text of the ruling of these cards\">rulings</table>",
        "<column purpose=\"output: 'Find all cards refers to return card id'\">cards.id</column>",
        "<column purpose=\"output: 'describe the text of the ruling of these cards'\">rulings.text</column>",
        "<column purpose=\"output: 'State if these cards have missing or degraded properties and values'\">cards.hasContentWarning</column>",
        "<column purpose=\"join: cards.uuid\">cards.uuid</column>",
        "<column purpose=\"join: rulings.uuid\">rulings.uuid</column>",
        "<column purpose=\"filter: ''Stephen Daniele' is artist'\">cards.artist</column>",
        "<output_schema purpose=\"card id\">integer</output_schema>",
        "<output_schema purpose=\"ruling text\">text</output_schema>",
        "<output_schema purpose=\"hasContentWarning\">integer</output_schema>",
        "<warning>The artist name in the question is 'Stephen Daniel', but the SQL query uses 'Stephen Daniele'. Make sure to use the correct spelling as per the question.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Find all cards illustrated by Stephen Daniel--><table>cards</table>",
        "<!--Find all cards illustrated by Stephen Daniel--><column>cards.artist</column>",
        "<!--Find all cards illustrated by Stephen Daniel--><column>cards.id</column>",
        "<!--describe the text of the ruling of these cards--><table>rulings</table>",
        "<!--describe the text of the ruling of these cards--><column>rulings.text</column>",
        "<!--join cards and rulings--><column>cards.uuid</column>",
        "<!--join cards and rulings--><column>rulings.uuid</column>",
        "<!--State if these cards have missing or degraded properties and values--><column>cards.hasContentWarning</column>",
        "<!--card id--><output_schema>integer</output_schema>",
        "<!--ruling text--><output_schema>text</output_schema>",
        "<!--has content warning--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 349,
      "db_id": "card_games",
      "question": "Name the card and artist with the most ruling information. Also state if the card is a promotional printing.",
      "evidence": "with the most ruling information refers to Max(count(rulings.uuid)); the card is the promotional printing refers to isPromo = 1;",
      "SQL": "SELECT T1.name, T1.artist, T1.isPromo FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.isPromo = 1 AND T1.artist = (SELECT artist FROM cards WHERE isPromo = 1 GROUP BY artist HAVING COUNT(DISTINCT uuid) = (SELECT MAX(count_uuid) FROM ( SELECT COUNT(DISTINCT uuid) AS count_uuid FROM cards WHERE isPromo = 1 GROUP BY artist ))) LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["cards", "rulings"],
        "columns": [
          "cards.uuid",
          "cards.isPromo",
          "cards.artist",
          "cards.name",
          "rulings.uuid"
        ],
        "output_schema": ["text", "text", "integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains card information including name, artist, and promotional status\">cards</table>",
        "<table purpose=\"Contains ruling information for cards\">rulings</table>",
        "<column purpose=\"join: links cards to rulings\">cards.uuid</column>",
        "<column purpose=\"filter: identifies promotional cards\">cards.isPromo</column>",
        "<column purpose=\"output: artist of the card\">cards.artist</column>",
        "<column purpose=\"output: name of the card\">cards.name</column>",
        "<column purpose=\"join: links rulings to cards\">rulings.uuid</column>",
        "<output_schema purpose=\"name of the card\">text</output_schema>",
        "<output_schema purpose=\"artist of the card\">text</output_schema>",
        "<output_schema purpose=\"promotional status of the card\">integer</output_schema>",
        "<warning>The proposal is missing a COUNT or GROUP BY operation to determine the card with the most ruling information.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for card name and artist--><table>cards</table>",
        "<!--Required for counting rulings--><table>rulings</table>",
        "<!--Join cards and rulings--><column>cards.uuid</column>",
        "<!--Join cards and rulings--><column>rulings.uuid</column>",
        "<!--Name of the card--><column>cards.name</column>",
        "<!--Artist of the card--><column>cards.artist</column>",
        "<!--Check if card is promotional--><column>cards.isPromo</column>",
        "<!--Name of the card--><output_schema>text</output_schema>",
        "<!--Artist of the card--><output_schema>text</output_schema>",
        "<!--If the card is promotional--><output_schema>integer</output_schema>",
        "<!--Number of rulings (for verification)--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 352,
      "db_id": "card_games",
      "question": "Calculate the percentage of the cards availabe in Chinese Simplified.",
      "evidence": "Chinese Simplified' is the language; percentage = Divide(Sum(id where language = 'Chinese Simplified'), Count(id)) *100",
      "SQL": "SELECT CAST(SUM(CASE WHEN T2.language = 'Chinese Simplified' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["cards", "foreign_data"],
        "columns": [
          "foreign_data.language",
          "cards.id",
          "cards.uuid",
          "foreign_data.uuid"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for counting total cards\">cards</table>",
        "<table purpose=\"Contains language information for card translations\">foreign_data</table>",
        "<column purpose=\"filter: 'Chinese Simplified'\">foreign_data.language</column>",
        "<column purpose=\"calculate: total number of cards\">cards.id</column>",
        "<column purpose=\"join: cards.uuid\">cards.uuid</column>",
        "<column purpose=\"join: foreign_data.uuid\">foreign_data.uuid</column>",
        "<output_schema purpose=\"percentage calculation result\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for card count and Chinese Simplified translations--><table>foreign_data</table>",
        "<!--Used to filter for Chinese Simplified translations--><column>foreign_data.language</column>",
        "<!--Used to count total entries and Chinese Simplified entries--><column>foreign_data.id</column>",
        "<!--Percentage of cards available in Chinese Simplified--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 356,
      "db_id": "card_games",
      "question": "How many cards have infinite power?",
      "evidence": "infinite power refers to power = '*';",
      "SQL": "SELECT COUNT(*) FROM cards WHERE power = '*'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["cards"],
        "columns": ["cards.power"],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains card information, including power\">cards</table>",
        "<column purpose=\"filter: 'infinite power refers to power = '*''\">cards.power</column>",
        "<output_schema purpose=\"count of cards with infinite power\">integer</output_schema>",
        "<warning>The query uses '*' to represent infinite power, but the question states that infinite power refers to power = '*'. This might lead to incorrect results if there are cards with actual '*' as power that are not considered infinite.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'cards have infinite power'--><table>cards</table>",
        "<!--filter: 'infinite power'--><column>cards.power</column>",
        "<!--count: 'How many cards'--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 358,
      "db_id": "card_games",
      "question": "What is the border color of card \"Ancestor's Chosen\"?",
      "evidence": "name of card  = 'Ancestor''s Chosen' ;",
      "SQL": "SELECT DISTINCT borderColor FROM cards WHERE name = 'Ancestor''s Chosen'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["cards"],
        "columns": ["cards.borderColor", "cards.name"],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains card information, including border color and name\">cards</table>",
        "<column purpose=\"filter: 'name of card = Ancestor''s Chosen'\">cards.name</column>",
        "<column purpose=\"retrieve: 'What is the border color'\">cards.borderColor</column>",
        "<output_schema purpose=\"border color of the card\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for card information--><table>cards</table>",
        "<!--Filter: 'name of card  = 'Ancestor''s Chosen''--><column>cards.name</column>",
        "<!--Requested: 'border color of card'--><column>cards.borderColor</column>",
        "<!--Border color of the specific card--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 366,
      "db_id": "card_games",
      "question": "What is the rule of playing card \"Benalish Knight\"?",
      "evidence": "Benalish Knight' is the name of card; rule of playing card refers to format;",
      "SQL": "SELECT T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Benalish Knight'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["cards", "legalities"],
        "columns": [
          "legalities.format",
          "cards.uuid",
          "legalities.uuid",
          "cards.name"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains card information, including name\">cards</table>",
        "<table purpose=\"Contains legality information for different formats\">legalities</table>",
        "<column purpose=\"Output: shows the format of play\">legalities.format</column>",
        "<column purpose=\"Join: links cards to legalities\">cards.uuid</column>",
        "<column purpose=\"Join: links legalities to cards\">legalities.uuid</column>",
        "<column purpose=\"Filter: to find 'Benalish Knight'\">cards.name</column>",
        "<output_schema purpose=\"Format of play for 'Benalish Knight'\">text</output_schema>",
        "<warning>The query might return multiple rows if 'Benalish Knight' is legal in multiple formats. Consider adding legalities.status to the output to show the legal status in each format.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for card information--><table>cards</table>",
        "<!--Required for legality information--><table>legalities</table>",
        "<!--Filter: 'Benalish Knight'--><column>cards.name</column>",
        "<!--Join: cards.uuid--><column>cards.uuid</column>",
        "<!--Join: legalities.uuid--><column>legalities.uuid</column>",
        "<!--'rule of playing card refers to format'--><column>legalities.format</column>",
        "<!--'rule of playing card refers to format'--><column>legalities.status</column>",
        "<!--Format name--><output_schema>text</output_schema>",
        "<!--Legal status in the format--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 368,
      "db_id": "card_games",
      "question": "What is the percentage of borderless cards?",
      "evidence": "borderless card refers to borderColor = 'borderless'; percentage = Divide(Count (id) where borderColor = 'borderless', Count(id)) *100",
      "SQL": "SELECT CAST(SUM(CASE WHEN borderColor = 'borderless' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["cards"],
        "columns": ["cards.borderColor", "cards.id"],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for counting cards and filtering by borderColor\">cards</table>",
        "<column purpose=\"filter: 'borderless card refers to borderColor = 'borderless''\">cards.borderColor</column>",
        "<column purpose=\"calculate: used in COUNT(id) for total number of cards\">cards.id</column>",
        "<output_schema purpose=\"percentage calculation result\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'percentage of borderless cards'--><table>cards</table>",
        "<!--filter: 'borderless card refers to borderColor = 'borderless''--><column>cards.borderColor</column>",
        "<!--count: 'Count (id) where borderColor = 'borderless''--><column>cards.id</column>",
        "<!--percentage of borderless cards--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 371,
      "db_id": "card_games",
      "question": "What is the percentage of cards whose language is French among the Story Spotlight cards?",
      "evidence": "Story Spotlight card refers to isStorySpotlight = 1; French is the language; Percentage = Divide(Count(id) where language = 'French' and isStorySpotlight = 1, Count(id) where isStorySpotlight = 1)*100",
      "SQL": "SELECT CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.isStorySpotlight = 1",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["cards", "foreign_data"],
        "columns": [
          "foreign_data.language",
          "cards.id",
          "cards.uuid",
          "foreign_data.uuid",
          "cards.isStorySpotlight"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for Story Spotlight cards and joining with foreign_data\">cards</table>",
        "<table purpose=\"Required for language information\">foreign_data</table>",
        "<column purpose=\"filter: 'French'\">foreign_data.language</column>",
        "<column purpose=\"count: total Story Spotlight cards\">cards.id</column>",
        "<column purpose=\"join: cards.uuid\">cards.uuid</column>",
        "<column purpose=\"join: foreign_data.uuid\">foreign_data.uuid</column>",
        "<column purpose=\"filter: 'Story Spotlight card refers to isStorySpotlight = 1'\">cards.isStorySpotlight</column>",
        "<output_schema purpose=\"percentage calculation result\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for Story Spotlight cards--><table>cards</table>",
        "<!--Required for French language data--><table>foreign_data</table>",
        "<!--Filter for Story Spotlight cards--><column>cards.isStorySpotlight</column>",
        "<!--Join cards with foreign_data--><column>cards.uuid</column>",
        "<!--Join foreign_data with cards--><column>foreign_data.uuid</column>",
        "<!--Filter for French language--><column>foreign_data.language</column>",
        "<!--Count of French Story Spotlight cards--><output_schema>integer</output_schema>",
        "<!--Total count of Story Spotlight cards--><output_schema>integer</output_schema>",
        "<!--Percentage of French Story Spotlight cards--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 377,
      "db_id": "card_games",
      "question": "How many cards with original type of \"Summon - Angel\" have subtype other than \"Angel\"?",
      "evidence": "subtype other than Angel refers to subtypes is not 'Angel';",
      "SQL": "SELECT COUNT(id) FROM cards WHERE originalType = 'Summon - Angel' AND subtypes != 'Angel'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["cards"],
        "columns": ["cards.id", "cards.originalType", "cards.subtypes"],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains card information including original type and subtypes\">cards</table>",
        "<column purpose=\"Used for counting unique cards\">cards.id</column>",
        "<column purpose=\"Filter: 'original type of 'Summon - Angel''\">cards.originalType</column>",
        "<column purpose=\"Filter: 'subtype other than 'Angel''\">cards.subtypes</column>",
        "<output_schema purpose=\"Count of cards meeting the criteria\">integer</output_schema>",
        "<warning>The proposed SQL query uses '!=' for comparing subtypes, which may not work as intended. The 'subtypes' column likely contains a list of subtypes, so a direct comparison with '!=' might not correctly identify cards with subtypes other than 'Angel'.</warning>",
        "<warning>The query should use a more appropriate method to check if 'Angel' is not the only subtype, such as using the LIKE operator or a combination of conditions.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'cards with original type of \"Summon - Angel\"'--><table>cards</table>",
        "<!--Filter: 'original type of \"Summon - Angel\"'--><column>cards.originalType</column>",
        "<!--Filter: 'subtype other than \"Angel\"'--><column>cards.subtypes</column>",
        "<!--Count of cards meeting the criteria--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 379,
      "db_id": "card_games",
      "question": "What are the cards belong to duel deck a? List the ID.",
      "evidence": "duel deck a refers to duelDeck = a;",
      "SQL": "SELECT id FROM cards WHERE duelDeck = 'a'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["cards"],
        "columns": ["cards.id", "cards.duelDeck"],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for querying card information\">cards</table>",
        "<column purpose=\"output: 'List the ID'\">cards.id</column>",
        "<column purpose=\"filter: 'duel deck a refers to duelDeck = a'\">cards.duelDeck</column>",
        "<output_schema purpose=\"ID of cards in duel deck a\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'cards belong to duel deck a'--><table>cards</table>",
        "<!--filter: 'duel deck a refers to duelDeck = a'--><column>cards.duelDeck</column>",
        "<!--List the ID--><column>cards.id</column>",
        "<!--List the ID--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 383,
      "db_id": "card_games",
      "question": "How many of the banned cards are white border?",
      "evidence": "banned card refers to status = 'Banned'; white border refers to borderColor = 'white';",
      "SQL": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Banned' AND T1.borderColor = 'white'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["cards", "legalities"],
        "columns": [
          "cards.id",
          "cards.uuid",
          "legalities.uuid",
          "legalities.status",
          "cards.borderColor"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains card information including border color\">cards</table>",
        "<table purpose=\"Contains legality information for cards\">legalities</table>",
        "<column purpose=\"Used for counting banned white border cards\">cards.id</column>",
        "<column purpose=\"join: legalities.uuid\">cards.uuid</column>",
        "<column purpose=\"join: cards.uuid\">legalities.uuid</column>",
        "<column purpose=\"filter: status = 'Banned'\">legalities.status</column>",
        "<column purpose=\"filter: borderColor = 'white'\">cards.borderColor</column>",
        "<output_schema purpose=\"Count of banned white border cards\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'banned cards'--><table>legalities</table>",
        "<!--Required for 'white border'--><table>cards</table>",
        "<!--filter: 'banned cards'--><column>legalities.status</column>",
        "<!--filter: 'white border'--><column>cards.borderColor</column>",
        "<!--join: legalities.uuid--><column>cards.uuid</column>",
        "<!--join: cards.uuid--><column>legalities.uuid</column>",
        "<!--count of banned white border cards--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 391,
      "db_id": "card_games",
      "question": "Among the Artifact cards, which are black color and comes with foreign languague translation?",
      "evidence": "Artifact card refers to originalType = 'Artifact'; black color refers to colors = 'B'; foreign language refers to language in foreign_data",
      "SQL": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Artifact' AND T1.colors = 'B'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["cards", "foreign_data"],
        "columns": [
          "cards.name",
          "cards.uuid",
          "foreign_data.uuid",
          "cards.colors",
          "cards.originalType"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for Artifact cards and black color information\">cards</table>",
        "<table purpose=\"Required for foreign language translations\">foreign_data</table>",
        "<column purpose=\"output: name of the Artifact cards\">cards.name</column>",
        "<column purpose=\"join: cards.uuid\">cards.uuid</column>",
        "<column purpose=\"join: foreign_data.uuid\">foreign_data.uuid</column>",
        "<column purpose=\"filter: 'black color'\">cards.colors</column>",
        "<column purpose=\"filter: 'Artifact cards'\">cards.originalType</column>",
        "<output_schema purpose=\"name of the Artifact cards\">text</output_schema>",
        "<warning>The proposal is missing foreign_data.language column, which is needed to confirm the existence of foreign language translations.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Artifact cards'--><table>cards</table>",
        "<!--Required for 'foreign language translation'--><table>foreign_data</table>",
        "<!--filter: 'Artifact cards'--><column>cards.originalType</column>",
        "<!--filter: 'black color'--><column>cards.colors</column>",
        "<!--join: cards.uuid--><column>cards.uuid</column>",
        "<!--join: foreign_data.uuid--><column>foreign_data.uuid</column>",
        "<!--foreign language information--><column>foreign_data.language</column>",
        "<!--Artifact card names--><output_schema>text</output_schema>",
        "<!--Foreign language translations--><output_schema>text</output_schema>",
        "<!--Languages of translations--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 397,
      "db_id": "card_games",
      "question": "What is the mana cost of cards with a normal layout, a 2003 frame version, with a black border color, and available in paper and mtgo?",
      "evidence": "available in paper and mtgo refers to availability = 'mtgo,paper'; frameVersion = 2003;borderColor = 'black'",
      "SQL": "SELECT manaCost FROM cards WHERE availability = 'mtgo,paper' AND borderColor = 'black' AND frameVersion = 2003 AND layout = 'normal'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["cards"],
        "columns": [
          "cards.manaCost",
          "cards.availability",
          "cards.borderColor",
          "cards.frameVersion",
          "cards.layout"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for all card information\">cards</table>",
        "<column purpose=\"calculate: 'mana cost of cards'\">cards.manaCost</column>",
        "<column purpose=\"filter: 'available in paper and mtgo'\">cards.availability</column>",
        "<column purpose=\"filter: 'black border color'\">cards.borderColor</column>",
        "<column purpose=\"filter: '2003 frame version'\">cards.frameVersion</column>",
        "<column purpose=\"filter: 'normal layout'\">cards.layout</column>",
        "<output_schema purpose=\"mana cost of cards\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'mana cost'--><table>cards</table>",
        "<!--filter: 'normal layout'--><column>cards.layout</column>",
        "<!--filter: '2003 frame version'--><column>cards.frameVersion</column>",
        "<!--filter: 'black border color'--><column>cards.borderColor</column>",
        "<!--filter: 'available in paper and mtgo'--><column>cards.availability</column>",
        "<!--output: 'mana cost'--><column>cards.manaCost</column>",
        "<!--mana cost of cards meeting criteria--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 402,
      "db_id": "card_games",
      "question": "What is the percentage of Story Spotlight cards that do not have a text box? List them by their ID.",
      "evidence": "Story Spotlight cards that do not have a text box refers to isStorylight = 1 and isTextless = 0; Percentage = DIVIDE(SUM(count(id) where isStorylight = 1 AND isTextless = 0 ), SUM(count(id))) * 100",
      "SQL": "SELECT CAST(SUM(CASE WHEN isTextless = 0 AND  isStorySpotlight = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["cards"],
        "columns": ["cards.isStorySpotlight", "cards.isTextless", "cards.id"],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains the required information about Story Spotlight cards and their text box status\">cards</table>",
        "<column purpose=\"filter: Story Spotlight cards (isStorySpotlight = 1)\">cards.isStorySpotlight</column>",
        "<column purpose=\"filter: cards without a text box (isTextless = 0)\">cards.isTextless</column>",
        "<column purpose=\"calculate: count of cards meeting the criteria\">cards.id</column>",
        "<output_schema purpose=\"percentage calculation result\">real</output_schema>",
        "<warning>The proposal is missing a COUNT or SUM aggregation for the calculation. The SQL query should include these to properly calculate the percentage.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Story Spotlight cards'--><table>cards</table>",
        "<!--filter: 'Story Spotlight cards'--><column>cards.isStorySpotlight</column>",
        "<!--filter: 'do not have a text box'--><column>cards.isTextless</column>",
        "<!--calculate: 'percentage'--><column>cards.id</column>",
        "<!--output: 'List them by their ID'--><output_schema>integer</output_schema>",
        "<!--output: 'percentage'--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 405,
      "db_id": "card_games",
      "question": "How many Brazilian Portuguese translated sets are inside the Commander block?",
      "evidence": "Commander block refer to block = 'Commander'; sets refer to code = setCode; Portuguese refer to language = 'Portuguese (Brasil)'",
      "SQL": "SELECT COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Portuguese (Brazil)' AND T1.block = 'Commander'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["sets", "set_translations"],
        "columns": [
          "sets.id",
          "sets.code",
          "set_translations.setCode",
          "set_translations.language",
          "sets.block"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'Commander block' and set information\">sets</table>",
        "<table purpose=\"Required for translations of set names\">set_translations</table>",
        "<column purpose=\"join: sets.code = set_translations.setCode\">sets.code</column>",
        "<column purpose=\"join: set_translations.setCode = sets.code\">set_translations.setCode</column>",
        "<column purpose=\"filter: 'Portuguese (Brazil)'\">set_translations.language</column>",
        "<column purpose=\"filter: 'Commander block'\">sets.block</column>",
        "<warning>sets.id is not necessary for this query as we're only counting the number of sets</warning>",
        "<error>Missing COUNT(*) or COUNT(some_column) in the output schema</error>",
        "<output_schema purpose=\"count of Brazilian Portuguese translated Commander sets\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Commander block'--><table>sets</table>",
        "<!--Required for 'Brazilian Portuguese translated sets'--><table>set_translations</table>",
        "<!--Filter: 'Commander block'--><column>sets.block</column>",
        "<!--Join: sets.code to set_translations.setCode--><column>sets.code</column>",
        "<!--Join: set_translations.setCode to sets.code--><column>set_translations.setCode</column>",
        "<!--Filter: 'Portuguese (Brasil)'--><column>set_translations.language</column>",
        "<!--Count of Brazilian Portuguese translated Commander sets--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 407,
      "db_id": "card_games",
      "question": "Lists all types of cards in German.",
      "evidence": "German refer to language; all types refer to the subtypes, supertypes; subtypes is not null AND supertypes is not null",
      "SQL": "SELECT T1.subtypes, T1.supertypes FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'German' AND T1.subtypes IS NOT NULL AND T1.supertypes IS NOT NULL",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["cards", "foreign_data"],
        "columns": [
          "cards.subtypes",
          "cards.supertypes",
          "cards.uuid",
          "foreign_data.uuid",
          "foreign_data.language"
        ],
        "output_schema": ["text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for card types (subtypes and supertypes)\">cards</table>",
        "<table purpose=\"Required for language information\">foreign_data</table>",
        "<column purpose=\"output: 'all types refer to the subtypes'\">cards.subtypes</column>",
        "<column purpose=\"output: 'all types refer to the supertypes'\">cards.supertypes</column>",
        "<column purpose=\"join: foreign_data.uuid\">cards.uuid</column>",
        "<column purpose=\"join: cards.uuid\">foreign_data.uuid</column>",
        "<column purpose=\"filter: 'German refer to language'\">foreign_data.language</column>",
        "<output_schema purpose=\"subtypes of cards\">text</output_schema>",
        "<output_schema purpose=\"supertypes of cards\">text</output_schema>",
        "<warning>The proposal does not include a way to filter for non-null subtypes and supertypes as specified in the question.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'all types of cards'--><table>cards</table>",
        "<!--Required for 'in German'--><table>foreign_data</table>",
        "<!--join: cards.uuid--><column>foreign_data.uuid</column>",
        "<!--join: foreign_data.uuid--><column>cards.uuid</column>",
        "<!--filter: 'in German'--><column>foreign_data.language</column>",
        "<!--filter: 'subtypes is not null'--><column>cards.subtypes</column>",
        "<!--filter: 'supertypes is not null'--><column>cards.supertypes</column>",
        "<!--output: 'all types of cards in German'--><column>foreign_data.type</column>",
        "<!--list of all types in German--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 408,
      "db_id": "card_games",
      "question": "How many unknown power cards contain info about the triggered ability",
      "evidence": "unknown power cards refers to power is null or power = '*';contain info about the triggered ability refers to text contains 'triggered ability'",
      "SQL": "SELECT Count(DISTINCT T1.id) FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE (T1.power IS NULL OR T1.power = '*') AND T2.text LIKE '%triggered ability%'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["cards", "rulings"],
        "columns": [
          "cards.id",
          "cards.uuid",
          "rulings.uuid",
          "rulings.text",
          "cards.power"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains card information, including power\">cards</table>",
        "<table purpose=\"Contains rulings information, including triggered ability details\">rulings</table>",
        "<column purpose=\"Used for counting distinct cards\">cards.id</column>",
        "<column purpose=\"Join key with rulings table\">cards.uuid</column>",
        "<column purpose=\"Join key with cards table\">rulings.uuid</column>",
        "<column purpose=\"Filter: contains 'triggered ability'\">rulings.text</column>",
        "<column purpose=\"Filter: is NULL or '*'\">cards.power</column>",
        "<output_schema purpose=\"Count of distinct cards meeting the criteria\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'unknown power cards'--><table>cards</table>",
        "<!--filter: 'power is null or power = '*''--><column>cards.power</column>",
        "<!--filter: 'text contains 'triggered ability''--><column>cards.text</column>",
        "<!--count of cards meeting criteria--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 409,
      "db_id": "card_games",
      "question": "Indicates the number of cards with pre-modern format, ruling text \"This is a triggered mana ability.\" that do not have multiple faces.",
      "evidence": "pre-modern format refers to format = 'premodern' ;do not have multiple faces refers to side IS NULL",
      "SQL": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid INNER JOIN rulings AS T3 ON T1.uuid = T3.uuid WHERE T2.format = 'premodern' AND T3.text = 'This is a triggered mana ability.' AND T1.Side IS NULL",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["cards", "legalities", "rulings"],
        "columns": [
          "cards.id",
          "cards.uuid",
          "legalities.uuid",
          "legalities.format",
          "rulings.uuid",
          "rulings.text",
          "cards.side"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for card information and to check for multiple faces\">cards</table>",
        "<table purpose=\"Required to filter cards by 'premodern' format\">legalities</table>",
        "<table purpose=\"Required to check for specific ruling text\">rulings</table>",
        "<column purpose=\"Used for counting cards\">cards.id</column>",
        "<column purpose=\"join: legalities.uuid, rulings.uuid\">cards.uuid</column>",
        "<column purpose=\"join: cards.uuid\">legalities.uuid</column>",
        "<column purpose=\"filter: 'pre-modern format'\">legalities.format</column>",
        "<column purpose=\"join: cards.uuid\">rulings.uuid</column>",
        "<column purpose=\"filter: 'This is a triggered mana ability.'\">rulings.text</column>",
        "<column purpose=\"filter: 'do not have multiple faces'\">cards.side</column>",
        "<output_schema purpose=\"count of cards meeting the criteria\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'pre-modern format'--><table>legalities</table>",
        "<!--Required for 'ruling text'--><table>rulings</table>",
        "<!--Required for 'do not have multiple faces'--><table>cards</table>",
        "<!--filter: 'pre-modern format'--><column>legalities.format</column>",
        "<!--filter: 'pre-modern format'--><column>legalities.status</column>",
        "<!--filter: 'ruling text \"This is a triggered mana ability.\"'--><column>rulings.text</column>",
        "<!--filter: 'do not have multiple faces'--><column>cards.side</column>",
        "<!--join: legalities.uuid--><column>cards.uuid</column>",
        "<!--join: rulings.uuid--><column>cards.uuid</column>",
        "<!--number of cards--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 412,
      "db_id": "card_games",
      "question": "What is the foreign name of the card in French of type Creature, normal layout and black border color, by artist Matthew D. Wilson?",
      "evidence": "in French refers to language = 'French'; black border color refers to borderColor = 'black'",
      "SQL": "SELECT name FROM foreign_data WHERE uuid IN ( SELECT uuid FROM cards WHERE types = 'Creature' AND layout = 'normal' AND borderColor = 'black' AND artist = 'Matthew D. Wilson' ) AND language = 'French'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["foreign_data", "cards"],
        "columns": [
          "cards.uuid",
          "cards.artist",
          "cards.borderColor",
          "cards.layout",
          "cards.types",
          "foreign_data.name",
          "foreign_data.language",
          "foreign_data.uuid"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains foreign language card data\">foreign_data</table>",
        "<table purpose=\"Contains main card data\">cards</table>",
        "<column purpose=\"join: foreign_data.uuid\">cards.uuid</column>",
        "<column purpose=\"filter: 'by artist Matthew D. Wilson'\">cards.artist</column>",
        "<column purpose=\"filter: 'black border color'\">cards.borderColor</column>",
        "<column purpose=\"filter: 'normal layout'\">cards.layout</column>",
        "<column purpose=\"filter: 'type Creature'\">cards.types</column>",
        "<column purpose=\"output: 'foreign name of the card'\">foreign_data.name</column>",
        "<column purpose=\"filter: 'in French'\">foreign_data.language</column>",
        "<column purpose=\"join: cards.uuid\">foreign_data.uuid</column>",
        "<output_schema purpose=\"foreign name of the card\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'type Creature'--><table>cards</table>",
        "<!--Required for 'normal layout'--><column>cards.layout</column>",
        "<!--Required for 'black border color'--><column>cards.borderColor</column>",
        "<!--Required for 'by artist Matthew D. Wilson'--><column>cards.artist</column>",
        "<!--Required for 'foreign name of the card in French'--><table>foreign_data</table>",
        "<!--Required for 'foreign name of the card in French'--><column>foreign_data.language</column>",
        "<!--Required for 'foreign name of the card in French'--><column>foreign_data.name</column>",
        "<!--Join cards and foreign_data tables--><column>cards.uuid</column>",
        "<!--Join cards and foreign_data tables--><column>foreign_data.uuid</column>",
        "<!--Required for 'type Creature'--><column>cards.types</column>",
        "<!--Foreign name of the card in French--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 414,
      "db_id": "card_games",
      "question": "What language is the set of 180 cards that belongs to the Ravnica block translated into?",
      "evidence": "set of 180 cards refers to baseSetSize = 180",
      "SQL": "SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.block = 'Ravnica' AND T1.baseSetSize = 180",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["sets", "set_translations"],
        "columns": [
          "set_translations.language",
          "sets.code",
          "set_translations.setCode",
          "sets.baseSetSize",
          "sets.block"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains set information, including block and baseSetSize\">sets</table>",
        "<table purpose=\"Contains translations of set names\">set_translations</table>",
        "<column purpose=\"Output: language of the translation\">set_translations.language</column>",
        "<column purpose=\"Join: link sets to set_translations\">sets.code</column>",
        "<column purpose=\"Join: link set_translations to sets\">set_translations.setCode</column>",
        "<column purpose=\"Filter: 'set of 180 cards'\">sets.baseSetSize</column>",
        "<column purpose=\"Filter: 'belongs to the Ravnica block'\">sets.block</column>",
        "<output_schema purpose=\"Language of the translation\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'set of 180 cards'--><table>sets</table>",
        "<!--Required for translations--><table>set_translations</table>",
        "<!--Filter: 'set of 180 cards'--><column>sets.baseSetSize</column>",
        "<!--Filter: 'belongs to the Ravnica block'--><column>sets.block</column>",
        "<!--Join: sets.code--><column>set_translations.setCode</column>",
        "<!--Required for 'language'--><column>set_translations.language</column>",
        "<!--Language of translation--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 415,
      "db_id": "card_games",
      "question": "What percentage of cards with format commander and legal status do not have a content warning?",
      "evidence": "do not have a content warning refers to hasContentWarning = 0; percentage refers to DIVIDE(COUNT(hasContentWarning = 0),COUNT(ID))*100 where format = 'commander' AND Status = 'legal';",
      "SQL": "SELECT CAST(SUM(CASE WHEN T1.hasContentWarning = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'commander' AND T2.status = 'Legal'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["cards", "legalities"],
        "columns": [
          "cards.hasContentWarning",
          "cards.id",
          "cards.uuid",
          "legalities.uuid",
          "legalities.format",
          "legalities.status"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains card information including content warning status\">cards</table>",
        "<table purpose=\"Contains legality information for different formats\">legalities</table>",
        "<column purpose=\"filter: 'do not have a content warning refers to hasContentWarning = 0'\">cards.hasContentWarning</column>",
        "<column purpose=\"calculate: used in COUNT(ID) for percentage calculation\">cards.id</column>",
        "<column purpose=\"join: cards.uuid\">cards.uuid</column>",
        "<column purpose=\"join: legalities.uuid\">legalities.uuid</column>",
        "<column purpose=\"filter: 'format = 'commander''\">legalities.format</column>",
        "<column purpose=\"filter: 'Status = 'legal''\">legalities.status</column>",
        "<output_schema purpose=\"percentage calculation result\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'format commander and legal status'--><table>legalities</table>",
        "<!--Required for 'hasContentWarning'--><table>cards</table>",
        "<!--filter: 'format commander'--><column>legalities.format</column>",
        "<!--filter: 'legal status'--><column>legalities.status</column>",
        "<!--join: cards.uuid--><column>legalities.uuid</column>",
        "<!--join: legalities.uuid--><column>cards.uuid</column>",
        "<!--filter: 'do not have a content warning'--><column>cards.hasContentWarning</column>",
        "<!--calculate: 'percentage'--><column>cards.id</column>",
        "<!--percentage of cards without content warning--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 416,
      "db_id": "card_games",
      "question": "What percentage of cards without power are in French?",
      "evidence": "in French refers to language = 'French'; cards without power refers to power IS NULL OR power = '*'; percentage = DIVIDE(COUNT(language = 'French' and power is NULL or power = '*'), COUNT( power is NULL or power = '*'))*100",
      "SQL": "SELECT CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.power IS NULL OR T1.power = '*'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["cards", "foreign_data"],
        "columns": [
          "foreign_data.language",
          "cards.id",
          "cards.uuid",
          "foreign_data.uuid",
          "cards.power"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for card information and power data\">cards</table>",
        "<table purpose=\"Required for language information\">foreign_data</table>",
        "<column purpose=\"filter: 'in French'\">foreign_data.language</column>",
        "<column purpose=\"calculate: count of cards\">cards.id</column>",
        "<column purpose=\"join: cards.uuid\">cards.uuid</column>",
        "<column purpose=\"join: foreign_data.uuid\">foreign_data.uuid</column>",
        "<column purpose=\"filter: 'cards without power'\">cards.power</column>",
        "<output_schema purpose=\"percentage calculation result\">real</output_schema>",
        "<warning>The query might double count cards if there are multiple foreign language versions for a single card. Consider using DISTINCT or grouping by cards.uuid to avoid this.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'cards without power'--><table>cards</table>",
        "<!--Required for 'in French'--><table>foreign_data</table>",
        "<!--filter: 'cards without power'--><column>cards.power</column>",
        "<!--join: cards.uuid--><column>cards.uuid</column>",
        "<!--join: foreign_data.uuid--><column>foreign_data.uuid</column>",
        "<!--filter: 'in French'--><column>foreign_data.language</column>",
        "<!--percentage of cards without power in French--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 422,
      "db_id": "card_games",
      "question": "What is the language of the card with the multiverse number 149934?",
      "evidence": "multiverse number 149934 refers to multiverseid = 149934;",
      "SQL": "SELECT language FROM foreign_data WHERE multiverseid = 149934",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["foreign_data"],
        "columns": ["foreign_data.language", "foreign_data.multiverseid"],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains information about Magic: The Gathering cards in various foreign languages\">foreign_data</table>",
        "<column purpose=\"filter: 'multiverse number 149934'\">foreign_data.multiverseid</column>",
        "<column purpose=\"output: 'What is the language of the card'\">foreign_data.language</column>",
        "<output_schema purpose=\"language of the card\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'language of the card'--><table>foreign_data</table>",
        "<!--filter: 'with the multiverse number 149934'--><column>foreign_data.multiverseid</column>",
        "<!--retrieve: 'language of the card'--><column>foreign_data.language</column>",
        "<!--language of the card--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 424,
      "db_id": "card_games",
      "question": "What proportion of cards do not have a text box with a normal layout?",
      "evidence": "do not have a text box refers to isTextless = 1; proportion refers to DIVIDE(COUNT(Textless = 1 and layout = 'normal'),COUNT(Textless))*100",
      "SQL": "SELECT CAST(SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM cards",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["cards"],
        "columns": ["cards.isTextless", "cards.layout"],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for counting cards and checking their properties\">cards</table>",
        "<column purpose=\"filter: 'do not have a text box refers to isTextless = 1'\">cards.isTextless</column>",
        "<column purpose=\"filter: 'with a normal layout'\">cards.layout</column>",
        "<output_schema purpose=\"proportion as a percentage\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'cards do not have a text box'--><table>cards</table>",
        "<!--filter: 'do not have a text box'--><column>cards.isTextless</column>",
        "<!--filter: 'with a normal layout'--><column>cards.layout</column>",
        "<!--calculate: 'proportion'--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 427,
      "db_id": "card_games",
      "question": "What languages are available in the set known as Archenemy on the magic card market and having the code ARC?",
      "evidence": "known as Archenemy refers to mcmName = 'Archenemy'; having the code ARC refers to setCode = 'ARC'",
      "SQL": "SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.mcmName = 'Archenemy' AND T2.setCode = 'ARC'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["sets", "set_translations"],
        "columns": [
          "set_translations.language",
          "sets.code",
          "set_translations.setCode",
          "sets.mcmName"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains information about the Archenemy set\">sets</table>",
        "<table purpose=\"Contains translations of set names in various languages\">set_translations</table>",
        "<column purpose=\"Output: languages available for the Archenemy set\">set_translations.language</column>",
        "<column purpose=\"Join: to connect sets with set_translations\">sets.code</column>",
        "<column purpose=\"Join: to connect sets with set_translations; Filter: 'having the code ARC'\">set_translations.setCode</column>",
        "<column purpose=\"Filter: 'known as Archenemy on the magic card market'\">sets.mcmName</column>",
        "<output_schema purpose=\"Language of the set translation\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'set known as Archenemy on the magic card market'--><table>sets</table>",
        "<!--Required for 'having the code ARC'--><table>sets</table>",
        "<!--Required for language translations--><table>set_translations</table>",
        "<!--Filter: 'known as Archenemy on the magic card market'--><column>sets.mcmName</column>",
        "<!--Filter: 'having the code ARC'--><column>sets.code</column>",
        "<!--Join: sets.code to set_translations.setCode--><column>set_translations.setCode</column>",
        "<!--Required for 'What languages are available'--><column>set_translations.language</column>",
        "<!--Languages available for the set--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 440,
      "db_id": "card_games",
      "question": "Which foreign language used by \"A Pedra Fellwar\"?",
      "evidence": "\"A Pedra Fellwar\" refers to name = 'A Pedra Fellwar'",
      "SQL": "SELECT DISTINCT language FROM foreign_data WHERE name = 'A Pedra Fellwar'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["foreign_data"],
        "columns": ["foreign_data.language", "foreign_data.name"],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains foreign language card data, including translations\">foreign_data</table>",
        "<column purpose=\"filter: 'A Pedra Fellwar' refers to name = 'A Pedra Fellwar'\">foreign_data.name</column>",
        "<column purpose=\"output: 'Which foreign language used'\">foreign_data.language</column>",
        "<output_schema purpose=\"language is stored as text\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for foreign language information--><table>foreign_data</table>",
        "<!--Required to match the card name--><column>foreign_data.name</column>",
        "<!--Required to get the language--><column>foreign_data.language</column>",
        "<!--Foreign language used by \"A Pedra Fellwar\"--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 459,
      "db_id": "card_games",
      "question": "Which card costs more converted mana, \"Serra Angel\" or \"Shrine Keeper\"?",
      "evidence": "\"Serra Angel\" refers to name = 'Serra Angel'; \"Shrine Keeper\" refers to name = 'Shrine Keeper'; card costs more converted mana when the value of convertedManaCost is greater",
      "SQL": "SELECT name FROM cards WHERE name IN ('Serra Angel', 'Shrine Keeper') ORDER BY convertedManaCost DESC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["cards"],
        "columns": ["cards.name", "cards.convertedManaCost"],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains card information including name and converted mana cost\">cards</table>",
        "<column purpose=\"filter: 'Serra Angel' or 'Shrine Keeper'\">cards.name</column>",
        "<column purpose=\"calculate: 'costs more converted mana'\">cards.convertedManaCost</column>",
        "<output_schema purpose=\"Return the name of the card that costs more converted mana\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Serra Angel'--><table>cards</table>",
        "<!--Required for 'Shrine Keeper'--><table>cards</table>",
        "<!--filter: 'Serra Angel'--><column>cards.name</column>",
        "<!--filter: 'Shrine Keeper'--><column>cards.name</column>",
        "<!--compare: 'costs more converted mana'--><column>cards.convertedManaCost</column>",
        "<!--name of the card that costs more--><output_schema>text</output_schema>",
        "<!--converted mana cost of the more expensive card--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 462,
      "db_id": "card_games",
      "question": "What's the Italian name of the set of cards with \"Ancestor's Chosen\" is in?",
      "evidence": "Italian is a language which refers to language = 'Italian'; with \"Ancestor's Chosen\" in the card set refers to name = 'Ancestor''s Chosen'",
      "SQL": "SELECT translation FROM set_translations WHERE setCode IN ( SELECT setCode FROM cards WHERE name = 'Ancestor''s Chosen' ) AND language = 'Italian'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["set_translations", "cards"],
        "columns": [
          "cards.setCode",
          "cards.name",
          "set_translations.translation",
          "set_translations.language",
          "set_translations.setCode"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains set translations, including Italian names\">set_translations</table>",
        "<table purpose=\"Contains card information, including 'Ancestor's Chosen'\">cards</table>",
        "<column purpose=\"join: set_translations.setCode, filter: 'set of cards with 'Ancestor's Chosen''\">cards.setCode</column>",
        "<column purpose=\"filter: 'Ancestor's Chosen'\">cards.name</column>",
        "<column purpose=\"output: 'Italian name of the set'\">set_translations.translation</column>",
        "<column purpose=\"filter: 'Italian'\">set_translations.language</column>",
        "<column purpose=\"join: cards.setCode\">set_translations.setCode</column>",
        "<output_schema purpose=\"Italian name of the set\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for finding the set of \"Ancestor's Chosen\"--><table>cards</table>",
        "<!--Required for finding the Italian name of the set--><table>set_translations</table>",
        "<!--Required for joining cards and set_translations--><table>sets</table>",
        "<!--Filter for \"Ancestor's Chosen\"--><column>cards.name</column>",
        "<!--Join cards with sets--><column>cards.setCode</column>",
        "<!--Join sets with set_translations--><column>sets.code</column>",
        "<!--Join set_translations with sets--><column>set_translations.setCode</column>",
        "<!--Filter for Italian language--><column>set_translations.language</column>",
        "<!--Italian name of the set--><column>set_translations.translation</column>",
        "<!--Italian name of the set containing \"Ancestor's Chosen\"--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 465,
      "db_id": "card_games",
      "question": "For the set of cards with \"Ancestor's Chosen\" in it, is there a Korean version of it?",
      "evidence": "set of cards with \"Ancestor''s Chosen\" in it refers to name = 'Ancestor''s Chosen'; Korean version refers to language = 'Korean'",
      "SQL": "SELECT IIF(SUM(CASE WHEN T2.language = 'Korean' AND T2.translation IS NOT NULL THEN 1 ELSE 0 END) > 0, 'YES', 'NO') FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T1.name = 'Ancestor''s Chosen'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["cards", "set_translations"],
        "columns": [
          "set_translations.language",
          "set_translations.translation",
          "cards.setCode",
          "set_translations.setCode",
          "cards.name"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains card information, including 'Ancestor's Chosen'\">cards</table>",
        "<table purpose=\"Contains set translations, including Korean versions\">set_translations</table>",
        "<column purpose=\"filter: 'Korean version'\">set_translations.language</column>",
        "<column purpose=\"check if Korean translation exists\">set_translations.translation</column>",
        "<column purpose=\"join: set_translations.setCode\">cards.setCode</column>",
        "<column purpose=\"join: cards.setCode\">set_translations.setCode</column>",
        "<column purpose=\"filter: 'Ancestor's Chosen'\">cards.name</column>",
        "<output_schema purpose=\"YES/NO answer for Korean version existence\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for finding the set with \"Ancestor's Chosen\"--><table>cards</table>",
        "<!--Required for checking Korean version--><table>foreign_data</table>",
        "<!--Filter for \"Ancestor's Chosen\"--><column>cards.name</column>",
        "<!--Join cards with foreign_data--><column>cards.uuid</column>",
        "<!--Join foreign_data with cards--><column>foreign_data.uuid</column>",
        "<!--Filter for Korean version--><column>foreign_data.language</column>",
        "<!--Set code for the card--><column>cards.setCode</column>",
        "<!--Existence of Korean version--><output_schema>boolean</output_schema>"
      ]
    },
    {
      "question_id": 466,
      "db_id": "card_games",
      "question": "Among the cards in the set \"Hauptset Zehnte Edition\", how many of them are designed by Adam Rex?",
      "evidence": "card set \"Hauptset Zehnte Edition\" refers to translation = 'Hauptset Zehnte Edition'; designed by Adam refers to artist = 'Adam Rex'",
      "SQL": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T2.translation = 'Hauptset Zehnte Edition' AND T1.artist = 'Adam Rex'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["cards", "set_translations"],
        "columns": [
          "cards.id",
          "cards.setCode",
          "set_translations.setCode",
          "set_translations.translation",
          "cards.artist"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains card information, including artist\">cards</table>",
        "<table purpose=\"Contains set translations, needed for 'Hauptset Zehnte Edition'\">set_translations</table>",
        "<column purpose=\"Used for counting cards\">cards.id</column>",
        "<column purpose=\"join: set_translations.setCode\">cards.setCode</column>",
        "<column purpose=\"join: cards.setCode\">set_translations.setCode</column>",
        "<column purpose=\"filter: 'Hauptset Zehnte Edition'\">set_translations.translation</column>",
        "<column purpose=\"filter: 'Adam Rex'\">cards.artist</column>",
        "<output_schema purpose=\"Count of cards meeting the criteria\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'cards in the set \"Hauptset Zehnte Edition\"'--><table>set_translations</table>",
        "<!--Required for 'cards in the set \"Hauptset Zehnte Edition\"'--><table>cards</table>",
        "<!--Required to join set_translations with cards--><table>sets</table>",
        "<!--Filter: 'Hauptset Zehnte Edition'--><column>set_translations.translation</column>",
        "<!--Filter: 'Hauptset Zehnte Edition'--><column>set_translations.language</column>",
        "<!--Join: set_translations.setCode--><column>sets.code</column>",
        "<!--Join: sets.code--><column>cards.setCode</column>",
        "<!--Filter: 'designed by Adam Rex'--><column>cards.artist</column>",
        "<!--Count of cards--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 468,
      "db_id": "card_games",
      "question": "What is the Simplified Chinese translation of the name of the set \"Eighth Edition\"?",
      "evidence": "Eighth Edition is the name of card set which refers to name = 'Eighth Edition'; Simplified Chinese refers to language = 'Chinese Simplified'; translation of the name refers to translation",
      "SQL": "SELECT T2.translation FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.name = 'Eighth Edition' AND T2.language = 'Chinese Simplified'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["sets", "set_translations"],
        "columns": [
          "set_translations.translation",
          "sets.code",
          "set_translations.setCode",
          "set_translations.language",
          "sets.name"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to find the set 'Eighth Edition'\">sets</table>",
        "<table purpose=\"Required to find the translation of the set name\">set_translations</table>",
        "<column purpose=\"output: 'translation of the name'\">set_translations.translation</column>",
        "<column purpose=\"join: set_translations.setCode\">sets.code</column>",
        "<column purpose=\"join: sets.code\">set_translations.setCode</column>",
        "<column purpose=\"filter: 'Simplified Chinese'\">set_translations.language</column>",
        "<column purpose=\"filter: 'Eighth Edition'\">sets.name</column>",
        "<output_schema purpose=\"translation of the set name\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Eighth Edition' set--><table>sets</table>",
        "<!--Required for translations--><table>set_translations</table>",
        "<!--Filter: 'Eighth Edition'--><column>sets.name</column>",
        "<!--Join: sets.code--><column>sets.code</column>",
        "<!--Join: set_translations.setCode--><column>set_translations.setCode</column>",
        "<!--Filter: 'Chinese Simplified'--><column>set_translations.language</column>",
        "<!--'translation of the name'--><column>set_translations.translation</column>",
        "<!--Simplified Chinese translation of 'Eighth Edition'--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 469,
      "db_id": "card_games",
      "question": "Did the set of cards with \"Angel of Mercy\" appear on Magic: The Gathering Online?",
      "evidence": "card set \"Angel of Mercy\" refers to name = 'Angel of Mercy'; appear on Magic: The Gathering Online refers to mtgoCode is NOT NULL and vice versa",
      "SQL": "SELECT IIF(T2.mtgoCode IS NOT NULL, 'YES', 'NO') FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Angel of Mercy'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["cards", "sets"],
        "columns": ["sets.mtgoCode", "cards.setCode", "sets.code", "cards.name"],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains card information, including 'Angel of Mercy'\">cards</table>",
        "<table purpose=\"Contains set information, including MTGO availability\">sets</table>",
        "<column purpose=\"Indicates if the set appeared on Magic: The Gathering Online\">sets.mtgoCode</column>",
        "<column purpose=\"join: links cards to their respective sets\">cards.setCode</column>",
        "<column purpose=\"join: links sets to cards\">sets.code</column>",
        "<column purpose=\"filter: to find 'Angel of Mercy'\">cards.name</column>",
        "<output_schema purpose=\"YES/NO answer for MTGO availability\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Angel of Mercy'--><table>cards</table>",
        "<!--Required for set information--><table>sets</table>",
        "<!--Filter: 'Angel of Mercy'--><column>cards.name</column>",
        "<!--Join: cards.setCode--><column>cards.setCode</column>",
        "<!--Join: sets.code--><column>sets.code</column>",
        "<!--Check: 'appear on Magic: The Gathering Online'--><column>sets.mtgoCode</column>",
        "<!--Answer: Did the set appear on Magic: The Gathering Online--><output_schema>boolean</output_schema>"
      ]
    },
    {
      "question_id": 472,
      "db_id": "card_games",
      "question": "Among the sets in the block \"Ice Age\", how many of them have an Italian translation?",
      "evidence": "sets in the block \"Ice Age\" refers to block = 'Ice Age'; Italian translation refers to language = 'Italian' and translation is not null",
      "SQL": "SELECT COUNT(DISTINCT T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.block = 'Ice Age' AND T2.language = 'Italian' AND T2.translation IS NOT NULL",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["sets", "set_translations"],
        "columns": [
          "sets.id",
          "sets.code",
          "set_translations.setCode",
          "set_translations.language",
          "set_translations.translation",
          "sets.block"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'sets in the block 'Ice Age''\">sets</table>",
        "<table purpose=\"Required for 'Italian translation'\">set_translations</table>",
        "<column purpose=\"calculate: count of distinct sets\">sets.id</column>",
        "<column purpose=\"join: set_translations.setCode\">sets.code</column>",
        "<column purpose=\"join: sets.code\">set_translations.setCode</column>",
        "<column purpose=\"filter: 'Italian translation'\">set_translations.language</column>",
        "<column purpose=\"filter: 'translation is not null'\">set_translations.translation</column>",
        "<column purpose=\"filter: 'sets in the block 'Ice Age''\">sets.block</column>",
        "<output_schema purpose=\"count of sets with Italian translation\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'sets in the block \"Ice Age\"'--><table>sets</table>",
        "<!--Required for 'Italian translation'--><table>set_translations</table>",
        "<!--filter: 'block \"Ice Age\"'--><column>sets.block</column>",
        "<!--join: sets.code--><column>set_translations.setCode</column>",
        "<!--filter: 'Italian translation'--><column>set_translations.language</column>",
        "<!--filter: 'Italian translation'--><column>set_translations.translation</column>",
        "<!--count of sets with Italian translation--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 473,
      "db_id": "card_games",
      "question": "Is the set of cards with Adarkar Valkyrie only available outside the United States?",
      "evidence": "card set Adarkar Valkyrie refers to name = 'Adarkar Valkyrie'; isForeignOnly = 1 means only available outside the United States;",
      "SQL": "SELECT IIF(isForeignOnly = 1, 'YES', 'NO') FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Adarkar Valkyrie'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["cards", "sets"],
        "columns": [
          "sets.isForeignOnly",
          "cards.setCode",
          "sets.code",
          "cards.name"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains card information, including name and set code\">cards</table>",
        "<table purpose=\"Contains set information, including foreign availability\">sets</table>",
        "<column purpose=\"filter: 'only available outside the United States'\">sets.isForeignOnly</column>",
        "<column purpose=\"join: sets.code\">cards.setCode</column>",
        "<column purpose=\"join: cards.setCode\">sets.code</column>",
        "<column purpose=\"filter: 'Adarkar Valkyrie'\">cards.name</column>",
        "<output_schema purpose=\"YES/NO answer to availability outside the United States\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required to find the set(s) containing Adarkar Valkyrie--><table>cards</table>",
        "<!--Required to check if the set is only available outside the USA--><table>sets</table>",
        "<!--To identify the card 'Adarkar Valkyrie'--><column>cards.name</column>",
        "<!--To link cards to their respective sets--><column>cards.setCode</column>",
        "<!--To link sets to cards--><column>sets.code</column>",
        "<!--To check if the set is only available outside the USA--><column>sets.isForeignOnly</column>",
        "<!--Answer whether the set is only available outside the USA--><output_schema>boolean</output_schema>"
      ]
    },
    {
      "question_id": 474,
      "db_id": "card_games",
      "question": "Among the sets of cards that have an Italian translation, how many of them have a base set number of under 100?",
      "evidence": "Italian translation refers to language = 'Italian'; have a translation means translation is not null; base set number of under 100 refers to baseSetSize < 10",
      "SQL": "SELECT COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation IS NOT NULL AND T1.baseSetSize < 100 AND T2.language = 'Italian'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["sets", "set_translations"],
        "columns": [
          "sets.id",
          "sets.code",
          "set_translations.setCode",
          "set_translations.language",
          "set_translations.translation",
          "sets.baseSetSize"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains set information, including baseSetSize\">sets</table>",
        "<table purpose=\"Contains translations of set names, including Italian translations\">set_translations</table>",
        "<column purpose=\"join: sets.code\">sets.code</column>",
        "<column purpose=\"join: set_translations.setCode\">set_translations.setCode</column>",
        "<column purpose=\"filter: 'Italian translation'\">set_translations.language</column>",
        "<column purpose=\"filter: 'have a translation'\">set_translations.translation</column>",
        "<column purpose=\"filter: 'base set number of under 100'\">sets.baseSetSize</column>",
        "<output_schema purpose=\"count of sets meeting the criteria\">integer</output_schema>",
        "<warning>sets.id is not necessary for this query as we're only interested in the count, not specific set IDs</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for set information--><table>sets</table>",
        "<!--Required for Italian translations--><table>set_translations</table>",
        "<!--Join: sets.code--><column>set_translations.setCode</column>",
        "<!--Join: set_translations.setCode--><column>sets.code</column>",
        "<!--Filter: 'Italian translation'--><column>set_translations.language</column>",
        "<!--Filter: 'have a translation'--><column>set_translations.translation</column>",
        "<!--Filter: 'base set number of under 100'--><column>sets.baseSetSize</column>",
        "<!--Count of sets meeting criteria--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 477,
      "db_id": "card_games",
      "question": "Which of these artists have designed a card in the set Coldsnap, Jeremy Jarvis, Aaron Miller or Chippy?",
      "evidence": "card set Coldsnap refers to name = 'Coldsnap'; Jeremy Jarvis, Aaron Miller or Chippy are the name of artists which refers to artist IN ('Jeremy Jarvis', 'Aaron Miller','Chippy');",
      "SQL": "SELECT T1.artist FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE (T2.name = 'Coldsnap' AND T1.artist = 'Chippy') OR (T2.name = 'Coldsnap' AND T1.artist = 'Aaron Miller') OR (T2.name = 'Coldsnap' AND T1.artist = 'Jeremy Jarvis') GROUP BY T1.artist",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["cards", "sets"],
        "columns": ["cards.artist", "cards.setCode", "sets.code", "sets.name"],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains card information, including artist names\">cards</table>",
        "<table purpose=\"Contains set information, including set names\">sets</table>",
        "<column purpose=\"filter: 'Jeremy Jarvis, Aaron Miller or Chippy', calculate: result\">cards.artist</column>",
        "<column purpose=\"join: sets.code\">cards.setCode</column>",
        "<column purpose=\"join: cards.setCode\">sets.code</column>",
        "<column purpose=\"filter: 'Coldsnap'\">sets.name</column>",
        "<output_schema purpose=\"List of artists who designed cards in Coldsnap\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'card in the set Coldsnap'--><table>cards</table>",
        "<!--Required for 'card in the set Coldsnap'--><table>sets</table>",
        "<!--Filter: 'set Coldsnap'--><column>sets.name</column>",
        "<!--Join: cards.setCode--><column>sets.code</column>",
        "<!--Join: sets.code--><column>cards.setCode</column>",
        "<!--Filter: 'Jeremy Jarvis, Aaron Miller or Chippy'--><column>cards.artist</column>",
        "<!--Output: artists who designed a card in Coldsnap--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 479,
      "db_id": "card_games",
      "question": "Among the cards with converted mana cost higher than 5 in the set Coldsnap, how many of them have unknown power?",
      "evidence": "card set Coldsnap refers to name = 'Coldsnap'; converted mana cost higher than 5 refers to convertedManaCost > 5; unknown power refers to power = '*' or T1.power is null",
      "SQL": "SELECT SUM(CASE WHEN T1.power = '*' OR T1.power IS NULL THEN 1 ELSE 0 END) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap' AND T1.convertedManaCost > 5",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["cards", "sets"],
        "columns": [
          "cards.power",
          "cards.setCode",
          "sets.code",
          "sets.name",
          "cards.convertedManaCost"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains card information, including power and converted mana cost\">cards</table>",
        "<table purpose=\"Contains set information, including set name\">sets</table>",
        "<column purpose=\"filter: 'unknown power refers to power = '*' or T1.power is null'\">cards.power</column>",
        "<column purpose=\"join: sets.code\">cards.setCode</column>",
        "<column purpose=\"join: cards.setCode\">sets.code</column>",
        "<column purpose=\"filter: 'card set Coldsnap refers to name = 'Coldsnap''\">sets.name</column>",
        "<column purpose=\"filter: 'converted mana cost higher than 5 refers to convertedManaCost > 5'\">cards.convertedManaCost</column>",
        "<output_schema purpose=\"count of cards meeting the criteria\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'cards with converted mana cost higher than 5'--><table>cards</table>",
        "<!--Required for 'in the set Coldsnap'--><table>sets</table>",
        "<!--filter: 'converted mana cost higher than 5'--><column>cards.convertedManaCost</column>",
        "<!--filter: 'in the set Coldsnap'--><column>cards.setCode</column>",
        "<!--join: cards.setCode--><column>sets.code</column>",
        "<!--filter: 'in the set Coldsnap'--><column>sets.name</column>",
        "<!--filter: 'unknown power'--><column>cards.power</column>",
        "<!--count of cards meeting criteria--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 480,
      "db_id": "card_games",
      "question": "What is the Italian flavor text of the card \"Ancestor's Chosen\"?",
      "evidence": "Italian refers to language = 'Italian'; flavor text refers to flavorText; \"Ancestor''s Chosen\" refers to name = 'Ancestor''s Chosen'",
      "SQL": "SELECT T2.flavorText FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Italian'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["cards", "foreign_data"],
        "columns": [
          "foreign_data.flavorText",
          "cards.uuid",
          "foreign_data.uuid",
          "foreign_data.language",
          "cards.name"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains the base card information for 'Ancestor's Chosen'\">cards</table>",
        "<table purpose=\"Contains translations and flavor text in various languages, including Italian\">foreign_data</table>",
        "<column purpose=\"The Italian flavor text we're looking for\">foreign_data.flavorText</column>",
        "<column purpose=\"join: foreign_data.uuid\">cards.uuid</column>",
        "<column purpose=\"join: cards.uuid\">foreign_data.uuid</column>",
        "<column purpose=\"filter: 'Italian'\">foreign_data.language</column>",
        "<column purpose=\"filter: 'Ancestor's Chosen'\">cards.name</column>",
        "<output_schema purpose=\"The Italian flavor text of 'Ancestor's Chosen'\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for card name--><table>cards</table>",
        "<!--Required for foreign language data--><table>foreign_data</table>",
        "<!--Filter: \"Ancestor's Chosen\"--><column>cards.name</column>",
        "<!--Join: cards.uuid--><column>cards.uuid</column>",
        "<!--Join: foreign_data.uuid--><column>foreign_data.uuid</column>",
        "<!--Filter: Italian--><column>foreign_data.language</column>",
        "<!--Italian flavor text--><column>foreign_data.flavorText</column>",
        "<!--Italian flavor text of \"Ancestor's Chosen\"--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 483,
      "db_id": "card_games",
      "question": "Please list the Italian text ruling of all the cards in the set Coldsnap.",
      "evidence": "card set Coldsnap refers to name = 'Coldsnap'; Italian refers to language = 'Italian'",
      "SQL": "SELECT DISTINCT T1.text FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid INNER JOIN sets AS T3 ON T3.code = T2.setCode WHERE T3.name = 'Coldsnap' AND T1.language = 'Italian'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["foreign_data", "cards", "sets"],
        "columns": [
          "foreign_data.text",
          "foreign_data.uuid",
          "cards.uuid",
          "cards.setCode",
          "sets.code",
          "sets.name",
          "foreign_data.language"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains foreign language card data, including Italian text\">foreign_data</table>",
        "<table purpose=\"Links foreign_data to sets via setCode\">cards</table>",
        "<table purpose=\"Contains set information, including the Coldsnap set\">sets</table>",
        "<column purpose=\"The Italian text of the card\">foreign_data.text</column>",
        "<column purpose=\"join: cards.uuid\">foreign_data.uuid</column>",
        "<column purpose=\"join: foreign_data.uuid\">cards.uuid</column>",
        "<column purpose=\"join: sets.code\">cards.setCode</column>",
        "<column purpose=\"join: cards.setCode\">sets.code</column>",
        "<column purpose=\"filter: 'Coldsnap'\">sets.name</column>",
        "<column purpose=\"filter: 'Italian'\">foreign_data.language</column>",
        "<output_schema purpose=\"Italian text of Coldsnap cards\">text</output_schema>",
        "<warning>The proposal doesn't include rulings. The question asks for \"Italian text ruling\", but the SQL query and table selection suggest you're looking for the Italian text of the cards themselves, not rulings. If you need rulings, you should include the rulings table and its relevant columns.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'set Coldsnap'--><table>sets</table>",
        "<!--Required for 'Italian text ruling'--><table>foreign_data</table>",
        "<!--Required for linking cards to rulings--><table>cards</table>",
        "<!--Required for 'text ruling'--><table>rulings</table>",
        "<!--Filter: 'set Coldsnap'--><column>sets.name</column>",
        "<!--Join: sets to cards--><column>sets.code</column>",
        "<!--Join: sets to cards--><column>cards.setCode</column>",
        "<!--Join: cards to foreign_data--><column>cards.uuid</column>",
        "<!--Join: cards to foreign_data--><column>foreign_data.uuid</column>",
        "<!--Filter: 'Italian'--><column>foreign_data.language</column>",
        "<!--Join: cards to rulings--><column>rulings.uuid</column>",
        "<!--Output: Italian card name--><column>foreign_data.name</column>",
        "<!--Output: Italian card text--><column>foreign_data.text</column>",
        "<!--Output: ruling date--><column>rulings.date</column>",
        "<!--Output: ruling text--><column>rulings.text</column>",
        "<!--Italian card name--><output_schema>text</output_schema>",
        "<!--Italian card text--><output_schema>text</output_schema>",
        "<!--Ruling date--><output_schema>date</output_schema>",
        "<!--Ruling text--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 484,
      "db_id": "card_games",
      "question": "Please list the Italian names of the cards in the set Coldsnap with the highest converted mana cost.",
      "evidence": "card set Coldsnap refers to name = 'Coldsnap'; Italian refers to language = 'Italian'; highest converted mana cost refers to MAX(convertedManaCost)",
      "SQL": "SELECT T2.name FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid INNER JOIN sets AS T3 ON T3.code = T2.setCode WHERE T3.name = 'Coldsnap' AND T1.language = 'Italian' ORDER BY T2.convertedManaCost DESC",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["foreign_data", "cards", "sets"],
        "columns": [
          "cards.name",
          "foreign_data.uuid",
          "cards.uuid",
          "cards.setCode",
          "sets.code",
          "sets.name",
          "foreign_data.language",
          "cards.convertedManaCost"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains foreign language card data, including Italian names\">foreign_data</table>",
        "<table purpose=\"Contains card data, including converted mana cost\">cards</table>",
        "<table purpose=\"Contains set data, used to identify the Coldsnap set\">sets</table>",
        "<column purpose=\"Output: Italian names of the cards\">foreign_data.name</column>",
        "<error>foreign_data.name is missing from the proposal. It should be included to get the Italian names.</error>",
        "<column purpose=\"join: links foreign_data to cards\">foreign_data.uuid</column>",
        "<column purpose=\"join: links foreign_data to cards\">cards.uuid</column>",
        "<column purpose=\"join: links cards to sets\">cards.setCode</column>",
        "<column purpose=\"join: links cards to sets\">sets.code</column>",
        "<column purpose=\"filter: 'Coldsnap' set\">sets.name</column>",
        "<column purpose=\"filter: Italian language\">foreign_data.language</column>",
        "<column purpose=\"sort: highest converted mana cost\">cards.convertedManaCost</column>",
        "<column warning=\"Not needed for this query\">cards.name</column>",
        "<output_schema purpose=\"Italian names of the cards\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'cards in the set Coldsnap'--><table>cards</table>",
        "<!--Required for 'Italian names'--><table>foreign_data</table>",
        "<!--Required for 'set Coldsnap'--><table>sets</table>",
        "<!--filter: 'set Coldsnap'--><column>sets.name</column>",
        "<!--join: cards.setCode--><column>sets.code</column>",
        "<!--join: sets.code--><column>cards.setCode</column>",
        "<!--calculate: 'highest converted mana cost'--><column>cards.convertedManaCost</column>",
        "<!--join: foreign_data.uuid--><column>cards.uuid</column>",
        "<!--join: cards.uuid--><column>foreign_data.uuid</column>",
        "<!--filter: 'Italian'--><column>foreign_data.language</column>",
        "<!--'Italian names'--><column>foreign_data.name</column>",
        "<!--Italian names of cards with highest converted mana cost--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 486,
      "db_id": "card_games",
      "question": "What is the percentage of the cards with a converted mana cost of 7 in the set Coldsnap?",
      "evidence": "converted mana cost of 7 refers to convertedManaCost = 7; card set Coldsnap refers to name = 'Coldsnap'; percentage = DIVIDE(SUM(convertedManaCost = 7), SUM(convertedManaCost))*100",
      "SQL": "SELECT CAST(SUM(CASE WHEN T1.convertedManaCost = 7 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["cards", "sets"],
        "columns": [
          "cards.convertedManaCost",
          "cards.id",
          "cards.setCode",
          "sets.code",
          "sets.name"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains card information, including converted mana cost\">cards</table>",
        "<table purpose=\"Contains set information, including set names\">sets</table>",
        "<column purpose=\"calculate: 'percentage of cards with converted mana cost of 7', filter: 'converted mana cost of 7'\">cards.convertedManaCost</column>",
        "<column purpose=\"count total number of cards in the set\">cards.id</column>",
        "<column purpose=\"join: sets.code\">cards.setCode</column>",
        "<column purpose=\"join: cards.setCode\">sets.code</column>",
        "<column purpose=\"filter: 'set Coldsnap'\">sets.name</column>",
        "<output_schema purpose=\"percentage calculation result\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'cards with a converted mana cost of 7'--><table>cards</table>",
        "<!--Required for 'in the set Coldsnap'--><table>sets</table>",
        "<!--calculate: 'converted mana cost of 7'--><column>cards.convertedManaCost</column>",
        "<!--join: cards.setCode--><column>cards.setCode</column>",
        "<!--join: sets.code--><column>sets.code</column>",
        "<!--filter: 'in the set Coldsnap'--><column>sets.name</column>",
        "<!--percentage of cards with convertedManaCost = 7--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 487,
      "db_id": "card_games",
      "question": "What is the percentage of incredibly powerful cards in the set Coldsnap?",
      "evidence": "card set Coldsnap refers to name = 'Coldsnap'; foil is incredibly powerful refers to cardKingdomFoilId is not null AND cardKingdomId is not null; the percentage of incredibly powerful cards in the set refers to DIVIDE(SUM(incredibly powerful), SUM(name = 'Coldsnap'))*100",
      "SQL": "SELECT CAST(SUM(CASE WHEN T1.cardKingdomFoilId IS NOT NULL AND T1.cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["cards", "sets"],
        "columns": [
          "cards.cardKingdomFoilId",
          "cards.cardKingdomId",
          "cards.id",
          "cards.setCode",
          "sets.code",
          "sets.name"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains card information, including cardKingdomFoilId and cardKingdomId\">cards</table>",
        "<table purpose=\"Contains set information, including set name\">sets</table>",
        "<column purpose=\"filter: 'incredibly powerful cards', join: sets.code\">cards.setCode</column>",
        "<column purpose=\"filter: 'incredibly powerful cards'\">cards.cardKingdomFoilId</column>",
        "<column purpose=\"filter: 'incredibly powerful cards'\">cards.cardKingdomId</column>",
        "<column purpose=\"count: total cards in the set\">cards.id</column>",
        "<column purpose=\"join: cards.setCode\">sets.code</column>",
        "<column purpose=\"filter: 'Coldsnap'\">sets.name</column>",
        "<output_schema purpose=\"percentage of incredibly powerful cards\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'set Coldsnap'--><table>cards</table>",
        "<!--Required for 'set Coldsnap'--><table>sets</table>",
        "<!--Filter: 'set Coldsnap'--><column>sets.name</column>",
        "<!--Join: cards to sets--><column>cards.setCode</column>",
        "<!--Join: sets to cards--><column>sets.code</column>",
        "<!--Filter: 'incredibly powerful'--><column>cards.cardKingdomFoilId</column>",
        "<!--Filter: 'incredibly powerful'--><column>cards.cardKingdomId</column>",
        "<!--Calculate: 'percentage of incredibly powerful cards'--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 518,
      "db_id": "card_games",
      "question": "Which of the play format has the highest number of banned status? Indicate the play format and the names of all the card meet the condition.",
      "evidence": "play format refers to format; banned status refers to status = 'Banned'; the highest number of banned status refers to MAX(COUNT(status = 'Banned'))",
      "SQL": "WITH MaxBanned AS (SELECT format, COUNT(*) AS count_banned FROM legalities WHERE status = 'Banned' GROUP BY format ORDER BY COUNT(*) DESC LIMIT 1) SELECT T2.format, T1.name FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid INNER JOIN MaxBanned MB ON MB.format = T2.format WHERE T2.status = 'Banned'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["cards", "legalities"],
        "columns": [
          "legalities.format",
          "legalities.status",
          "cards.name",
          "cards.uuid",
          "legalities.uuid"
        ],
        "output_schema": ["text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for card names\">cards</table>",
        "<table purpose=\"Required for format and banned status information\">legalities</table>",
        "<column purpose=\"filter and group: 'Which of the play format'\">legalities.format</column>",
        "<column purpose=\"filter: 'banned status'\">legalities.status</column>",
        "<column purpose=\"output: 'names of all the card meet the condition'\">cards.name</column>",
        "<column purpose=\"join: cards.uuid\">cards.uuid</column>",
        "<column purpose=\"join: legalities.uuid\">legalities.uuid</column>",
        "<output_schema purpose=\"play format with highest number of banned cards\">text</output_schema>",
        "<output_schema purpose=\"names of banned cards in the format with highest number of banned cards\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'play format' and 'banned status'--><table>legalities</table>",
        "<!--Required for card names--><table>cards</table>",
        "<!--play format--><column>legalities.format</column>",
        "<!--banned status--><column>legalities.status</column>",
        "<!--join: cards.uuid--><column>legalities.uuid</column>",
        "<!--join: legalities.uuid--><column>cards.uuid</column>",
        "<!--card names--><column>cards.name</column>",
        "<!--play format with highest number of banned cards--><output_schema>text</output_schema>",
        "<!--names of banned cards in that format--><output_schema>text[]</output_schema>"
      ]
    },
    {
      "question_id": 522,
      "db_id": "card_games",
      "question": "Which cards are ranked 1st on EDHRec? List all of the cards name and its banned play format.",
      "evidence": "ranked 1st on EDHRec refers to edhrecRank = 1; banned refers to status = 'Banned'; play format refers to format; cards name refers to name",
      "SQL": "SELECT T1.name, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid WHERE T1.edhrecRank = 1 AND T2.status = 'Banned' GROUP BY T1.name, T2.format",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["cards", "legalities"],
        "columns": [
          "cards.name",
          "legalities.format",
          "cards.uuid",
          "legalities.uuid",
          "legalities.status",
          "cards.edhrecRank"
        ],
        "output_schema": ["text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for card information\">cards</table>",
        "<table purpose=\"Required for legality information\">legalities</table>",
        "<column purpose=\"output: 'cards name'\">cards.name</column>",
        "<column purpose=\"output: 'play format'\">legalities.format</column>",
        "<column purpose=\"join: legalities.uuid\">cards.uuid</column>",
        "<column purpose=\"join: cards.uuid\">legalities.uuid</column>",
        "<column purpose=\"filter: 'banned'\">legalities.status</column>",
        "<column purpose=\"filter: 'ranked 1st on EDHRec'\">cards.edhrecRank</column>",
        "<output_schema purpose=\"cards name\">text</output_schema>",
        "<output_schema purpose=\"play format\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'cards ranked 1st on EDHRec'--><table>cards</table>",
        "<!--Required for 'banned play format'--><table>legalities</table>",
        "<!--filter: 'ranked 1st on EDHRec'--><column>cards.edhrecRank</column>",
        "<!--output: 'cards name'--><column>cards.name</column>",
        "<!--join: cards.uuid--><column>cards.uuid</column>",
        "<!--join: legalities.uuid--><column>legalities.uuid</column>",
        "<!--filter: 'banned'--><column>legalities.status</column>",
        "<!--output: 'play format'--><column>legalities.format</column>",
        "<!--cards name--><output_schema>text</output_schema>",
        "<!--banned play format--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 528,
      "db_id": "card_games",
      "question": "List the names of all the cards in the set Hour of Devastation and find the formats in which these cards are legal.",
      "evidence": "the set Hour of Devastation refers to set.name = 'Hour of Devastation'; names of all the cards in the set refers to cards.name; legal cards refers to status = 'Legal'; the formats refers to format",
      "SQL": "SELECT DISTINCT T2.name , CASE WHEN T1.status = 'Legal' THEN T1.format ELSE NULL END FROM legalities AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid WHERE T2.setCode IN ( SELECT code FROM sets WHERE name = 'Hour of Devastation' )",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["legalities", "cards", "sets"],
        "columns": [
          "sets.code",
          "sets.name",
          "cards.name",
          "legalities.status",
          "legalities.format",
          "legalities.uuid",
          "cards.uuid",
          "cards.setCode"
        ],
        "output_schema": ["text", "null"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to get the set code for 'Hour of Devastation'\">sets</table>",
        "<table purpose=\"Required to get card names and link to legalities\">cards</table>",
        "<table purpose=\"Required to get format legality information\">legalities</table>",
        "<column purpose=\"Join: cards.setCode\">sets.code</column>",
        "<column purpose=\"Filter: 'Hour of Devastation'\">sets.name</column>",
        "<column purpose=\"Output: 'names of all the cards in the set'\">cards.name</column>",
        "<column purpose=\"Filter: 'legal cards'\">legalities.status</column>",
        "<column purpose=\"Output: 'the formats'\">legalities.format</column>",
        "<column purpose=\"Join: cards.uuid\">legalities.uuid</column>",
        "<column purpose=\"Join: legalities.uuid\">cards.uuid</column>",
        "<column purpose=\"Join: sets.code\">cards.setCode</column>",
        "<output_schema purpose=\"Card name\">text</output_schema>",
        "<output_schema purpose=\"Format (null if not legal)\">null</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'set Hour of Devastation'--><table>sets</table>",
        "<!--Required for 'names of all the cards in the set'--><table>cards</table>",
        "<!--Required for 'formats in which these cards are legal'--><table>legalities</table>",
        "<!--Filter: 'Hour of Devastation'--><column>sets.name</column>",
        "<!--Join: cards.setCode--><column>sets.code</column>",
        "<!--Join: sets.code--><column>cards.setCode</column>",
        "<!--'names of all the cards in the set'--><column>cards.name</column>",
        "<!--Join: legalities.uuid--><column>cards.uuid</column>",
        "<!--Join: cards.uuid--><column>legalities.uuid</column>",
        "<!--Filter: 'legal cards'--><column>legalities.status</column>",
        "<!--'the formats'--><column>legalities.format</column>",
        "<!--'names of all the cards in the set'--><output_schema>text</output_schema>",
        "<!--'the formats in which these cards are legal'--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 529,
      "db_id": "card_games",
      "question": "Find and list the names of sets which doesn't have Japanese translation but have Korean translation.",
      "evidence": "names of sets refers to name; doesn't have Japanese translation refers to language not like '%Japanese%'; have Korean translation refers to language = 'Korean'",
      "SQL": "SELECT name FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE language = 'Korean' AND language NOT LIKE '%Japanese%' )",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["sets", "set_translations"],
        "columns": [
          "set_translations.setCode",
          "set_translations.language",
          "sets.name",
          "sets.code"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains set information, including names\">sets</table>",
        "<table purpose=\"Contains translations of set names in various languages\">set_translations</table>",
        "<column purpose=\"Join: sets.code, filter: sets with Korean translation but not Japanese\">set_translations.setCode</column>",
        "<column purpose=\"Filter: 'Korean' and not 'Japanese'\">set_translations.language</column>",
        "<column purpose=\"Output: names of sets\">sets.name</column>",
        "<column purpose=\"Join: set_translations.setCode\">sets.code</column>",
        "<output_schema purpose=\"List of set names\">text</output_schema>",
        "<warning>The proposed columns and tables are correct, but the SQL query provided in the question uses a subquery approach. The proposal doesn't explicitly mention this structure, but it's a valid way to solve the problem.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for set names--><table>sets</table>",
        "<!--Required for translations--><table>set_translations</table>",
        "<!--Join sets with set_translations--><column>sets.code</column>",
        "<!--Join sets with set_translations--><column>set_translations.setCode</column>",
        "<!--Filter for Korean translations--><column>set_translations.language</column>",
        "<!--Check for absence of Japanese translations--><column>set_translations.language</column>",
        "<!--Output set names--><column>sets.name</column>",
        "<!--List of set names--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 530,
      "db_id": "card_games",
      "question": "List all the frame styles and cards Allen Williams worked on and find any banned cards if there are any.",
      "evidence": "frame styles refers to frameVersion; cards Allen Williams worked on refers to artist = 'Allen Williams'; banned cards refers to status = 'Banned'",
      "SQL": "SELECT DISTINCT T1.frameVersion, T1.name , IIF(T2.status = 'Banned', T1.name, 'NO') FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Allen Williams'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["cards", "legalities"],
        "columns": [
          "cards.frameVersion",
          "cards.name",
          "legalities.status",
          "cards.uuid",
          "legalities.uuid",
          "cards.artist"
        ],
        "output_schema": ["text", "text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains card information including frame styles and artist\">cards</table>",
        "<table purpose=\"Contains legality information for cards\">legalities</table>",
        "<column purpose=\"filter: 'frame styles refers to frameVersion'\">cards.frameVersion</column>",
        "<column purpose=\"output: card names\">cards.name</column>",
        "<column purpose=\"filter: 'banned cards refers to status = 'Banned''\">legalities.status</column>",
        "<column purpose=\"join: cards.uuid\">cards.uuid</column>",
        "<column purpose=\"join: legalities.uuid\">legalities.uuid</column>",
        "<column purpose=\"filter: 'cards Allen Williams worked on refers to artist = 'Allen Williams''\">cards.artist</column>",
        "<output_schema purpose=\"frame version of the card\">text</output_schema>",
        "<output_schema purpose=\"name of the card\">text</output_schema>",
        "<output_schema purpose=\"indication if the card is banned or not\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'frame styles'--><table>cards</table>",
        "<!--Required for 'cards Allen Williams worked on'--><table>cards</table>",
        "<!--Required for 'banned cards'--><table>legalities</table>",
        "<!--frame styles--><column>cards.frameVersion</column>",
        "<!--cards Allen Williams worked on--><column>cards.artist</column>",
        "<!--cards Allen Williams worked on--><column>cards.name</column>",
        "<!--join: cards.uuid--><column>legalities.uuid</column>",
        "<!--banned cards--><column>legalities.status</column>",
        "<!--frame styles--><output_schema>text</output_schema>",
        "<!--cards Allen Williams worked on--><output_schema>text</output_schema>",
        "<!--banned cards (if any)--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 195,
      "db_id": "toxicology",
      "question": "What is the most common bond type?",
      "evidence": "most common bond type refers MAX(COUNT(bond_type))",
      "SQL": "SELECT T.bond_type FROM ( SELECT bond_type, COUNT(bond_id) FROM bond GROUP BY bond_type ORDER BY COUNT(bond_id) DESC LIMIT 1 ) AS T",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["bond"],
        "columns": ["bond.bond_type", "bond.bond_id"],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for counting bond types\">bond</table>",
        "<column purpose=\"calculate: 'most common bond type'\">bond.bond_type</column>",
        "<column purpose=\"count: to determine the most common bond type\">bond.bond_id</column>",
        "<output_schema purpose=\"return the most common bond type\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'most common bond type'--><table>bond</table>",
        "<!--calculate: 'most common bond type'--><column>bond.bond_type</column>",
        "<!--most common bond type--><output_schema>text</output_schema>",
        "<!--count of most common bond type--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 197,
      "db_id": "toxicology",
      "question": "Calculate the average number of oxygen atoms in single-bonded molecules.",
      "evidence": "single-bonded molecules refers to bond_type = '-' ; average number of oxygen atom = AVG(element = 'o')",
      "SQL": "SELECT AVG(oxygen_count) FROM (SELECT T1.molecule_id, COUNT(T1.element) AS oxygen_count FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id  WHERE T2.bond_type = '-' AND T1.element = 'o'  GROUP BY T1.molecule_id) AS oxygen_counts",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["atom", "bond"],
        "columns": [
          "atom.element",
          "atom.molecule_id",
          "bond.molecule_id",
          "bond.bond_type"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for counting oxygen atoms\">atom</table>",
        "<table purpose=\"Required for identifying single-bonded molecules\">bond</table>",
        "<column purpose=\"filter: 'oxygen atoms', calculate: 'number of oxygen atoms'\">atom.element</column>",
        "<column purpose=\"join: bond.molecule_id, group: 'average number of oxygen atoms'\">atom.molecule_id</column>",
        "<column purpose=\"join: atom.molecule_id\">bond.molecule_id</column>",
        "<column purpose=\"filter: 'single-bonded molecules'\">bond.bond_type</column>",
        "<output_schema purpose=\"average number of oxygen atoms\">real</output_schema>",
        "<warning>The proposal is missing a COUNT or SUM aggregation for oxygen atoms. While this can be implemented in the SQL query, it's worth noting that an aggregation function will be needed to count the oxygen atoms.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'oxygen atoms'--><table>atom</table>",
        "<!--Required for 'single-bonded molecules'--><table>bond</table>",
        "<!--Required to link atoms and bonds to molecules--><table>molecule</table>",
        "<!--Filter: 'oxygen atoms'--><column>atom.element</column>",
        "<!--Join: atom.molecule_id--><column>molecule.molecule_id</column>",
        "<!--Join: bond.molecule_id--><column>molecule.molecule_id</column>",
        "<!--Filter: 'single-bonded molecules'--><column>bond.bond_type</column>",
        "<!--Calculate: 'average number of oxygen atoms'--><column>atom.molecule_id</column>",
        "<!--Average number of oxygen atoms in single-bonded molecules--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 198,
      "db_id": "toxicology",
      "question": "On average how many carcinogenic molecules are single bonded?",
      "evidence": "carcinogenic molecules refers to label = '+'; single-bonded refers to bond_type = '-'; average = DIVIDE(SUM(bond_type = '-'), COUNT(atom_id))",
      "SQL": "SELECT AVG(single_bond_count) FROM (SELECT T3.molecule_id, COUNT(T1.bond_type) AS single_bond_count FROM bond AS T1  INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN molecule AS T3 ON T3.molecule_id = T2.molecule_id WHERE T1.bond_type = '-' AND T3.label = '+' GROUP BY T3.molecule_id) AS subquery",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["bond", "atom", "molecule"],
        "columns": [
          "bond.bond_type",
          "bond.molecule_id",
          "atom.molecule_id",
          "molecule.molecule_id",
          "molecule.label"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'single bonded' information\">bond</table>",
        "<table purpose=\"Required for joining bond and molecule tables\">atom</table>",
        "<table purpose=\"Required for 'carcinogenic molecules' information\">molecule</table>",
        "<column purpose=\"filter: 'single bonded'\">bond.bond_type</column>",
        "<column purpose=\"join: atom.molecule_id, molecule.molecule_id\">bond.molecule_id</column>",
        "<column purpose=\"join: bond.molecule_id, molecule.molecule_id\">atom.molecule_id</column>",
        "<column purpose=\"join: bond.molecule_id, atom.molecule_id\">molecule.molecule_id</column>",
        "<column purpose=\"filter: 'carcinogenic molecules'\">molecule.label</column>",
        "<output_schema purpose=\"average number of single bonds in carcinogenic molecules\">real</output_schema>",
        "<warning>The proposal is missing atom.atom_id, which is needed for the average calculation as per the question's definition: \"average = DIVIDE(SUM(bond_type = '-'), COUNT(atom_id))\"</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'carcinogenic molecules'--><table>molecule</table>",
        "<!--Required for 'single bonded'--><table>bond</table>",
        "<!--Required to connect molecules and bonds--><table>atom</table>",
        "<!--Filter: 'carcinogenic molecules'--><column>molecule.label</column>",
        "<!--Join: molecule.molecule_id--><column>atom.molecule_id</column>",
        "<!--Join: atom.molecule_id--><column>bond.molecule_id</column>",
        "<!--Filter: 'single bonded'--><column>bond.bond_type</column>",
        "<!--Count atoms for average calculation--><column>atom.atom_id</column>",
        "<!--Average number of single bonds in carcinogenic molecules--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 200,
      "db_id": "toxicology",
      "question": "Find the triple-bonded molecules which are carcinogenic.",
      "evidence": "triple-bonded molecules refers to bond_type = '#'; carcinogenic refers to label = '+'",
      "SQL": "SELECT DISTINCT T2.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#' AND T2.label = '+'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["bond", "molecule"],
        "columns": [
          "molecule.molecule_id",
          "bond.molecule_id",
          "molecule.label",
          "bond.bond_type"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'triple-bonded molecules'\">bond</table>",
        "<table purpose=\"Required for 'carcinogenic' information\">molecule</table>",
        "<column purpose=\"output: 'Find the triple-bonded molecules which are carcinogenic'\">molecule.molecule_id</column>",
        "<column purpose=\"join: molecule.molecule_id\">bond.molecule_id</column>",
        "<column purpose=\"filter: 'carcinogenic refers to label = '+'\">molecule.label</column>",
        "<column purpose=\"filter: 'triple-bonded molecules refers to bond_type = '#''\">bond.bond_type</column>",
        "<output_schema purpose=\"molecule_id of carcinogenic triple-bonded molecules\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'triple-bonded molecules'--><table>bond</table>",
        "<!--Required for 'carcinogenic'--><table>molecule</table>",
        "<!--filter: 'triple-bonded molecules'--><column>bond.bond_type</column>",
        "<!--join: molecule.molecule_id--><column>bond.molecule_id</column>",
        "<!--join: bond.molecule_id--><column>molecule.molecule_id</column>",
        "<!--filter: 'carcinogenic'--><column>molecule.label</column>",
        "<!--triple-bonded carcinogenic molecules--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 201,
      "db_id": "toxicology",
      "question": "What is the percentage of carbon in double-bond molecules?",
      "evidence": "carbon refers to element = 'c'; double-bond molecules refers to bond_type = '='; percentage = DIVIDE(SUM(element = 'c'), COUNT(atom_id))",
      "SQL": "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.element = 'c' THEN T1.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T1.atom_id) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '='",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["atom", "bond"],
        "columns": [
          "atom.element",
          "atom.atom_id",
          "atom.molecule_id",
          "bond.molecule_id",
          "bond.bond_type"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for atom information, including element and atom_id\">atom</table>",
        "<table purpose=\"Required for bond information, including bond_type\">bond</table>",
        "<column purpose=\"filter: 'carbon refers to element = 'c''\">atom.element</column>",
        "<column purpose=\"calculate: used in COUNT(DISTINCT atom_id) for percentage calculation\">atom.atom_id</column>",
        "<column purpose=\"join: atom.molecule_id = bond.molecule_id\">atom.molecule_id</column>",
        "<column purpose=\"join: bond.molecule_id = atom.molecule_id\">bond.molecule_id</column>",
        "<column purpose=\"filter: 'double-bond molecules refers to bond_type = '=''\">bond.bond_type</column>",
        "<output_schema purpose=\"percentage of carbon in double-bond molecules\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'carbon' and atom count--><table>atom</table>",
        "<!--Required for 'double-bond molecules'--><table>bond</table>",
        "<!--Required to link atoms and bonds--><table>connected</table>",
        "<!--Required to link atoms and bonds to molecules--><table>molecule</table>",
        "<!--filter: 'carbon refers to element = 'c''--><column>atom.element</column>",
        "<!--filter: 'double-bond molecules refers to bond_type = '=''--><column>bond.bond_type</column>",
        "<!--join: atom.atom_id--><column>connected.atom_id</column>",
        "<!--join: bond.bond_id--><column>connected.bond_id</column>",
        "<!--join: atom.molecule_id--><column>molecule.molecule_id</column>",
        "<!--join: bond.molecule_id--><column>molecule.molecule_id</column>",
        "<!--percentage of carbon in double-bond molecules--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 206,
      "db_id": "toxicology",
      "question": "What elements are in the TR004_8_9 bond atoms?",
      "evidence": "TR004_8_9 bond atoms refers to bond_id = 'TR004_8_9';",
      "SQL": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR004_8_9'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["atom", "connected"],
        "columns": [
          "atom.element",
          "atom.atom_id",
          "connected.atom_id",
          "connected.bond_id"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to get the element information of atoms\">atom</table>",
        "<table purpose=\"Required to link atoms with the specific bond\">connected</table>",
        "<column purpose=\"calculate: 'What elements are in the TR004_8_9 bond atoms?'\">atom.element</column>",
        "<column purpose=\"join: connected.atom_id\">atom.atom_id</column>",
        "<column purpose=\"join: atom.atom_id\">connected.atom_id</column>",
        "<column purpose=\"filter: 'TR004_8_9 bond atoms refers to bond_id = 'TR004_8_9''\">connected.bond_id</column>",
        "<output_schema purpose=\"element types of atoms in the specified bond\">text</output_schema>",
        "<warning>The query might miss one of the atoms in the bond. Consider including connected.atom_id2 in the join condition to ensure both atoms of the bond are considered.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for bond information--><table>bond</table>",
        "<!--Required for atom information--><table>atom</table>",
        "<!--Required for connecting bonds to atoms--><table>connected</table>",
        "<!--Filter for specific bond 'TR004_8_9'--><column>bond.bond_id</column>",
        "<!--Join bond to connected--><column>connected.bond_id</column>",
        "<!--Join connected to atom for first atom--><column>connected.atom_id</column>",
        "<!--Join connected to atom for second atom--><column>connected.atom_id2</column>",
        "<!--Join atom to connected for first atom--><column>atom.atom_id</column>",
        "<!--Get element information for atoms--><column>atom.element</column>",
        "<!--Output elements of atoms in the bond--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 207,
      "db_id": "toxicology",
      "question": "What elements are in a double type bond?",
      "evidence": "double type bond refers to bond_type = '=';",
      "SQL": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN connected AS T3 ON T1.atom_id = T3.atom_id WHERE T2.bond_type = '='",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["atom", "bond", "connected"],
        "columns": [
          "atom.element",
          "atom.molecule_id",
          "bond.molecule_id",
          "bond.bond_type",
          "atom.atom_id",
          "connected.atom_id"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for element information\">atom</table>",
        "<table purpose=\"Required for bond type information\">bond</table>",
        "<table purpose=\"Required to connect atoms and bonds\">connected</table>",
        "<column purpose=\"output: 'What elements are in a double type bond?'\">atom.element</column>",
        "<column purpose=\"join: bond.molecule_id\">atom.molecule_id</column>",
        "<column purpose=\"join: atom.molecule_id\">bond.molecule_id</column>",
        "<column purpose=\"filter: 'double type bond refers to bond_type = '=''\">bond.bond_type</column>",
        "<column purpose=\"join: connected.atom_id\">atom.atom_id</column>",
        "<column purpose=\"join: atom.atom_id\">connected.atom_id</column>",
        "<output_schema purpose=\"elements in a double type bond\">text</output_schema>",
        "<error>connected.bond_id should be included to join with bond.bond_id</error>",
        "<error>bond.bond_id should be included to join with connected.bond_id</error>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'elements' in bonds--><table>atom</table>",
        "<!--Required for 'double type bond'--><table>bond</table>",
        "<!--Required to connect atoms and bonds--><table>connected</table>",
        "<!--join: atom.atom_id--><column>connected.atom_id</column>",
        "<!--join: atom.atom_id--><column>connected.atom_id2</column>",
        "<!--join: bond.bond_id--><column>connected.bond_id</column>",
        "<!--filter: 'double type bond'--><column>bond.bond_type</column>",
        "<!--'elements' in double bond--><column>atom.element</column>",
        "<!--unique elements in double bonds--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 208,
      "db_id": "toxicology",
      "question": "Which type of label is the most numerous in atoms with hydrogen?",
      "evidence": "with hydrogen refers to element = 'h'; label most numerous in atoms refers to MAX(COUNT(label)); ",
      "SQL": "SELECT T.label FROM ( SELECT T2.label, COUNT(T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'h' GROUP BY T2.label ORDER BY COUNT(T2.molecule_id) DESC LIMIT 1 ) t",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["atom", "molecule"],
        "columns": [
          "molecule.label",
          "molecule.molecule_id",
          "atom.molecule_id",
          "atom.element"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for filtering atoms with hydrogen\">atom</table>",
        "<table purpose=\"Required for obtaining the label information\">molecule</table>",
        "<column purpose=\"calculate: 'Which type of label is the most numerous'\">molecule.label</column>",
        "<column purpose=\"join: atom.molecule_id\">molecule.molecule_id</column>",
        "<column purpose=\"join: molecule.molecule_id\">atom.molecule_id</column>",
        "<column purpose=\"filter: 'atoms with hydrogen'\">atom.element</column>",
        "<output_schema purpose=\"type of label that is most numerous\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'atoms with hydrogen'--><table>atom</table>",
        "<!--Required for 'label'--><table>molecule</table>",
        "<!--filter: 'atoms with hydrogen'--><column>atom.element</column>",
        "<!--join: atom.molecule_id--><column>molecule.molecule_id</column>",
        "<!--count: 'label is the most numerous'--><column>molecule.label</column>",
        "<!--most numerous label for atoms with hydrogen--><output_schema>text</output_schema>",
        "<!--count of the most numerous label--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 212,
      "db_id": "toxicology",
      "question": "Which element is the least numerous in non-carcinogenic molecules?",
      "evidence": "label = '-' means molecules are non-carcinogenic; least numerous refers to MIN(COUNT(element));",
      "SQL": "SELECT T.element FROM (SELECT T1.element, COUNT(DISTINCT T1.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '-' GROUP BY T1.element ORDER BY COUNT(DISTINCT T1.molecule_id) ASC LIMIT 1) t",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["atom", "molecule"],
        "columns": [
          "atom.element",
          "atom.molecule_id",
          "molecule.molecule_id",
          "molecule.label"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for element information and molecule association\">atom</table>",
        "<table purpose=\"Required for carcinogenic property of molecules\">molecule</table>",
        "<column purpose=\"calculate: 'Which element is the least numerous', filter: group by element\">atom.element</column>",
        "<column purpose=\"join: molecule.molecule_id, calculate: count distinct molecules per element\">atom.molecule_id</column>",
        "<column purpose=\"join: atom.molecule_id\">molecule.molecule_id</column>",
        "<column purpose=\"filter: 'non-carcinogenic molecules'\">molecule.label</column>",
        "<output_schema purpose=\"element with the least count\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for element count and carcinogenic status--><table>atom</table>",
        "<!--Required for carcinogenic status--><table>molecule</table>",
        "<!--Join atom and molecule tables--><column>atom.molecule_id</column>",
        "<!--Join atom and molecule tables--><column>molecule.molecule_id</column>",
        "<!--Count occurrences of each element--><column>atom.element</column>",
        "<!--Filter for non-carcinogenic molecules--><column>molecule.label</column>",
        "<!--Element with the least occurrences--><output_schema>text</output_schema>",
        "<!--Count of the least numerous element--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 213,
      "db_id": "toxicology",
      "question": "What type of bond is there between the atoms TR004_8 and TR004_20?",
      "evidence": "type of bond refers to bond_type; between the atoms TR004_8 and TR004_20 refers to atom_id = 'TR004_8' AND atom_id2 = 'TR004_20' OR another way around",
      "SQL": "SELECT T1.bond_type FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.atom_id = 'TR004_8' AND T2.atom_id2 = 'TR004_20' OR T2.atom_id2 = 'TR004_8' AND T2.atom_id = 'TR004_20'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["bond", "connected"],
        "columns": [
          "bond.bond_type",
          "bond.bond_id",
          "connected.bond_id",
          "connected.atom_id",
          "connected.atom_id2"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'type of bond'\">bond</table>",
        "<table purpose=\"Required to connect atoms with bonds\">connected</table>",
        "<column purpose=\"calculate: 'type of bond'\">bond.bond_type</column>",
        "<column purpose=\"join: connected.bond_id\">bond.bond_id</column>",
        "<column purpose=\"join: bond.bond_id\">connected.bond_id</column>",
        "<column purpose=\"filter: 'between the atoms TR004_8 and TR004_20'\">connected.atom_id</column>",
        "<column purpose=\"filter: 'between the atoms TR004_8 and TR004_20'\">connected.atom_id2</column>",
        "<output_schema purpose=\"type of bond\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for atom connections--><table>connected</table>",
        "<!--Required for bond information--><table>bond</table>",
        "<!--To find the connection between TR004_8 and TR004_20--><column>connected.atom_id</column>",
        "<!--To find the connection between TR004_8 and TR004_20--><column>connected.atom_id2</column>",
        "<!--To join with bond table--><column>connected.bond_id</column>",
        "<!--To join with connected table--><column>bond.bond_id</column>",
        "<!--To get the type of bond--><column>bond.bond_type</column>",
        "<!--Type of bond between the atoms--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 215,
      "db_id": "toxicology",
      "question": "How many atoms with iodine and with sulfur type elements are there in single bond molecules?",
      "evidence": "with iodine element refer to element = 'i'; with sulfur element refers to element = 's'; single type bond refers to bond_type = '-'; Should consider the distinct atoms when counting;",
      "SQL": "SELECT COUNT(DISTINCT CASE WHEN T1.element = 'i' THEN T1.atom_id ELSE NULL END) AS iodine_nums , COUNT(DISTINCT CASE WHEN T1.element = 's' THEN T1.atom_id ELSE NULL END) AS sulfur_nums FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T3.bond_type = '-'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["atom", "connected", "bond"],
        "columns": [
          "atom.element",
          "atom.atom_id",
          "connected.atom_id",
          "connected.bond_id",
          "bond.bond_id",
          "bond.bond_type"
        ],
        "output_schema": ["integer", "integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for atom information, including element type\">atom</table>",
        "<table purpose=\"Required to connect atoms with bonds\">connected</table>",
        "<table purpose=\"Required for bond type information\">bond</table>",
        "<column purpose=\"filter: 'iodine and with sulfur type elements'\">atom.element</column>",
        "<column purpose=\"calculate: 'distinct atoms when counting'\">atom.atom_id</column>",
        "<column purpose=\"join: atom.atom_id\">connected.atom_id</column>",
        "<column purpose=\"join: bond.bond_id\">connected.bond_id</column>",
        "<column purpose=\"join: connected.bond_id\">bond.bond_id</column>",
        "<column purpose=\"filter: 'single bond molecules'\">bond.bond_type</column>",
        "<output_schema purpose=\"count of iodine atoms\">integer</output_schema>",
        "<output_schema purpose=\"count of sulfur atoms\">integer</output_schema>",
        "<warning>The proposal is missing atom.molecule_id and bond.molecule_id, which might be needed to ensure atoms and bonds belong to the same molecule.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for atom information--><table>atom</table>",
        "<!--Required for bond information--><table>bond</table>",
        "<!--Required to link atoms and bonds--><table>connected</table>",
        "<!--Required to filter 'iodine' elements--><column>atom.element</column>",
        "<!--Required to filter 'sulfur' elements--><column>atom.element</column>",
        "<!--Required to identify unique atoms--><column>atom.atom_id</column>",
        "<!--Required to link atoms to bonds--><column>connected.atom_id</column>",
        "<!--Required to link atoms to bonds--><column>connected.bond_id</column>",
        "<!--Required to filter 'single bond' molecules--><column>bond.bond_type</column>",
        "<!--Required to link bonds to atoms--><column>bond.bond_id</column>",
        "<!--Count of distinct atoms with iodine and sulfur in single bond molecules--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 218,
      "db_id": "toxicology",
      "question": "What percentage of carcinogenic-type molecules does not contain fluorine?",
      "evidence": "label = '+' mean molecules are carcinogenic; contain fluorine refers to element = 'f'; percentage = DIVIDE(SUM(element = 'f') * 100, COUNT(molecule_id)) where label = '+'; Should consider the distinct atoms when counting;",
      "SQL": "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.element <> 'f' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["atom", "molecule"],
        "columns": [
          "atom.element",
          "molecule.molecule_id",
          "atom.molecule_id",
          "molecule.label"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for checking fluorine content in molecules\">atom</table>",
        "<table purpose=\"Required for identifying carcinogenic molecules\">molecule</table>",
        "<column purpose=\"filter: 'contain fluorine refers to element = 'f''\">atom.element</column>",
        "<column purpose=\"join: atom.molecule_id, calculate: distinct molecules\">molecule.molecule_id</column>",
        "<column purpose=\"join: molecule.molecule_id\">atom.molecule_id</column>",
        "<column purpose=\"filter: 'carcinogenic-type molecules', 'label = '+' mean molecules are carcinogenic'\">molecule.label</column>",
        "<output_schema purpose=\"percentage of carcinogenic molecules without fluorine\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for carcinogenic molecules--><table>molecule</table>",
        "<!--Required for atom information--><table>atom</table>",
        "<!--Filter carcinogenic molecules--><column>molecule.label</column>",
        "<!--Join molecule and atom tables--><column>molecule.molecule_id</column>",
        "<!--Join molecule and atom tables--><column>atom.molecule_id</column>",
        "<!--Check for fluorine atoms--><column>atom.element</column>",
        "<!--Percentage of carcinogenic molecules without fluorine--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 219,
      "db_id": "toxicology",
      "question": "What is the percentage of carcinogenic molecules in triple type bonds?",
      "evidence": "label = '+' mean molecules are carcinogenic; triple bond refers to bond_type = '#'; percentage = DIVIDE(SUM(bond_type = '#') * 100, COUNT(bond_id)) as percent where label = '+'",
      "SQL": "SELECT CAST(COUNT(DISTINCT CASE WHEN T2.label = '+' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '#'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["atom", "molecule", "bond"],
        "columns": [
          "molecule.label",
          "molecule.molecule_id",
          "atom.molecule_id",
          "bond.molecule_id",
          "bond.bond_type"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for joining with molecule and bond tables\">atom</table>",
        "<table purpose=\"Required for carcinogenic information\">molecule</table>",
        "<table purpose=\"Required for bond type information\">bond</table>",
        "<column purpose=\"filter: carcinogenic molecules (label = '+')\">molecule.label</column>",
        "<column purpose=\"join: molecule.molecule_id, atom.molecule_id, bond.molecule_id\">molecule.molecule_id</column>",
        "<column purpose=\"join: molecule.molecule_id, atom.molecule_id, bond.molecule_id\">atom.molecule_id</column>",
        "<column purpose=\"join: molecule.molecule_id, atom.molecule_id, bond.molecule_id\">bond.molecule_id</column>",
        "<column purpose=\"filter: triple bond (bond_type = '#')\">bond.bond_type</column>",
        "<output_schema purpose=\"percentage of carcinogenic molecules with triple bonds\">real</output_schema>",
        "<warning>The proposed tables and columns are correct, but the SQL query doesn't exactly match the description in the question. The question asks for the percentage of carcinogenic molecules in triple type bonds, while the SQL calculates the percentage of molecules with triple bonds that are carcinogenic. These are different calculations.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for carcinogenic molecules--><table>molecule</table>",
        "<!--Required for bond types--><table>bond</table>",
        "<!--Join molecule and bond tables--><column>molecule.molecule_id</column>",
        "<!--Join molecule and bond tables--><column>bond.molecule_id</column>",
        "<!--Filter for carcinogenic molecules--><column>molecule.label</column>",
        "<!--Filter for triple bonds--><column>bond.bond_type</column>",
        "<!--Count total bonds for carcinogenic molecules--><column>bond.bond_id</column>",
        "<!--Percentage of carcinogenic molecules with triple bonds--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 220,
      "db_id": "toxicology",
      "question": "Please list top three elements of the toxicology of the molecule TR000 in alphabetical order.",
      "evidence": "TR000 is the molecule id;",
      "SQL": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR000' ORDER BY T.element LIMIT 3",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["atom"],
        "columns": ["atom.element", "atom.molecule_id"],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"contains information about atoms in molecules\">atom</table>",
        "<column purpose=\"retrieve chemical elements of the atoms\">atom.element</column>",
        "<column purpose=\"filter: 'of the molecule TR000'\">atom.molecule_id</column>",
        "<output_schema purpose=\"list elements (which are text)\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for molecule information--><table>molecule</table>",
        "<!--Required for atom information--><table>atom</table>",
        "<!--Filter for specific molecule 'TR000'--><column>molecule.molecule_id</column>",
        "<!--Join molecule and atom tables--><column>atom.molecule_id</column>",
        "<!--Get elements of the molecule--><column>atom.element</column>",
        "<!--List elements of molecule TR000--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 226,
      "db_id": "toxicology",
      "question": "What is the percentage of double bonds in the molecule TR008? Please provide your answer as a percentage with five decimal places.",
      "evidence": "double bond refers to bond_type = '='; TR008 is the molecule id; percentage = DIVIDE(SUM(bond_type = '='), COUNT(bond_id)) as percent where molecule_id = 'TR008'",
      "SQL": "SELECT ROUND(CAST(COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T.bond_id),5) FROM bond AS T WHERE T.molecule_id = 'TR008'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["bond"],
        "columns": ["bond.bond_type", "bond.bond_id", "bond.molecule_id"],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for bond information of molecule TR008\">bond</table>",
        "<column purpose=\"filter: 'double bonds', calculate: percentage of double bonds\">bond.bond_type</column>",
        "<column purpose=\"calculate: total number of bonds\">bond.bond_id</column>",
        "<column purpose=\"filter: 'in the molecule TR008'\">bond.molecule_id</column>",
        "<output_schema purpose=\"percentage with five decimal places\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'double bonds in the molecule TR008'--><table>bond</table>",
        "<!--filter: 'in the molecule TR008'--><column>bond.molecule_id</column>",
        "<!--calculate: 'percentage of double bonds'--><column>bond.bond_type</column>",
        "<!--percentage of double bonds in TR008--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 227,
      "db_id": "toxicology",
      "question": "What is the percentage of molecules that are carcinogenic? Please provide your answer as a percentage with three decimal places.",
      "evidence": "label = '+' mean molecules are carcinogenic; percentage = DIVIDE(SUM(label = '+'), COUNT(molecule_id)) as percent",
      "SQL": "SELECT ROUND(CAST(COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(T.molecule_id),3) FROM molecule t",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["molecule"],
        "columns": ["molecule.label", "molecule.molecule_id"],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains information about molecules and their carcinogenic properties\">molecule</table>",
        "<column purpose=\"filter: Identifies carcinogenic molecules ('+' indicates carcinogenic)\">molecule.label</column>",
        "<column purpose=\"calculate: Used for counting total number of molecules\">molecule.molecule_id</column>",
        "<output_schema purpose=\"Represents the percentage of carcinogenic molecules as a real number\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'percentage of molecules'--><table>molecule</table>",
        "<!--Used to identify carcinogenic molecules--><column>molecule.label</column>",
        "<!--Used to count total molecules--><column>molecule.molecule_id</column>",
        "<!--Percentage of carcinogenic molecules--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 228,
      "db_id": "toxicology",
      "question": "How much of the hydrogen in molecule TR206 is accounted for? Please provide your answer as a percentage with four decimal places.",
      "evidence": "hydrogen refers to element = 'h'; TR206 is the molecule id; percentage = DIVIDE(SUM(element = 'h'), COUNT(atom_id)) as percent where molecule_id = 'TR206'",
      "SQL": "SELECT ROUND(CAST(COUNT(CASE WHEN T.element = 'h' THEN T.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(T.atom_id),4) FROM atom AS T WHERE T.molecule_id = 'TR206'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["atom"],
        "columns": ["atom.element", "atom.atom_id", "atom.molecule_id"],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for counting atoms and filtering by molecule\">atom</table>",
        "<column purpose=\"filter: 'hydrogen refers to element = 'h''\">atom.element</column>",
        "<column purpose=\"calculate: 'percentage = DIVIDE(SUM(element = 'h'), COUNT(atom_id))'\">atom.atom_id</column>",
        "<column purpose=\"filter: 'TR206 is the molecule id'\">atom.molecule_id</column>",
        "<output_schema purpose=\"percentage with four decimal places\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'hydrogen in molecule TR206'--><table>atom</table>",
        "<!--filter: 'molecule TR206'--><column>atom.molecule_id</column>",
        "<!--filter: 'hydrogen'--><column>atom.element</column>",
        "<!--count: 'all atoms in molecule'--><column>atom.atom_id</column>",
        "<!--percentage of hydrogen atoms--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 230,
      "db_id": "toxicology",
      "question": "What are the elements of the toxicology and label of molecule TR060?",
      "evidence": "TR060 is the molecule id; ",
      "SQL": "SELECT DISTINCT T1.element, T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.molecule_id = 'TR060'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["atom", "molecule"],
        "columns": [
          "atom.element",
          "molecule.label",
          "atom.molecule_id",
          "molecule.molecule_id"
        ],
        "output_schema": ["text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'elements of the toxicology'\">atom</table>",
        "<table purpose=\"Required for 'label of molecule TR060'\">molecule</table>",
        "<column purpose=\"calculate: 'elements of the toxicology'\">atom.element</column>",
        "<column purpose=\"calculate: 'label of molecule TR060'\">molecule.label</column>",
        "<column purpose=\"join: molecule.molecule_id, filter: 'TR060'\">atom.molecule_id</column>",
        "<column purpose=\"join: atom.molecule_id, filter: 'TR060'\">molecule.molecule_id</column>",
        "<output_schema purpose=\"elements of the toxicology\">text</output_schema>",
        "<output_schema purpose=\"label of molecule TR060\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'elements of the toxicology'--><table>atom</table>",
        "<!--Required for 'label of molecule'--><table>molecule</table>",
        "<!--filter: 'of molecule TR060'--><column>atom.molecule_id</column>",
        "<!--join: atom.molecule_id--><column>molecule.molecule_id</column>",
        "<!--retrieve: 'elements of the toxicology'--><column>atom.element</column>",
        "<!--retrieve: 'label of molecule'--><column>molecule.label</column>",
        "<!--elements of the toxicology--><output_schema>text[]</output_schema>",
        "<!--label of molecule--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 231,
      "db_id": "toxicology",
      "question": "Which bond type accounted for the majority of the bonds found in molecule TR010 and state whether or not this molecule is carcinogenic?",
      "evidence": "TR010 is the molecule id; majority of the bond found refers to MAX(COUNT(bond_type)); ",
      "SQL": "SELECT T.bond_type FROM ( SELECT T1.bond_type, COUNT(T1.molecule_id) FROM bond AS T1  WHERE T1.molecule_id = 'TR010' GROUP BY T1.bond_type ORDER BY COUNT(T1.molecule_id) DESC LIMIT 1 ) AS T",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["bond"],
        "columns": ["bond.bond_type", "bond.molecule_id"],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'bond type' and 'bonds found in molecule TR010'\">bond</table>",
        "<column purpose=\"calculate: 'majority of the bonds found'\">bond.bond_type</column>",
        "<column purpose=\"filter: 'in molecule TR010'\">bond.molecule_id</column>",
        "<output_schema purpose=\"bond type that accounted for the majority\">text</output_schema>",
        "<error>The molecule table is missing, which is needed to determine if TR010 is carcinogenic</error>",
        "<error>The molecule.label column is missing, which is needed to determine if TR010 is carcinogenic</error>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'bond type' and 'majority of the bonds'--><table>bond</table>",
        "<!--Required for carcinogenic information--><table>molecule</table>",
        "<!--Filter for molecule 'TR010'--><column>bond.molecule_id</column>",
        "<!--Calculate 'majority of the bonds'--><column>bond.bond_type</column>",
        "<!--Join bond and molecule tables--><column>molecule.molecule_id</column>",
        "<!--Determine carcinogenicity--><column>molecule.label</column>",
        "<!--Bond type with majority--><output_schema>text</output_schema>",
        "<!--Carcinogenicity status--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 232,
      "db_id": "toxicology",
      "question": "Please list top three molecules that have single bonds between two atoms and are not carcinogenic in alphabetical order.",
      "evidence": "label = '-' means molecules are not carcinogenic; single type bond refers to bond_type = '-'; list top three molecules refers to return molecule_id and order by molecule_id;",
      "SQL": "SELECT DISTINCT T2.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '-' AND T2.label = '-' ORDER BY T2.molecule_id LIMIT 3",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["bond", "molecule"],
        "columns": [
          "molecule.molecule_id",
          "bond.molecule_id",
          "molecule.label",
          "bond.bond_type"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for bond information\">bond</table>",
        "<table purpose=\"Required for molecule information and carcinogenic properties\">molecule</table>",
        "<column purpose=\"output: 'list top three molecules', join: bond.molecule_id\">molecule.molecule_id</column>",
        "<column purpose=\"join: molecule.molecule_id\">bond.molecule_id</column>",
        "<column purpose=\"filter: 'not carcinogenic'\">molecule.label</column>",
        "<column purpose=\"filter: 'single bonds'\">bond.bond_type</column>",
        "<output_schema purpose=\"molecule_id of top three non-carcinogenic molecules with single bonds\">text</output_schema>",
        "<warning>The DISTINCT keyword may be necessary in the SELECT clause to avoid duplicate molecule_id entries.</warning>",
        "<warning>A LIMIT 3 clause should be added to the query to return only the top three molecules.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'molecules that have single bonds'--><table>bond</table>",
        "<!--Required for 'molecules that are not carcinogenic'--><table>molecule</table>",
        "<!--Required to join bond and molecule tables--><column>bond.molecule_id</column>",
        "<!--Required to join bond and molecule tables--><column>molecule.molecule_id</column>",
        "<!--Filter for single bonds--><column>bond.bond_type</column>",
        "<!--Filter for non-carcinogenic molecules--><column>molecule.label</column>",
        "<!--List molecules in alphabetical order--><column>molecule.molecule_id</column>",
        "<!--Return molecule_id for top three molecules--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 234,
      "db_id": "toxicology",
      "question": "How many bonds which involved atom 12 does molecule TR009 have?",
      "evidence": "TR009 is the molecule id;  involved atom 12 refers to atom_id = 'TR009_12' or atom_id2 = 'TR009_12'",
      "SQL": "SELECT COUNT(T2.bond_id) FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.molecule_id = 'TR009' AND T2.atom_id = T1.molecule_id || '_1' OR T2.atom_id2 = T1.molecule_id || '_2'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["bond", "connected"],
        "columns": [
          "connected.bond_id",
          "bond.bond_id",
          "bond.molecule_id",
          "connected.atom_id2",
          "connected.atom_id"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for bond information\">bond</table>",
        "<table purpose=\"Required for atom connections\">connected</table>",
        "<column purpose=\"join: bond.bond_id\">connected.bond_id</column>",
        "<column purpose=\"join: connected.bond_id\">bond.bond_id</column>",
        "<column purpose=\"filter: 'molecule TR009'\">bond.molecule_id</column>",
        "<column purpose=\"filter: 'involved atom 12'\">connected.atom_id2</column>",
        "<column purpose=\"filter: 'involved atom 12'\">connected.atom_id</column>",
        "<output_schema purpose=\"count of bonds\">integer</output_schema>",
        "<error>The SQL query is incorrect. It should use 'TR009_12' for filtering atom_id and atom_id2, not '_1' and '_2'.</error>",
        "<warning>The SQL query is missing proper parentheses in the WHERE clause, which could lead to incorrect results.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'bonds which involved atom 12'--><table>connected</table>",
        "<!--Required to filter for molecule TR009--><table>bond</table>",
        "<!--filter: 'molecule TR009'--><column>bond.molecule_id</column>",
        "<!--join: connected.bond_id--><column>bond.bond_id</column>",
        "<!--join: bond.bond_id--><column>connected.bond_id</column>",
        "<!--filter: 'involved atom 12' (atom_id)--><column>connected.atom_id</column>",
        "<!--filter: 'involved atom 12' (atom_id2)--><column>connected.atom_id2</column>",
        "<!--count of bonds--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 236,
      "db_id": "toxicology",
      "question": "What are the bond type and the atoms of the bond ID of TR001_6_9?",
      "evidence": "atoms refer to atom_id or atom_id2",
      "SQL": "SELECT T1.bond_type, T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.bond_id = 'TR001_6_9'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["bond", "connected"],
        "columns": [
          "bond.bond_type",
          "connected.atom_id",
          "connected.atom_id2",
          "bond.bond_id",
          "connected.bond_id"
        ],
        "output_schema": ["text", "text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'bond type'\">bond</table>",
        "<table purpose=\"Required for 'atoms of the bond'\">connected</table>",
        "<column purpose=\"calculate: 'bond type'\">bond.bond_type</column>",
        "<column purpose=\"calculate: 'atoms of the bond'\">connected.atom_id</column>",
        "<column purpose=\"calculate: 'atoms of the bond'\">connected.atom_id2</column>",
        "<column purpose=\"filter: 'bond ID of TR001_6_9', join: connected.bond_id\">bond.bond_id</column>",
        "<column purpose=\"filter: 'bond ID of TR001_6_9', join: bond.bond_id\">connected.bond_id</column>",
        "<output_schema purpose=\"bond type\">text</output_schema>",
        "<output_schema purpose=\"atom_id\">text</output_schema>",
        "<output_schema purpose=\"atom_id2\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'bond type'--><table>bond</table>",
        "<!--Required for 'atoms of the bond'--><table>connected</table>",
        "<!--Filter: 'bond ID of TR001_6_9'--><column>bond.bond_id</column>",
        "<!--Get 'bond type'--><column>bond.bond_type</column>",
        "<!--Join: connected.bond_id--><column>connected.bond_id</column>",
        "<!--Get 'atoms of the bond'--><column>connected.atom_id</column>",
        "<!--Get 'atoms of the bond'--><column>connected.atom_id2</column>",
        "<!--bond type--><output_schema>text</output_schema>",
        "<!--atoms of the bond (atom_id)--><output_schema>text</output_schema>",
        "<!--atoms of the bond (atom_id2)--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 239,
      "db_id": "toxicology",
      "question": "How many connections does the atom 19 have?",
      "evidence": "connections refers to bond_id; atom 19 refers to atom_id like 'TR%_19';",
      "SQL": "SELECT COUNT(T.bond_id) FROM connected AS T WHERE SUBSTR(T.atom_id, -2) = '19'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["connected"],
        "columns": ["connected.bond_id", "connected.atom_id"],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for counting connections of atom 19\">connected</table>",
        "<column purpose=\"calculate: count of connections for atom 19\">connected.bond_id</column>",
        "<column purpose=\"filter: to identify atom 19\">connected.atom_id</column>",
        "<output_schema purpose=\"count of connections\">integer</output_schema>",
        "<warning>The proposal is missing connected.atom_id2, which might also be needed to fully count all connections for atom 19</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'connections' and 'atom 19'--><table>connected</table>",
        "<!--filter: 'atom 19 refers to atom_id like 'TR%_19''--><column>connected.atom_id</column>",
        "<!--filter: 'atom 19 refers to atom_id like 'TR%_19''--><column>connected.atom_id2</column>",
        "<!--count: 'How many connections'--><column>connected.bond_id</column>",
        "<!--How many connections--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 240,
      "db_id": "toxicology",
      "question": "List all the elements of the toxicology of the molecule \"TR004\".",
      "evidence": "TR004 is the molecule id;",
      "SQL": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR004'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["atom"],
        "columns": ["atom.element", "atom.molecule_id"],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains information about atoms in molecules, including their elements\">atom</table>",
        "<column purpose=\"retrieve: 'List all the elements'\">atom.element</column>",
        "<column purpose=\"filter: 'of the molecule 'TR004''\">atom.molecule_id</column>",
        "<output_schema purpose=\"List of elements\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'elements of the toxicology of the molecule \"TR004\"'--><table>atom</table>",
        "<!--Filter: 'molecule \"TR004\"'--><column>atom.molecule_id</column>",
        "<!--List: 'all the elements'--><column>atom.element</column>",
        "<!--List of elements for molecule TR004--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 242,
      "db_id": "toxicology",
      "question": "Among all the atoms from 21 to 25, list all the molecules that are carcinogenic.",
      "evidence": "atoms from 21 to 25 refers to SUBSTR(atom_id, 7, 2) between '21' and '25'; label = '+' mean molecules are carcinogenic",
      "SQL": "SELECT DISTINCT T2.molecule_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE SUBSTR(T1.atom_id, -2) BETWEEN '21' AND '25' AND T2.label = '+'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["atom", "molecule"],
        "columns": [
          "molecule.molecule_id",
          "atom.molecule_id",
          "molecule.label",
          "atom.atom_id"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'atoms from 21 to 25'\">atom</table>",
        "<table purpose=\"Required for 'molecules that are carcinogenic'\">molecule</table>",
        "<column purpose=\"output: 'list all the molecules'\">molecule.molecule_id</column>",
        "<column purpose=\"join: molecule.molecule_id\">atom.molecule_id</column>",
        "<column purpose=\"filter: 'molecules that are carcinogenic'\">molecule.label</column>",
        "<column purpose=\"filter: 'atoms from 21 to 25'\">atom.atom_id</column>",
        "<output_schema purpose=\"list of carcinogenic molecule IDs\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for atom information--><table>atom</table>",
        "<!--Required for molecule carcinogenicity information--><table>molecule</table>",
        "<!--Used to filter atoms from 21 to 25--><column>atom.atom_id</column>",
        "<!--Join atom and molecule tables--><column>atom.molecule_id</column>",
        "<!--Join atom and molecule tables--><column>molecule.molecule_id</column>",
        "<!--Filter carcinogenic molecules--><column>molecule.label</column>",
        "<!--List carcinogenic molecules--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 243,
      "db_id": "toxicology",
      "question": "What are the bonds that have phosphorus and nitrogen as their atom elements?",
      "evidence": "have phosphorus as atom elements refers to element = 'p'; have nitrogen as atom elements refers to element = 'n'",
      "SQL": "SELECT T2.bond_id FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id IN ( SELECT T3.bond_id FROM connected AS T3 INNER JOIN atom AS T4 ON T3.atom_id = T4.atom_id WHERE T4.element = 'p' ) AND T1.element = 'n'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["atom", "connected"],
        "columns": [
          "connected.bond_id",
          "connected.atom_id",
          "atom.atom_id",
          "atom.element"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for atom element information\">atom</table>",
        "<table purpose=\"Required to connect atoms and bonds\">connected</table>",
        "<column purpose=\"output: bonds with phosphorus and nitrogen atoms\">connected.bond_id</column>",
        "<column purpose=\"join: atom.atom_id\">connected.atom_id</column>",
        "<column purpose=\"join: connected.atom_id\">atom.atom_id</column>",
        "<column purpose=\"filter: 'phosphorus and nitrogen as their atom elements'\">atom.element</column>",
        "<output_schema purpose=\"bond_id of bonds with phosphorus and nitrogen atoms\">text</output_schema>",
        "<warning>The query might need to join the 'connected' table twice to ensure both phosphorus and nitrogen atoms are connected to the same bond.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'bonds that have phosphorus and nitrogen as their atom elements'--><table>bond</table>",
        "<!--Required to identify atoms with phosphorus and nitrogen--><table>atom</table>",
        "<!--Required to connect atoms to bonds--><table>connected</table>",
        "<!--Join bond with connected--><column>bond.bond_id</column>",
        "<!--Join connected with atom--><column>connected.atom_id</column>",
        "<!--Join connected with atom for the second atom in the bond--><column>connected.atom_id2</column>",
        "<!--Join atom with connected--><column>atom.atom_id</column>",
        "<!--Filter for phosphorus atoms: 'element = 'p''--><column>atom.element</column>",
        "<!--Identify the bonds--><column>bond.bond_id</column>",
        "<!--Provide information about the bond type--><column>bond.bond_type</column>",
        "<!--Bonds with phosphorus and nitrogen--><output_schema>text</output_schema>",
        "<!--Bond type information--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 244,
      "db_id": "toxicology",
      "question": "Is the molecule with the most double bonds carcinogenic?",
      "evidence": "double bond refers to bond_type = ' = '; label = '+' mean molecules are carcinogenic",
      "SQL": "SELECT T1.label FROM molecule AS T1 INNER JOIN ( SELECT T.molecule_id, COUNT(T.bond_type) FROM bond AS T WHERE T.bond_type = '=' GROUP BY T.molecule_id ORDER BY COUNT(T.bond_type) DESC LIMIT 1 ) AS T2 ON T1.molecule_id = T2.molecule_id",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["molecule", "bond"],
        "columns": [
          "bond.molecule_id",
          "bond.bond_type",
          "molecule.label",
          "molecule.molecule_id"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for carcinogenic information\">molecule</table>",
        "<table purpose=\"Required for counting double bonds\">bond</table>",
        "<column purpose=\"join: molecule.molecule_id, group by: count double bonds per molecule\">bond.molecule_id</column>",
        "<column purpose=\"filter: 'double bond refers to bond_type = ' = ''\">bond.bond_type</column>",
        "<column purpose=\"output: 'Is the molecule ... carcinogenic?', filter: 'label = '+' mean molecules are carcinogenic'\">molecule.label</column>",
        "<column purpose=\"join: bond.molecule_id\">molecule.molecule_id</column>",
        "<output_schema purpose=\"carcinogenic status ('+' or '-')\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for counting double bonds--><table>bond</table>",
        "<!--Required for carcinogenic information--><table>molecule</table>",
        "<!--Filter for double bonds--><column>bond.bond_type</column>",
        "<!--Group by molecule--><column>bond.molecule_id</column>",
        "<!--Join bond and molecule tables--><column>molecule.molecule_id</column>",
        "<!--Determine if carcinogenic--><column>molecule.label</column>",
        "<!--Molecule ID with most double bonds--><output_schema>text</output_schema>",
        "<!--Number of double bonds in that molecule--><output_schema>integer</output_schema>",
        "<!--Whether the molecule is carcinogenic--><output_schema>boolean</output_schema>"
      ]
    },
    {
      "question_id": 245,
      "db_id": "toxicology",
      "question": "What is the average number of bonds the atoms with the element iodine have?",
      "evidence": "atoms with the element iodine refers to element = 'i'; average = DIVIDE(COUND(bond_id), COUNT(atom_id)) where element = 'i'",
      "SQL": "SELECT CAST(COUNT(T2.bond_id) AS REAL) / COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.element = 'i'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["atom", "connected"],
        "columns": [
          "connected.bond_id",
          "atom.atom_id",
          "connected.atom_id",
          "atom.element"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for filtering atoms with element 'iodine'\">atom</table>",
        "<table purpose=\"Required for counting bonds connected to atoms\">connected</table>",
        "<column purpose=\"calculate: count of bonds for average\">connected.bond_id</column>",
        "<column purpose=\"calculate: count of atoms for average\">atom.atom_id</column>",
        "<column purpose=\"join: atom.atom_id\">connected.atom_id</column>",
        "<column purpose=\"filter: 'atoms with the element iodine'\">atom.element</column>",
        "<output_schema purpose=\"average number of bonds\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'atoms with the element iodine'--><table>atom</table>",
        "<!--Required for counting bonds--><table>connected</table>",
        "<!--Filter: 'atoms with the element iodine'--><column>atom.element</column>",
        "<!--Join: atom.atom_id--><column>connected.atom_id</column>",
        "<!--Join: atom.atom_id--><column>connected.atom_id2</column>",
        "<!--Count bonds for average calculation--><column>connected.bond_id</column>",
        "<!--Identify unique atoms for average calculation--><column>atom.atom_id</column>",
        "<!--Average number of bonds--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 247,
      "db_id": "toxicology",
      "question": "List all the elements of atoms that can not bond with any other atoms.",
      "evidence": " atoms cannot bond with other atoms means atom_id NOT in connected table;",
      "SQL": "SELECT DISTINCT T.element FROM atom AS T WHERE T.element NOT IN ( SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id )",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["atom", "connected"],
        "columns": ["atom.element", "atom.atom_id", "connected.atom_id"],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for listing elements of atoms\">atom</table>",
        "<table purpose=\"Required to check if atoms can bond with others\">connected</table>",
        "<column purpose=\"output: List all the elements of atoms\">atom.element</column>",
        "<column purpose=\"join: connected.atom_id\">atom.atom_id</column>",
        "<column purpose=\"join: atom.atom_id\">connected.atom_id</column>",
        "<output_schema purpose=\"elements of atoms that cannot bond\">text</output_schema>",
        "<warning>The proposal is missing DISTINCT for the element column, which is needed to avoid duplicate elements in the output.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'elements of atoms'--><table>atom</table>",
        "<!--Required to check atoms that cannot bond--><table>connected</table>",
        "<!--Needed to identify atoms--><column>atom.atom_id</column>",
        "<!--Needed to check if atom is in connected table--><column>connected.atom_id</column>",
        "<!--Needed to check if atom is in connected table (as second atom)--><column>connected.atom_id2</column>",
        "<!--Required to list 'elements of atoms'--><column>atom.element</column>",
        "<!--List of elements that cannot bond--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 248,
      "db_id": "toxicology",
      "question": "What are the atoms of the triple bond with the molecule \"TR041\"?",
      "evidence": "TR041 is the molecule id; triple bond refers to bond_type = '#';",
      "SQL": "SELECT T2.atom_id, T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T3.bond_type = '#' AND T3.molecule_id = 'TR041'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["atom", "connected", "bond"],
        "columns": [
          "connected.atom_id",
          "connected.atom_id2",
          "atom.atom_id",
          "connected.bond_id",
          "bond.bond_id",
          "bond.bond_type",
          "bond.molecule_id"
        ],
        "output_schema": ["text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to get atom information\">atom</table>",
        "<table purpose=\"Required to connect atoms and bonds\">connected</table>",
        "<table purpose=\"Required to filter for triple bonds and specific molecule\">bond</table>",
        "<column purpose=\"output: one of the atoms in the triple bond\">connected.atom_id</column>",
        "<column purpose=\"output: the other atom in the triple bond\">connected.atom_id2</column>",
        "<column purpose=\"join: with connected.atom_id\">atom.atom_id</column>",
        "<column purpose=\"join: with bond.bond_id\">connected.bond_id</column>",
        "<column purpose=\"join: with connected.bond_id\">bond.bond_id</column>",
        "<column purpose=\"filter: 'triple bond refers to bond_type = '#''\">bond.bond_type</column>",
        "<column purpose=\"filter: 'molecule TR041'\">bond.molecule_id</column>",
        "<output_schema purpose=\"atom ID of one atom in the triple bond\">text</output_schema>",
        "<output_schema purpose=\"atom ID of the other atom in the triple bond\">text</output_schema>",
        "<warning>The atom table is included in the query but not used in the output. Consider removing it if it's not needed for additional filtering or joining.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'atoms of the triple bond'--><table>atom</table>",
        "<!--Required for 'triple bond'--><table>bond</table>",
        "<!--Required to connect atoms and bonds--><table>connected</table>",
        "<!--Filter: 'with the molecule \"TR041\"'--><column>atom.molecule_id</column>",
        "<!--Filter: 'with the molecule \"TR041\"'--><column>bond.molecule_id</column>",
        "<!--Filter: 'triple bond'--><column>bond.bond_type</column>",
        "<!--Join: bond.bond_id--><column>connected.bond_id</column>",
        "<!--Join: atom.atom_id--><column>connected.atom_id</column>",
        "<!--Join: atom.atom_id--><column>connected.atom_id2</column>",
        "<!--Output: atoms of the triple bond--><column>atom.atom_id</column>",
        "<!--Output: chemical element of the atoms--><column>atom.element</column>",
        "<!--Atom identifier--><output_schema>text</output_schema>",
        "<!--Chemical element of the atom--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 249,
      "db_id": "toxicology",
      "question": "What are the elements of the atoms of TR144_8_19?",
      "evidence": "TR144_8_19 is the bond id; ",
      "SQL": "SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR144_8_19'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["connected", "atom"],
        "columns": [
          "atom.element",
          "connected.atom_id",
          "atom.atom_id",
          "connected.bond_id"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to find atoms connected by the given bond\">connected</table>",
        "<table purpose=\"Required to get element information for the atoms\">atom</table>",
        "<column purpose=\"calculate: 'elements of the atoms'\">atom.element</column>",
        "<column purpose=\"join: atom.atom_id\">connected.atom_id</column>",
        "<column purpose=\"join: connected.atom_id\">atom.atom_id</column>",
        "<column purpose=\"filter: 'TR144_8_19 is the bond id'\">connected.bond_id</column>",
        "<output_schema purpose=\"elements of the atoms\">text</output_schema>",
        "<warning>The query only considers one of the two atoms connected by the bond. To get both atoms' elements, you should also join on connected.atom_id2 or use a UNION.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for bond information--><table>bond</table>",
        "<!--Required for atom information--><table>atom</table>",
        "<!--Required for connection between bond and atoms--><table>connected</table>",
        "<!--To identify the specific bond--><column>bond.bond_id</column>",
        "<!--To link bond with connected atoms--><column>connected.bond_id</column>",
        "<!--To get the atoms connected by the bond--><column>connected.atom_id</column>",
        "<!--To get the atoms connected by the bond--><column>connected.atom_id2</column>",
        "<!--To link connected atoms with their elements--><column>atom.atom_id</column>",
        "<!--To get the elements of the atoms--><column>atom.element</column>",
        "<!--Elements of the atoms connected by the bond--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 253,
      "db_id": "toxicology",
      "question": "List the elements of all the triple bonds.",
      "evidence": "triple bond refers to bond_type = '#';",
      "SQL": "SELECT DISTINCT T3.element FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id INNER JOIN atom AS T3 ON T2.atom_id = T3.atom_id WHERE T1.bond_type = '#'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["bond", "connected", "atom"],
        "columns": [
          "atom.element",
          "bond.bond_id",
          "connected.bond_id",
          "connected.atom_id",
          "atom.atom_id",
          "bond.bond_type"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for filtering triple bonds\">bond</table>",
        "<table purpose=\"Required to connect bonds with atoms\">connected</table>",
        "<table purpose=\"Required to get element information\">atom</table>",
        "<column purpose=\"output: 'List the elements'\">atom.element</column>",
        "<column purpose=\"join: connected.bond_id\">bond.bond_id</column>",
        "<column purpose=\"join: bond.bond_id\">connected.bond_id</column>",
        "<column purpose=\"join: atom.atom_id\">connected.atom_id</column>",
        "<column purpose=\"join: connected.atom_id\">atom.atom_id</column>",
        "<column purpose=\"filter: 'triple bonds'\">bond.bond_type</column>",
        "<output_schema purpose=\"element names are text\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'elements' and 'triple bonds'--><table>atom</table>",
        "<!--Required for 'triple bonds'--><table>bond</table>",
        "<!--Required to connect atoms and bonds--><table>connected</table>",
        "<!--join: atom.atom_id--><column>connected.atom_id</column>",
        "<!--join: atom.atom_id--><column>connected.atom_id2</column>",
        "<!--join: bond.bond_id--><column>connected.bond_id</column>",
        "<!--join: bond.bond_id--><column>bond.bond_id</column>",
        "<!--filter: 'triple bonds'--><column>bond.bond_type</column>",
        "<!--'elements of all the triple bonds'--><column>atom.element</column>",
        "<!--List the elements--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 255,
      "db_id": "toxicology",
      "question": "What proportion of single bonds are carcinogenic? Please provide your answer as a percentage with five decimal places.",
      "evidence": "single bond refers to bond_type = '-'; label = '+' mean molecules are carcinogenic; proportion = DIVIDE(SUM(label = '+') * 100, COUNT(bond_id)) where bond_type = '-'",
      "SQL": "SELECT ROUND(CAST(COUNT(CASE WHEN T2.label = '+' THEN T1.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T1.bond_id),5) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '-'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["bond", "molecule"],
        "columns": [
          "molecule.label",
          "bond.bond_id",
          "bond.molecule_id",
          "molecule.molecule_id",
          "bond.bond_type"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for bond information and filtering single bonds\">bond</table>",
        "<table purpose=\"Required for carcinogenic information\">molecule</table>",
        "<column purpose=\"filter: carcinogenic molecules ('label = '+'')\">molecule.label</column>",
        "<column purpose=\"calculate: count of bonds\">bond.bond_id</column>",
        "<column purpose=\"join: bond.molecule_id\">bond.molecule_id</column>",
        "<column purpose=\"join: molecule.molecule_id\">molecule.molecule_id</column>",
        "<column purpose=\"filter: single bonds ('bond_type = '-'')\">bond.bond_type</column>",
        "<output_schema purpose=\"proportion of single bonds that are carcinogenic as a percentage\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'single bonds'--><table>bond</table>",
        "<!--Required for 'carcinogenic' information--><table>molecule</table>",
        "<!--Filter: 'single bond refers to bond_type = '-''--><column>bond.bond_type</column>",
        "<!--Join: bond.molecule_id--><column>molecule.molecule_id</column>",
        "<!--Filter: 'label = '+' mean molecules are carcinogenic'--><column>molecule.label</column>",
        "<!--Required for calculation: 'proportion = DIVIDE(SUM(label = '+') * 100, COUNT(bond_id))'--><column>bond.bond_id</column>",
        "<!--Proportion of single bonds that are carcinogenic--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 260,
      "db_id": "toxicology",
      "question": "Calculate the total atoms with triple-bond molecules containing the element phosphorus or bromine.",
      "evidence": "triple bond refers to bond_type = '#'; phosphorus refers to element = 'p'; bromine refers to element = 'br'",
      "SQL": "SELECT COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '#' AND T1.element IN ('p', 'br')",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["atom", "molecule", "bond"],
        "columns": [
          "atom.atom_id",
          "atom.molecule_id",
          "molecule.molecule_id",
          "bond.molecule_id",
          "bond.bond_type",
          "atom.element"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for atom information and element filtering\">atom</table>",
        "<table purpose=\"Required for joining atom and bond information\">molecule</table>",
        "<table purpose=\"Required for bond type filtering\">bond</table>",
        "<column purpose=\"calculate: 'total atoms'\">atom.atom_id</column>",
        "<column purpose=\"join: molecule.molecule_id\">atom.molecule_id</column>",
        "<column purpose=\"join: atom.molecule_id, bond.molecule_id\">molecule.molecule_id</column>",
        "<column purpose=\"join: molecule.molecule_id\">bond.molecule_id</column>",
        "<column purpose=\"filter: 'triple-bond molecules'\">bond.bond_type</column>",
        "<column purpose=\"filter: 'element phosphorus or bromine'\">atom.element</column>",
        "<output_schema purpose=\"count of atoms\">integer</output_schema>",
        "<warning>The query may double count atoms if a molecule has multiple triple bonds. Consider using DISTINCT in the COUNT function or grouping by molecule_id and atom_id to avoid this.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'atoms with triple-bond molecules'--><table>atom</table>",
        "<!--Required for 'triple-bond molecules'--><table>bond</table>",
        "<!--Required to connect atoms and bonds--><table>connected</table>",
        "<!--Required to join atom and bond tables--><table>molecule</table>",
        "<!--filter: 'element phosphorus or bromine'--><column>atom.element</column>",
        "<!--join: atom.molecule_id--><column>molecule.molecule_id</column>",
        "<!--join: molecule.molecule_id--><column>bond.molecule_id</column>",
        "<!--filter: 'triple-bond'--><column>bond.bond_type</column>",
        "<!--join: atom.atom_id--><column>connected.atom_id</column>",
        "<!--join: connected.atom_id--><column>atom.atom_id</column>",
        "<!--join: connected.bond_id--><column>bond.bond_id</column>",
        "<!--Calculate: 'total atoms'--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 263,
      "db_id": "toxicology",
      "question": "What is the composition of element chlorine in percentage among the single bond molecules?",
      "evidence": "element chlorine refers to element = 'cl'; single bond refers to bond_type = '-'; percentage = DIVIDE(SUM(element = 'cl'), COUNT(atom_id)) as percent where bond_type = '-'",
      "SQL": "SELECT CAST(COUNT(CASE WHEN T.element = 'cl' THEN T.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(T.atom_id) FROM ( SELECT T1.atom_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '-' ) AS T",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["atom", "molecule", "bond"],
        "columns": [
          "atom.element",
          "atom.atom_id",
          "atom.molecule_id",
          "molecule.molecule_id",
          "bond.molecule_id",
          "bond.bond_type"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for atom information, including element and atom_id\">atom</table>",
        "<table purpose=\"Required to join atom and bond tables\">molecule</table>",
        "<table purpose=\"Required to filter for single bond molecules\">bond</table>",
        "<column purpose=\"filter: 'element chlorine refers to element = 'cl''\">atom.element</column>",
        "<column purpose=\"calculate: 'percentage = DIVIDE(SUM(element = 'cl'), COUNT(atom_id))'\">atom.atom_id</column>",
        "<column purpose=\"join: molecule.molecule_id\">atom.molecule_id</column>",
        "<column purpose=\"join: atom.molecule_id, bond.molecule_id\">molecule.molecule_id</column>",
        "<column purpose=\"join: molecule.molecule_id\">bond.molecule_id</column>",
        "<column purpose=\"filter: 'single bond refers to bond_type = '-''\">bond.bond_type</column>",
        "<output_schema purpose=\"percentage of chlorine atoms in single bond molecules\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for element information--><table>atom</table>",
        "<!--Required for bond type information--><table>bond</table>",
        "<!--Required to link atoms and bonds--><table>connected</table>",
        "<!--Required to identify unique molecules--><table>molecule</table>",
        "<!--To filter for chlorine atoms--><column>atom.element</column>",
        "<!--To filter for single bonds--><column>bond.bond_type</column>",
        "<!--To count total atoms--><column>atom.atom_id</column>",
        "<!--To link atom and connected tables--><column>atom.atom_id</column>",
        "<!--To link atom and connected tables--><column>connected.atom_id</column>",
        "<!--To link bond and connected tables--><column>connected.bond_id</column>",
        "<!--To link bond and connected tables--><column>bond.bond_id</column>",
        "<!--To ensure we're counting unique molecules--><column>atom.molecule_id</column>",
        "<!--To ensure we're counting unique molecules--><column>bond.molecule_id</column>",
        "<!--To ensure we're counting unique molecules--><column>molecule.molecule_id</column>",
        "<!--Percentage of chlorine atoms in single bond molecules--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 268,
      "db_id": "toxicology",
      "question": "What are the elements for bond id TR001_10_11?",
      "evidence": "TR001_10_11 is the bond id;",
      "SQL": "SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR001_10_11'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["connected", "atom"],
        "columns": [
          "atom.element",
          "connected.atom_id",
          "atom.atom_id",
          "connected.bond_id"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to find atoms connected by the given bond\">connected</table>",
        "<table purpose=\"Required to get element information for the connected atoms\">atom</table>",
        "<column purpose=\"calculate: 'elements for bond id TR001_10_11'\">atom.element</column>",
        "<column purpose=\"join: atom.atom_id\">connected.atom_id</column>",
        "<column purpose=\"join: connected.atom_id\">atom.atom_id</column>",
        "<column purpose=\"filter: 'bond id TR001_10_11'\">connected.bond_id</column>",
        "<output_schema purpose=\"elements for the given bond\">text</output_schema>",
        "<warning>The proposal is missing connected.atom_id2, which is needed to get both elements connected by the bond</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for bond information--><table>bond</table>",
        "<!--Required for atom information--><table>atom</table>",
        "<!--Required for connecting bonds to atoms--><table>connected</table>",
        "<!--To filter the specific bond: 'TR001_10_11 is the bond id'--><column>bond.bond_id</column>",
        "<!--To link bond to connected atoms--><column>connected.bond_id</column>",
        "<!--To get atom IDs for the bond--><column>connected.atom_id</column>",
        "<!--To get atom IDs for the bond--><column>connected.atom_id2</column>",
        "<!--To link connected atoms to their elements--><column>atom.atom_id</column>",
        "<!--To get the elements: 'What are the elements'--><column>atom.element</column>",
        "<!--Elements for the specified bond--><output_schema>text</output_schema>",
        "<!--Elements for the specified bond--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 273,
      "db_id": "toxicology",
      "question": "What is the percentage of element chlorine in carcinogenic molecules?",
      "evidence": "chlorine refers to element = 'cl'; label = '+' mean molecules are carcinogenic; percentage = DIVIDE(SUM(element = 'pb'); COUNT(molecule_id)) as percentage where label = '+'",
      "SQL": "SELECT CAST(COUNT( CASE WHEN T1.element = 'cl' THEN T1.element ELSE NULL END) AS REAL) * 100 / COUNT(T1.element) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["atom", "molecule"],
        "columns": [
          "atom.element",
          "atom.molecule_id",
          "molecule.molecule_id",
          "molecule.label"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for element information\">atom</table>",
        "<table purpose=\"Required for carcinogenic information\">molecule</table>",
        "<column purpose=\"filter: 'element chlorine', calculate: percentage of chlorine\">atom.element</column>",
        "<column purpose=\"join: molecule.molecule_id\">atom.molecule_id</column>",
        "<column purpose=\"join: atom.molecule_id\">molecule.molecule_id</column>",
        "<column purpose=\"filter: 'carcinogenic molecules'\">molecule.label</column>",
        "<output_schema purpose=\"percentage of chlorine in carcinogenic molecules\">real</output_schema>",
        "<error>The SQL query does not match the description in the question. The question asks for element 'cl', but the SQL uses 'pb' (lead).</error>",
        "<warning>The SQL query calculates the percentage differently from the description in the question. It uses COUNT(CASE WHEN element = 'cl' THEN element ELSE NULL END) / COUNT(element) * 100, while the question suggests SUM(element = 'cl') / COUNT(molecule_id).</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for molecule information and carcinogenic status--><table>molecule</table>",
        "<!--Required for atom information and element type--><table>atom</table>",
        "<!--Join molecule and atom tables--><column>molecule.molecule_id</column>",
        "<!--Join molecule and atom tables--><column>atom.molecule_id</column>",
        "<!--Filter for carcinogenic molecules--><column>molecule.label</column>",
        "<!--Filter for chlorine atoms--><column>atom.element</column>",
        "<!--Calculate percentage of chlorine in carcinogenic molecules--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 281,
      "db_id": "toxicology",
      "question": "Tally the toxicology element of the 4th atom of each molecule that was carcinogenic.",
      "evidence": "label = '+' means molecules are carcinogenic; 4th atom of each molecule refers to substr(atom_id, 7, 1) = '4'; ",
      "SQL": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND SUBSTR(T1.atom_id, -1) = '4' AND LENGTH(T1.atom_id) = 7",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["atom", "molecule"],
        "columns": [
          "atom.element",
          "atom.molecule_id",
          "molecule.molecule_id",
          "molecule.label",
          "atom.atom_id"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for atom information and element\">atom</table>",
        "<table purpose=\"Required for carcinogenic information\">molecule</table>",
        "<column purpose=\"calculate: 'Tally the toxicology element'\">atom.element</column>",
        "<column purpose=\"join: molecule.molecule_id\">atom.molecule_id</column>",
        "<column purpose=\"join: atom.molecule_id\">molecule.molecule_id</column>",
        "<column purpose=\"filter: 'molecules that were carcinogenic'\">molecule.label</column>",
        "<column purpose=\"filter: '4th atom of each molecule'\">atom.atom_id</column>",
        "<output_schema purpose=\"element of the 4th atom\">text</output_schema>",
        "<warning>The proposal is missing a COUNT or GROUP BY clause to tally the elements</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for molecule carcinogenicity--><table>molecule</table>",
        "<!--Required for atom information--><table>atom</table>",
        "<!--Filter carcinogenic molecules--><column>molecule.label</column>",
        "<!--Join molecule and atom tables--><column>molecule.molecule_id</column>",
        "<!--Join molecule and atom tables--><column>atom.molecule_id</column>",
        "<!--Identify 4th atom of each molecule--><column>atom.atom_id</column>",
        "<!--Tally the toxicology element--><column>atom.element</column>",
        "<!--Element name for output--><output_schema>text</output_schema>",
        "<!--Count of each element for output--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 282,
      "db_id": "toxicology",
      "question": "What is the ratio of Hydrogen elements in molecule ID TR006? List the ratio with its label.",
      "evidence": "hydrogen refers to element = 'h'; ratio = DIVIDE(SUM(element = 'h'), count(element)) where molecule_id = 'TR006' ; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic",
      "SQL": "WITH SubQuery AS (SELECT DISTINCT T1.atom_id, T1.element, T1.molecule_id, T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.molecule_id = 'TR006') SELECT CAST(COUNT(CASE WHEN element = 'h' THEN atom_id ELSE NULL END) AS REAL) / (CASE WHEN COUNT(atom_id) = 0 THEN NULL ELSE COUNT(atom_id) END) AS ratio, label FROM SubQuery GROUP BY label",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["atom", "molecule"],
        "columns": [
          "atom.atom_id",
          "atom.element",
          "atom.molecule_id",
          "molecule.label",
          "molecule.molecule_id"
        ],
        "output_schema": ["null", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for atom information and element counts\">atom</table>",
        "<table purpose=\"Required for molecule label information\">molecule</table>",
        "<column purpose=\"join: molecule.molecule_id, filter: 'molecule ID TR006'\">atom.molecule_id</column>",
        "<column purpose=\"filter: 'Hydrogen elements', calculate: ratio of Hydrogen\">atom.element</column>",
        "<column purpose=\"join: atom.molecule_id\">molecule.molecule_id</column>",
        "<column purpose=\"output: 'List the ratio with its label'\">molecule.label</column>",
        "<column warning=\"Not necessary for the calculation\">atom.atom_id</column>",
        "<output_schema error=\"Incorrect output type for ratio\">null</output_schema>",
        "<output_schema purpose=\"label output\">text</output_schema>",
        "<error>Missing output schema for ratio (should be REAL or FLOAT)</error>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Hydrogen elements in molecule ID TR006'--><table>atom</table>",
        "<!--Required for 'label' information--><table>molecule</table>",
        "<!--Filter: 'in molecule ID TR006'--><column>atom.molecule_id</column>",
        "<!--Calculate: 'ratio of Hydrogen elements'--><column>atom.element</column>",
        "<!--Join: atom.molecule_id--><column>molecule.molecule_id</column>",
        "<!--'List the ratio with its label'--><column>molecule.label</column>",
        "<!--Ratio of Hydrogen elements--><output_schema>real</output_schema>",
        "<!--Label indicating carcinogenicity--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 327,
      "db_id": "toxicology",
      "question": "Which non-carcinogenic molecules consisted more than 5 atoms?",
      "evidence": "label = '-' means molecules are non-carcinogenic; molecules consisted more than 5 atoms refers to COUNT(molecule_id) > 5",
      "SQL": "SELECT T.molecule_id FROM ( SELECT T1.molecule_id, COUNT(T2.atom_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '-' GROUP BY T1.molecule_id HAVING COUNT(T2.atom_id) > 5 ) t",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["molecule", "atom"],
        "columns": [
          "molecule.molecule_id",
          "atom.molecule_id",
          "molecule.label",
          "atom.atom_id"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for identifying non-carcinogenic molecules\">molecule</table>",
        "<table purpose=\"Required for counting atoms in molecules\">atom</table>",
        "<column purpose=\"join: atom.molecule_id, output: result\">molecule.molecule_id</column>",
        "<column purpose=\"join: molecule.molecule_id\">atom.molecule_id</column>",
        "<column purpose=\"filter: 'non-carcinogenic molecules'\">molecule.label</column>",
        "<column purpose=\"calculate: 'consisted more than 5 atoms'\">atom.atom_id</column>",
        "<output_schema purpose=\"molecule_id of non-carcinogenic molecules with more than 5 atoms\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for molecule information and carcinogenicity--><table>molecule</table>",
        "<!--Required for atom count per molecule--><table>atom</table>",
        "<!--Filter: 'non-carcinogenic molecules'--><column>molecule.label</column>",
        "<!--Join: molecule.molecule_id--><column>atom.molecule_id</column>",
        "<!--Count atoms per molecule--><column>atom.atom_id</column>",
        "<!--Output: molecules with more than 5 atoms--><column>molecule.molecule_id</column>",
        "<!--Molecule identifier--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 5,
      "db_id": "california_schools",
      "question": "How many schools with an average score in Math greater than 400 in the SAT test are exclusively virtual?",
      "evidence": "Exclusively virtual refers to Virtual = 'F'",
      "SQL": "SELECT COUNT(DISTINCT T2.School) FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.Virtual = 'F' AND T1.AvgScrMath > 400",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["satscores", "schools"],
        "columns": [
          "schools.School",
          "satscores.cds",
          "schools.CDSCode",
          "schools.Virtual",
          "satscores.AvgScrMath"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains SAT score data, including Math scores\">satscores</table>",
        "<table purpose=\"Contains school information, including virtual status\">schools</table>",
        "<column purpose=\"Not necessary for the count; DISTINCT is applied to CDSCode\">schools.School</column>",
        "<column purpose=\"join: schools.CDSCode\">satscores.cds</column>",
        "<column purpose=\"join: satscores.cds\">schools.CDSCode</column>",
        "<column purpose=\"filter: 'exclusively virtual'\">schools.Virtual</column>",
        "<column purpose=\"filter: 'average score in Math greater than 400'\">satscores.AvgScrMath</column>",
        "<output_schema purpose=\"count of schools meeting the criteria\">integer</output_schema>",
        "<warning>The query uses COUNT(DISTINCT T2.School), but schools.School is not necessary for this count. Using COUNT(DISTINCT T2.CDSCode) or simply COUNT(*) after joining and filtering would be more appropriate.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for SAT Math scores--><table>satscores</table>",
        "<!--Required for virtual school information--><table>schools</table>",
        "<!--Join satscores with schools--><column>satscores.cds</column>",
        "<!--Join schools with satscores--><column>schools.CDSCode</column>",
        "<!--Filter: 'average score in Math greater than 400'--><column>satscores.AvgScrMath</column>",
        "<!--Filter: 'exclusively virtual'--><column>schools.Virtual</column>",
        "<!--Count of schools meeting criteria--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 11,
      "db_id": "california_schools",
      "question": "Please list the codes of the schools with a total enrollment of over 500.",
      "evidence": "Total enrollment can be represented by \"Enrollment (K-12)\" + \"Enrollment (Ages 5-17)\"",
      "SQL": "SELECT T2.CDSCode FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.\"Enrollment (K-12)\" + T2.\"Enrollment (Ages 5-17)\" > 500",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["schools", "frpm"],
        "columns": [
          "frpm.CDSCode",
          "schools.CDSCode",
          "frpm.Enrollment (K-12)",
          "frpm.Enrollment (Ages 5-17)"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for joining with frpm table\">schools</table>",
        "<table purpose=\"Contains enrollment data needed for the calculation\">frpm</table>",
        "<column purpose=\"join: schools.CDSCode, output: 'codes of the schools'\">frpm.CDSCode</column>",
        "<column purpose=\"join: frpm.CDSCode\">schools.CDSCode</column>",
        "<column purpose=\"calculate: 'total enrollment'\">frpm.\"Enrollment (K-12)\"</column>",
        "<column purpose=\"calculate: 'total enrollment'\">frpm.\"Enrollment (Ages 5-17)\"</column>",
        "<output_schema purpose=\"codes of the schools\">text</output_schema>",
        "<warning>The proposal is missing a filter condition to select only schools with total enrollment over 500</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'codes of the schools'--><table>frpm</table>",
        "<!--Required for 'codes of the schools'--><column>frpm.CDSCode</column>",
        "<!--Required for 'total enrollment'--><column>frpm.\"Enrollment (K-12)\"</column>",
        "<!--Required for 'total enrollment'--><column>frpm.\"Enrollment (Ages 5-17)\"</column>",
        "<!--codes of the schools--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 12,
      "db_id": "california_schools",
      "question": "Among the schools with an SAT excellence rate of over 0.3, what is the highest eligible free rate for students aged 5-17?",
      "evidence": "Excellence rate = NumGE1500 / NumTstTakr; Eligible free rates for students aged 5-17 = \"Free Meal Count (Ages 5-17)\" / \"Enrollment (Ages 5-17)\"",
      "SQL": "SELECT MAX(CAST(T1.\"Free Meal Count (Ages 5-17)\" AS REAL) / T1.\"Enrollment (Ages 5-17)\") FROM frpm AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE CAST(T2.NumGE1500 AS REAL) / T2.NumTstTakr > 0.3",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["frpm", "satscores"],
        "columns": [
          "frpm.Free Meal Count (Ages 5-17)",
          "frpm.Enrollment (Ages 5-17)",
          "frpm.CDSCode",
          "satscores.cds",
          "satscores.NumGE1500",
          "satscores.NumTstTakr"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains data on free meal eligibility and enrollment\">frpm</table>",
        "<table purpose=\"Contains SAT score data\">satscores</table>",
        "<column purpose=\"calculate: 'Eligible free rates for students aged 5-17'\">frpm.Free Meal Count (Ages 5-17)</column>",
        "<column purpose=\"calculate: 'Eligible free rates for students aged 5-17'\">frpm.Enrollment (Ages 5-17)</column>",
        "<column purpose=\"join: satscores.cds\">frpm.CDSCode</column>",
        "<column purpose=\"join: frpm.CDSCode\">satscores.cds</column>",
        "<column purpose=\"calculate: 'SAT excellence rate'\">satscores.NumGE1500</column>",
        "<column purpose=\"calculate: 'SAT excellence rate'\">satscores.NumTstTakr</column>",
        "<output_schema purpose=\"highest eligible free rate for students aged 5-17\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for SAT excellence rate calculation--><table>satscores</table>",
        "<!--Required for eligible free rate calculation--><table>frpm</table>",
        "<!--Join satscores and frpm tables--><table>schools</table>",
        "<!--Calculate SAT excellence rate--><column>satscores.NumGE1500</column>",
        "<!--Calculate SAT excellence rate--><column>satscores.NumTstTakr</column>",
        "<!--Calculate eligible free rate--><column>frpm.\"Free Meal Count (Ages 5-17)\"</column>",
        "<!--Calculate eligible free rate--><column>frpm.\"Enrollment (Ages 5-17)\"</column>",
        "<!--Join satscores and schools tables--><column>satscores.cds</column>",
        "<!--Join schools and frpm tables--><column>schools.CDSCode</column>",
        "<!--Highest eligible free rate--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 17,
      "db_id": "california_schools",
      "question": "Rank schools by their average score in Writing where the score is greater than 499, showing their charter numbers.",
      "evidence": "Valid charter number means the number is not null",
      "SQL": "SELECT CharterNum, AvgScrWrite, RANK() OVER (ORDER BY AvgScrWrite DESC) AS WritingScoreRank FROM schools AS T1  INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T2.AvgScrWrite > 499 AND CharterNum is not null",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["schools", "satscores"],
        "columns": [
          "schools.CharterNum",
          "satscores.AvgScrWrite",
          "schools.CDSCode",
          "satscores.cds"
        ],
        "output_schema": ["text", "integer", "integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for charter numbers and joining with satscores\">schools</table>",
        "<table purpose=\"Required for SAT Writing scores\">satscores</table>",
        "<column purpose=\"output: 'showing their charter numbers'\">schools.CharterNum</column>",
        "<column purpose=\"filter: 'score is greater than 499', calculate: 'average score in Writing', rank: 'Rank schools by their average score in Writing'\">satscores.AvgScrWrite</column>",
        "<column purpose=\"join: schools.CDSCode\">schools.CDSCode</column>",
        "<column purpose=\"join: satscores.cds\">satscores.cds</column>",
        "<output_schema purpose=\"charter numbers\">text</output_schema>",
        "<output_schema purpose=\"average score in Writing\">integer</output_schema>",
        "<output_schema purpose=\"rank of schools\">integer</output_schema>",
        "<warning>The proposal doesn't explicitly mention the filter condition for valid charter numbers (not null). This should be included in the SQL query.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'average score in Writing'--><table>satscores</table>",
        "<!--Required for 'charter numbers'--><table>schools</table>",
        "<!--join: satscores.cds--><column>schools.CDSCode</column>",
        "<!--join: schools.CDSCode--><column>satscores.cds</column>",
        "<!--filter: 'score is greater than 499'--><column>satscores.AvgScrWrite</column>",
        "<!--'charter numbers'--><column>schools.CharterNum</column>",
        "<!--'Rank schools'--><output_schema>integer</output_schema>",
        "<!--'showing their charter numbers'--><output_schema>text</output_schema>",
        "<!--'average score in Writing'--><output_schema>integer</output_schema>",
        "<!--'school name'--><column>satscores.sname</column>",
        "<!--'school name'--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 23,
      "db_id": "california_schools",
      "question": "List the names of schools with more than 30 difference in enrollements between K-12 and ages 5-17? Please also give the full street adress of the schools.",
      "evidence": "Diffrence in enrollement = \"Enrollment (K-12)\" - \"Enrollment (Ages 5-17)\"",
      "SQL": "SELECT T1.School, T1.Street FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.\"Enrollment (K-12)\" - T2.\"Enrollment (Ages 5-17)\" > 30",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["schools", "frpm"],
        "columns": [
          "schools.School",
          "schools.Street",
          "schools.CDSCode",
          "frpm.CDSCode",
          "frpm.Enrollment (K-12)",
          "frpm.Enrollment (Ages 5-17)"
        ],
        "output_schema": ["text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for school names and addresses\">schools</table>",
        "<table purpose=\"Required for enrollment data\">frpm</table>",
        "<column purpose=\"output: 'names of schools'\">schools.School</column>",
        "<column purpose=\"output: 'full street address of the schools'\">schools.Street</column>",
        "<column purpose=\"join: frpm.CDSCode\">schools.CDSCode</column>",
        "<column purpose=\"join: schools.CDSCode\">frpm.CDSCode</column>",
        "<column purpose=\"calculate: 'difference in enrollments'\">frpm.Enrollment (K-12)</column>",
        "<column purpose=\"calculate: 'difference in enrollments'\">frpm.Enrollment (Ages 5-17)</column>",
        "<output_schema purpose=\"school names\">text</output_schema>",
        "<output_schema purpose=\"school addresses\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'names of schools' and enrollment data--><table>frpm</table>",
        "<!--Required for 'full street address'--><table>schools</table>",
        "<!--Join frpm and schools tables--><column>frpm.CDSCode</column>",
        "<!--Join frpm and schools tables--><column>schools.CDSCode</column>",
        "<!--Calculate difference in enrollments--><column>frpm.\"Enrollment (K-12)\"</column>",
        "<!--Calculate difference in enrollments--><column>frpm.\"Enrollment (Ages 5-17)\"</column>",
        "<!--'names of schools'--><column>frpm.\"School Name\"</column>",
        "<!--'full street address'--><column>schools.Street</column>",
        "<!--'full street address'--><column>schools.City</column>",
        "<!--'full street address'--><column>schools.State</column>",
        "<!--'full street address'--><column>schools.Zip</column>",
        "<!--'names of schools'--><output_schema>text</output_schema>",
        "<!--'full street address'--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 24,
      "db_id": "california_schools",
      "question": "Give the names of the schools with the percent eligible for free meals in K-12 is more than 0.1 and test takers whose test score is greater than or equal to 1500?",
      "evidence": "Percent eligible for free meals = Free Meal Count (K-12) / Total (Enrollment (K-12)",
      "SQL": "SELECT T2.\"School Name\" FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode WHERE CAST(T2.\"Free Meal Count (K-12)\" AS REAL) / T2.\"Enrollment (K-12)\" > 0.1 AND T1.NumGE1500 > 0",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["satscores", "frpm"],
        "columns": [
          "frpm.School Name",
          "satscores.cds",
          "frpm.CDSCode",
          "frpm.Free Meal Count (K-12)",
          "frpm.Enrollment (K-12)",
          "satscores.NumGE1500"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for SAT score data\">satscores</table>",
        "<table purpose=\"Required for free meal eligibility data\">frpm</table>",
        "<column purpose=\"output: 'names of the schools'\">frpm.School Name</column>",
        "<column purpose=\"join: frpm.CDSCode\">satscores.cds</column>",
        "<column purpose=\"join: satscores.cds\">frpm.CDSCode</column>",
        "<column purpose=\"calculate: 'percent eligible for free meals'\">frpm.Free Meal Count (K-12)</column>",
        "<column purpose=\"calculate: 'percent eligible for free meals'\">frpm.Enrollment (K-12)</column>",
        "<column purpose=\"filter: 'test takers whose test score is greater than or equal to 1500'\">satscores.NumGE1500</column>",
        "<output_schema purpose=\"names of the schools\">text</output_schema>",
        "<warning>Consider adding frpm.Percent (%) Eligible Free (K-12) as it directly represents the percentage of students eligible for free meals, which could simplify the calculation.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'percent eligible for free meals'--><table>frpm</table>",
        "<!--Required for 'test takers whose test score is greater than or equal to 1500'--><table>satscores</table>",
        "<!--Required for joining and getting school names--><table>schools</table>",
        "<!--Calculate: 'percent eligible for free meals'--><column>frpm.\"Free Meal Count (K-12)\"</column>",
        "<!--Calculate: 'percent eligible for free meals'--><column>frpm.\"Enrollment (K-12)\"</column>",
        "<!--Filter: 'test score is greater than or equal to 1500'--><column>satscores.NumGE1500</column>",
        "<!--Join: frpm.CDSCode--><column>schools.CDSCode</column>",
        "<!--Join: satscores.cds--><column>schools.CDSCode</column>",
        "<!--Output: 'names of the schools'--><column>schools.School</column>",
        "<!--Names of the schools meeting the criteria--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 25,
      "db_id": "california_schools",
      "question": "Name schools in Riverside which the average of average math score for SAT is grater than 400, what is the funding type of these schools?",
      "evidence": "Average of average math = sum(average math scores) / count(schools).",
      "SQL": "SELECT T1.sname, T2.\"Charter Funding Type\" FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode WHERE T2.\"District Name\" LIKE 'Riverside%' GROUP BY T1.sname, T2.\"Charter Funding Type\" HAVING CAST(SUM(T1.AvgScrMath) AS REAL) / COUNT(T1.cds) > 400",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["satscores", "frpm"],
        "columns": [
          "satscores.sname",
          "frpm.Charter Funding Type",
          "satscores.cds",
          "frpm.CDSCode",
          "frpm.District Name",
          "satscores.AvgScrMath"
        ],
        "output_schema": ["text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains SAT score data\">satscores</table>",
        "<table purpose=\"Contains school funding type information\">frpm</table>",
        "<column purpose=\"output: school name\">satscores.sname</column>",
        "<column purpose=\"output: funding type of schools\">frpm.Charter Funding Type</column>",
        "<column purpose=\"join: satscores.cds\">satscores.cds</column>",
        "<column purpose=\"join: frpm.CDSCode\">frpm.CDSCode</column>",
        "<column purpose=\"filter: 'schools in Riverside'\">frpm.District Name</column>",
        "<column purpose=\"calculate: 'average of average math score for SAT'\">satscores.AvgScrMath</column>",
        "<output_schema purpose=\"school name\">text</output_schema>",
        "<output_schema purpose=\"funding type\">text</output_schema>",
        "<warning>The proposed tables and columns are correct, but the SQL query might need modification to accurately calculate the average of average math scores as specified in the question.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'schools in Riverside'--><table>schools</table>",
        "<!--Required for 'average math score for SAT'--><table>satscores</table>",
        "<!--Filter: 'in Riverside'--><column>schools.County</column>",
        "<!--Join: schools.CDSCode--><column>satscores.cds</column>",
        "<!--Join: satscores.cds--><column>schools.CDSCode</column>",
        "<!--Calculate: 'average of average math score'--><column>satscores.AvgScrMath</column>",
        "<!--Output: 'Name schools'--><column>schools.School</column>",
        "<!--Output: 'funding type of these schools'--><column>schools.FundingType</column>",
        "<!--Name of schools--><output_schema>text</output_schema>",
        "<!--Funding type of schools--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 26,
      "db_id": "california_schools",
      "question": "State the names and full communication address of high schools in Monterey which has more than 800 free or reduced price meals for ages 15-17?",
      "evidence": "Full communication address should include Street, City, State and zip code if any.",
      "SQL": "SELECT T1.\"School Name\", T2.Street, T2.City, T2.State, T2.Zip FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Monterey' AND T1.\"Free Meal Count (Ages 5-17)\" > 800 AND T1.\"School Type\" = 'High Schools (Public)'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["frpm", "schools"],
        "columns": [
          "frpm.School Name",
          "schools.Street",
          "schools.City",
          "schools.State",
          "schools.Zip",
          "frpm.CDSCode",
          "schools.CDSCode",
          "schools.County",
          "frpm.Free Meal Count (Ages 5-17)",
          "frpm.School Type"
        ],
        "output_schema": ["text", "text", "text", "text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains school information including free meal count\">frpm</table>",
        "<table purpose=\"Contains detailed school address information\">schools</table>",
        "<column purpose=\"output: name of the high school\">frpm.School Name</column>",
        "<column purpose=\"output: part of full communication address\">schools.Street</column>",
        "<column purpose=\"output: part of full communication address\">schools.City</column>",
        "<column purpose=\"output: part of full communication address\">schools.State</column>",
        "<column purpose=\"output: part of full communication address\">schools.Zip</column>",
        "<column purpose=\"join: to link frpm and schools tables\">frpm.CDSCode</column>",
        "<column purpose=\"join: to link frpm and schools tables\">schools.CDSCode</column>",
        "<column purpose=\"filter: to select schools in Monterey\">schools.County</column>",
        "<column purpose=\"filter: to select schools with more than 800 free or reduced price meals\">frpm.Free Meal Count (Ages 5-17)</column>",
        "<column purpose=\"filter: to select high schools\">frpm.School Type</column>",
        "<output_schema purpose=\"School Name\">text</output_schema>",
        "<output_schema purpose=\"Street address\">text</output_schema>",
        "<output_schema purpose=\"City\">text</output_schema>",
        "<output_schema purpose=\"State\">text</output_schema>",
        "<output_schema purpose=\"ZIP code\">text</output_schema>",
        "<warning>The query uses \"Free Meal Count (Ages 5-17)\" instead of \"FRPM Count (Ages 5-17)\". The latter would be more appropriate for free or reduced price meals.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Filter for 'high schools'--><table>frpm</table>",
        "<!--Filter for 'in Monterey'--><column>frpm.\"County Name\"</column>",
        "<!--Filter for 'high schools'--><column>frpm.\"School Type\"</column>",
        "<!--Filter for 'more than 800 free or reduced price meals for ages 15-17'--><column>frpm.\"FRPM Count (Ages 5-17)\"</column>",
        "<!--Required for 'names and full communication address'--><table>schools</table>",
        "<!--Join frpm and schools tables--><column>frpm.CDSCode</column>",
        "<!--Join frpm and schools tables--><column>schools.CDSCode</column>",
        "<!--Output 'names'--><column>schools.School</column>",
        "<!--Output 'full communication address': Street--><column>schools.Street</column>",
        "<!--Output 'full communication address': City--><column>schools.City</column>",
        "<!--Output 'full communication address': State--><column>schools.State</column>",
        "<!--Output 'full communication address': zip code--><column>schools.Zip</column>",
        "<!--School name--><output_schema>text</output_schema>",
        "<!--Street address--><output_schema>text</output_schema>",
        "<!--City--><output_schema>text</output_schema>",
        "<!--State--><output_schema>text</output_schema>",
        "<!--Zip code--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 27,
      "db_id": "california_schools",
      "question": "What is the average score in writing for the schools that were opened after 1991 or closed before 2000? List the school names along with the score. Also, list the communication number of the schools if there is any.",
      "evidence": "Communication number refers to phone number.",
      "SQL": "SELECT T2.School, T1.AvgScrWrite, T2.Phone FROM schools AS T2 LEFT JOIN satscores AS T1 ON T2.CDSCode = T1.cds WHERE strftime('%Y', T2.OpenDate) > '1991' OR strftime('%Y', T2.ClosedDate) < '2000'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["schools", "satscores"],
        "columns": [
          "schools.School",
          "satscores.AvgScrWrite",
          "schools.Phone",
          "satscores.cds",
          "schools.CDSCode",
          "schools.ClosedDate",
          "schools.OpenDate"
        ],
        "output_schema": ["text", "integer", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains school information including opening and closing dates\">schools</table>",
        "<table purpose=\"Contains SAT score data including writing scores\">satscores</table>",
        "<column purpose=\"Output: 'List the school names'\">schools.School</column>",
        "<column purpose=\"Output: 'average score in writing'\">satscores.AvgScrWrite</column>",
        "<column purpose=\"Output: 'communication number of the schools'\">schools.Phone</column>",
        "<column purpose=\"join: schools.CDSCode\">satscores.cds</column>",
        "<column purpose=\"join: satscores.cds\">schools.CDSCode</column>",
        "<column purpose=\"filter: 'closed before 2000'\">schools.ClosedDate</column>",
        "<column purpose=\"filter: 'opened after 1991'\">schools.OpenDate</column>",
        "<output_schema purpose=\"School name\">text</output_schema>",
        "<output_schema purpose=\"Average writing score\">integer</output_schema>",
        "<output_schema purpose=\"Phone number\">text</output_schema>",
        "<warning>The query doesn't include an aggregation for the average writing score across schools. If you want an overall average, you'll need to use AVG() in your SQL query.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'average score in writing'--><table>satscores</table>",
        "<!--Required for 'schools that were opened after 1991 or closed before 2000' and 'school names'--><table>schools</table>",
        "<!--join: schools.CDSCode--><column>satscores.cds</column>",
        "<!--join: satscores.cds--><column>schools.CDSCode</column>",
        "<!--filter: 'opened after 1991'--><column>schools.OpenDate</column>",
        "<!--filter: 'closed before 2000'--><column>schools.ClosedDate</column>",
        "<!--'average score in writing'--><column>satscores.AvgScrWrite</column>",
        "<!--'List the school names'--><column>schools.School</column>",
        "<!--'communication number of the schools'--><column>schools.Phone</column>",
        "<!--school names--><output_schema>text</output_schema>",
        "<!--average score in writing--><output_schema>integer</output_schema>",
        "<!--communication number (phone number)--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 28,
      "db_id": "california_schools",
      "question": "Consider the average difference between K-12 enrollment and 15-17 enrollment of schools that are locally funded, list the names and DOC type of schools which has a difference above this average.",
      "evidence": "Difference between K-12 enrollment and 15-17 enrollment can be computed by \"Enrollment (K-12)\" - \"Enrollment (Ages 5-17)\"",
      "SQL": "SELECT T2.School, T2.DOC FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.FundingType = 'Locally funded' AND (T1.\"Enrollment (K-12)\" - T1.\"Enrollment (Ages 5-17)\") > (SELECT AVG(T3.\"Enrollment (K-12)\" - T3.\"Enrollment (Ages 5-17)\") FROM frpm AS T3 INNER JOIN schools AS T4 ON T3.CDSCode = T4.CDSCode WHERE T4.FundingType = 'Locally funded')",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["frpm", "schools"],
        "columns": [
          "frpm.Enrollment (K-12)",
          "frpm.Enrollment (Ages 5-17)",
          "frpm.CDSCode",
          "schools.CDSCode",
          "schools.FundingType",
          "schools.School",
          "schools.DOC"
        ],
        "output_schema": ["text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains enrollment data for K-12 and Ages 5-17\">frpm</table>",
        "<table purpose=\"Contains school information including funding type and DOC\">schools</table>",
        "<column purpose=\"calculate: difference between K-12 and 5-17 enrollment\">frpm.Enrollment (K-12)</column>",
        "<column purpose=\"calculate: difference between K-12 and 5-17 enrollment\">frpm.Enrollment (Ages 5-17)</column>",
        "<column purpose=\"join: schools.CDSCode\">frpm.CDSCode</column>",
        "<column purpose=\"join: frpm.CDSCode\">schools.CDSCode</column>",
        "<column purpose=\"filter: 'locally funded' schools\">schools.FundingType</column>",
        "<column purpose=\"output: 'names of schools'\">schools.School</column>",
        "<column purpose=\"output: 'DOC type of schools'\">schools.DOC</column>",
        "<warning>schools.DOCType should be used instead of schools.DOC to get the DOC type (text description) as requested in the question</warning>",
        "<output_schema purpose=\"School name\">text</output_schema>",
        "<output_schema purpose=\"DOC type\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'locally funded' schools--><table>schools</table>",
        "<!--Required for enrollment data--><table>frpm</table>",
        "<!--Join schools and frpm tables--><column>schools.CDSCode</column>",
        "<!--Join schools and frpm tables--><column>frpm.CDSCode</column>",
        "<!--Filter for 'locally funded' schools--><column>schools.FundingType</column>",
        "<!--Calculate enrollment difference--><column>frpm.\"Enrollment (K-12)\"</column>",
        "<!--Calculate enrollment difference--><column>frpm.\"Enrollment (Ages 5-17)\"</column>",
        "<!--Output: school name--><column>schools.School</column>",
        "<!--Output: DOC type--><column>schools.DOCType</column>",
        "<!--Output: school name--><output_schema>text</output_schema>",
        "<!--Output: DOC type--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 31,
      "db_id": "california_schools",
      "question": "What is the eligible free rate of the 10th and 11th schools with the highest enrolment for students in grades 1 through 12?",
      "evidence": "K-12 refers to students in grades 1 through 12; Eligible free rate for K-12 = \"Free Meal Count (K-12)\" / \"Enrollment (K-12)\"",
      "SQL": "SELECT CAST(\"Free Meal Count (K-12)\" AS REAL) / \"Enrollment (K-12)\" FROM frpm ORDER BY \"Enrollment (K-12)\" DESC LIMIT 9, 2",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["frpm"],
        "columns": ["frpm.Free Meal Count (K-12)", "frpm.Enrollment (K-12)"],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains the required enrollment and free meal count data\">frpm</table>",
        "<column purpose=\"calculate: numerator for 'eligible free rate'\">frpm.\"Free Meal Count (K-12)\"</column>",
        "<column purpose=\"calculate: denominator for 'eligible free rate', and filter: 'highest enrolment for students in grades 1 through 12'\">frpm.\"Enrollment (K-12)\"</column>",
        "<output_schema purpose=\"result of division for 'eligible free rate'\">real</output_schema>",
        "<warning>The proposal is missing an explicit reference to the LIMIT and OFFSET clauses needed to get the 10th and 11th schools.</warning>",
        "<warning>The proposal doesn't explicitly mention the ORDER BY clause needed for \"highest enrolment\".</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for enrollment and free meal data--><table>frpm</table>",
        "<!--Required for sorting by enrollment--><column>frpm.\"Enrollment (K-12)\"</column>",
        "<!--Required for calculating eligible free rate--><column>frpm.\"Free Meal Count (K-12)\"</column>",
        "<!--Required for calculating eligible free rate--><column>frpm.\"Enrollment (K-12)\"</column>",
        "<!--Required to identify schools--><column>frpm.\"School Name\"</column>",
        "<!--School name for the 10th and 11th highest enrollment schools--><output_schema>text</output_schema>",
        "<!--Eligible free rate for the 10th highest enrollment school--><output_schema>real</output_schema>",
        "<!--Eligible free rate for the 11th highest enrollment school--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 32,
      "db_id": "california_schools",
      "question": "What is the eligible free or reduced price meal rate for the top 5 schools in grades 1-12 with the highest free or reduced price meal count of the schools with the ownership code 66?",
      "evidence": "grades 1-12 means K-12; Eligible free or reduced price meal rate for K-12 = \"FRPM Count (K-12)\" / \"Enrollment (K-12)\"",
      "SQL": "SELECT CAST(T1.\"FRPM Count (K-12)\" AS REAL) / T1.\"Enrollment (K-12)\" FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.SOC = 66 ORDER BY T1.\"FRPM Count (K-12)\" DESC LIMIT 5",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["frpm", "schools"],
        "columns": [
          "frpm.FRPM Count (K-12)",
          "frpm.Enrollment (K-12)",
          "frpm.CDSCode",
          "schools.CDSCode",
          "schools.SOC"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains FRPM and enrollment data\">frpm</table>",
        "<table purpose=\"Contains school ownership code (SOC) data\">schools</table>",
        "<column purpose=\"calculate: 'free or reduced price meal count', filter: 'top 5 schools'\">frpm.FRPM Count (K-12)</column>",
        "<column purpose=\"calculate: 'Eligible free or reduced price meal rate'\">frpm.Enrollment (K-12)</column>",
        "<column purpose=\"join: schools.CDSCode\">frpm.CDSCode</column>",
        "<column purpose=\"join: frpm.CDSCode\">schools.CDSCode</column>",
        "<column purpose=\"filter: 'ownership code 66'\">schools.SOC</column>",
        "<output_schema purpose=\"Eligible free or reduced price meal rate\">real</output_schema>",
        "<warning>The query uses CAST to ensure floating-point division. Consider using CAST in your calculation to avoid integer division.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'eligible free or reduced price meal rate'--><table>frpm</table>",
        "<!--Required for 'ownership code 66'--><table>schools</table>",
        "<!--Join frpm and schools tables--><column>frpm.CDSCode</column>",
        "<!--Join frpm and schools tables--><column>schools.CDSCode</column>",
        "<!--Filter: 'ownership code 66'--><column>schools.SOC</column>",
        "<!--Calculate: 'eligible free or reduced price meal rate'--><column>frpm.\"FRPM Count (K-12)\"</column>",
        "<!--Calculate: 'eligible free or reduced price meal rate'--><column>frpm.\"Enrollment (K-12)\"</column>",
        "<!--Sort: 'top 5 schools'--><column>frpm.\"FRPM Count (K-12)\"</column>",
        "<!--Output: school name--><column>frpm.\"School Name\"</column>",
        "<!--Output: school name--><output_schema>text</output_schema>",
        "<!--Output: eligible free or reduced price meal rate--><output_schema>real</output_schema>",
        "<!--Output: FRPM count--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 37,
      "db_id": "california_schools",
      "question": "What is the complete address of the school with the lowest excellence rate? Indicate the Street, City, Zip and State.",
      "evidence": "Execellence Rate = NumGE1500 / NumTstTakr; complete address has Street, City, State, Zip code",
      "SQL": "SELECT T2.Street, T2.City, T2.State, T2.Zip FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY CAST(T1.NumGE1500 AS REAL) / T1.NumTstTakr ASC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["satscores", "schools"],
        "columns": [
          "schools.Street",
          "schools.City",
          "schools.State",
          "schools.Zip",
          "satscores.cds",
          "schools.CDSCode",
          "satscores.NumGE1500",
          "satscores.NumTstTakr"
        ],
        "output_schema": ["text", "text", "text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains SAT score data needed for excellence rate calculation\">satscores</table>",
        "<table purpose=\"Contains address information for schools\">schools</table>",
        "<column purpose=\"Part of the complete address: 'Street'\">schools.Street</column>",
        "<column purpose=\"Part of the complete address: 'City'\">schools.City</column>",
        "<column purpose=\"Part of the complete address: 'State'\">schools.State</column>",
        "<column purpose=\"Part of the complete address: 'Zip'\">schools.Zip</column>",
        "<column purpose=\"Join key with schools.CDSCode\">satscores.cds</column>",
        "<column purpose=\"Join key with satscores.cds\">schools.CDSCode</column>",
        "<column purpose=\"Calculate: numerator of excellence rate\">satscores.NumGE1500</column>",
        "<column purpose=\"Calculate: denominator of excellence rate\">satscores.NumTstTakr</column>",
        "<output_schema purpose=\"Street address\">text</output_schema>",
        "<output_schema purpose=\"City name\">text</output_schema>",
        "<output_schema purpose=\"State abbreviation\">text</output_schema>",
        "<output_schema purpose=\"ZIP code\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'excellence rate' calculation--><table>satscores</table>",
        "<!--Required for address information--><table>schools</table>",
        "<!--Join satscores and schools--><column>satscores.cds</column>",
        "<!--Join satscores and schools--><column>schools.CDSCode</column>",
        "<!--Calculate 'excellence rate'--><column>satscores.NumGE1500</column>",
        "<!--Calculate 'excellence rate'--><column>satscores.NumTstTakr</column>",
        "<!--'Street' part of complete address--><column>schools.Street</column>",
        "<!--'City' part of complete address--><column>schools.City</column>",
        "<!--'State' part of complete address--><column>schools.State</column>",
        "<!--'Zip code' part of complete address--><column>schools.Zip</column>",
        "<!--Street address--><output_schema>text</output_schema>",
        "<!--City--><output_schema>text</output_schema>",
        "<!--State--><output_schema>text</output_schema>",
        "<!--Zip code--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 36,
      "db_id": "california_schools",
      "question": "Under whose administration is the school with the highest number of students scoring 1500 or more on the SAT? Indicate their full names.",
      "evidence": "full name means first name, last name; There are at most 3 administrators for each school; SAT Scores are greater or equal to 1500 refers to NumGE1500",
      "SQL": "SELECT T2.AdmFName1, T2.AdmLName1, T2.AdmFName2, T2.AdmLName2, T2.AdmFName3, T2.AdmLName3 FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["satscores", "schools"],
        "columns": [
          "schools.AdmFName1",
          "schools.AdmLName1",
          "schools.AdmFName2",
          "schools.AdmLName2",
          "schools.AdmFName3",
          "schools.AdmLName3",
          "satscores.cds",
          "schools.CDSCode",
          "satscores.NumGE1500"
        ],
        "output_schema": ["text", "text", "text", "text", "text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains SAT score data, including NumGE1500\">satscores</table>",
        "<table purpose=\"Contains school administrator information\">schools</table>",
        "<column purpose=\"Output: first name of first administrator\">schools.AdmFName1</column>",
        "<column purpose=\"Output: last name of first administrator\">schools.AdmLName1</column>",
        "<column purpose=\"Output: first name of second administrator\">schools.AdmFName2</column>",
        "<column purpose=\"Output: last name of second administrator\">schools.AdmLName2</column>",
        "<column purpose=\"Output: first name of third administrator\">schools.AdmFName3</column>",
        "<column purpose=\"Output: last name of third administrator\">schools.AdmLName3</column>",
        "<column purpose=\"Join: link satscores to schools\">satscores.cds</column>",
        "<column purpose=\"Join: link schools to satscores\">schools.CDSCode</column>",
        "<column purpose=\"Filter: identify school with highest number of students scoring 1500 or more\">satscores.NumGE1500</column>",
        "<output_schema purpose=\"First name of administrator\">text</output_schema>",
        "<output_schema purpose=\"Last name of administrator\">text</output_schema>",
        "<output_schema purpose=\"First name of administrator (if exists)\">text</output_schema>",
        "<output_schema purpose=\"Last name of administrator (if exists)\">text</output_schema>",
        "<output_schema purpose=\"First name of administrator (if exists)\">text</output_schema>",
        "<output_schema purpose=\"Last name of administrator (if exists)\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'highest number of students scoring 1500 or more on the SAT'--><table>satscores</table>",
        "<!--Required for administrator information--><table>schools</table>",
        "<!--Join satscores and schools--><column>satscores.cds</column>",
        "<!--Join satscores and schools--><column>schools.CDSCode</column>",
        "<!--Identify school with highest number of students scoring 1500 or more--><column>satscores.NumGE1500</column>",
        "<!--Administrator's first name--><column>schools.AdmFName1</column>",
        "<!--Administrator's last name--><column>schools.AdmLName1</column>",
        "<!--Administrator's first name (2nd)--><column>schools.AdmFName2</column>",
        "<!--Administrator's last name (2nd)--><column>schools.AdmLName2</column>",
        "<!--Administrator's first name (3rd)--><column>schools.AdmFName3</column>",
        "<!--Administrator's last name (3rd)--><column>schools.AdmLName3</column>",
        "<!--Output: Administrator's full name(s)--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 39,
      "db_id": "california_schools",
      "question": "What is the average number of test takers from Fresno schools that opened between 1/1/1980 and 12/31/1980?",
      "evidence": "between 1/1/1980 and 12/31/1980 means the year = 1980",
      "SQL": "SELECT AVG(T1.NumTstTakr) FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE strftime('%Y', T2.OpenDate) = '1980' AND T2.County = 'Fresno'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["satscores", "schools"],
        "columns": [
          "satscores.NumTstTakr",
          "satscores.cds",
          "schools.CDSCode",
          "schools.County",
          "schools.OpenDate"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains SAT test taker data\">satscores</table>",
        "<table purpose=\"Contains school information including opening dates and county\">schools</table>",
        "<column purpose=\"calculate: 'average number of test takers'\">satscores.NumTstTakr</column>",
        "<column purpose=\"join: schools.CDSCode\">satscores.cds</column>",
        "<column purpose=\"join: satscores.cds\">schools.CDSCode</column>",
        "<column purpose=\"filter: 'Fresno schools'\">schools.County</column>",
        "<column purpose=\"filter: 'opened between 1/1/1980 and 12/31/1980'\">schools.OpenDate</column>",
        "<output_schema purpose=\"average number of test takers\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'average number of test takers'--><table>satscores</table>",
        "<!--Required for 'Fresno schools' and 'opened between 1/1/1980 and 12/31/1980'--><table>schools</table>",
        "<!--Join satscores with schools--><column>satscores.cds</column>",
        "<!--Join schools with satscores--><column>schools.CDSCode</column>",
        "<!--Filter: 'Fresno schools'--><column>schools.City</column>",
        "<!--Filter: 'opened between 1/1/1980 and 12/31/1980'--><column>schools.OpenDate</column>",
        "<!--Calculate: 'average number of test takers'--><column>satscores.NumTstTakr</column>",
        "<!--Average number of test takers--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 40,
      "db_id": "california_schools",
      "question": "What is the telephone number for the school with the lowest average score in reading in Fresno Unified?",
      "evidence": "Fresno Unified is a name of district;",
      "SQL": "SELECT T2.Phone FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.District = 'Fresno Unified' AND T1.AvgScrRead IS NOT NULL ORDER BY T1.AvgScrRead ASC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["satscores", "schools"],
        "columns": [
          "schools.Phone",
          "satscores.cds",
          "schools.CDSCode",
          "schools.District",
          "satscores.AvgScrRead"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains SAT scores data, including average reading scores\">satscores</table>",
        "<table purpose=\"Contains school information, including phone numbers and district names\">schools</table>",
        "<column purpose=\"Output: 'telephone number for the school'\">schools.Phone</column>",
        "<column purpose=\"Join: links satscores to schools\">satscores.cds</column>",
        "<column purpose=\"Join: links schools to satscores\">schools.CDSCode</column>",
        "<column purpose=\"Filter: 'Fresno Unified'\">schools.District</column>",
        "<column purpose=\"Filter and Sort: 'lowest average score in reading'\">satscores.AvgScrRead</column>",
        "<output_schema purpose=\"Phone number is stored as text\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'lowest average score in reading'--><table>satscores</table>",
        "<!--Required for 'telephone number'--><table>schools</table>",
        "<!--Filter: 'Fresno Unified'--><column>satscores.dname</column>",
        "<!--Calculate: 'lowest average score in reading'--><column>satscores.AvgScrRead</column>",
        "<!--Join: schools.CDSCode--><column>satscores.cds</column>",
        "<!--Join: satscores.cds--><column>schools.CDSCode</column>",
        "<!--Output: 'telephone number'--><column>schools.Phone</column>",
        "<!--Telephone number of the school--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 41,
      "db_id": "california_schools",
      "question": "List the names of virtual schools that are among the top 5 in their respective counties based on average reading scores.",
      "evidence": "Exclusively virtual refers to Virtual = 'F'; respective counties means PARTITION BY County",
      "SQL": "SELECT School FROM (SELECT T2.School,T1.AvgScrRead, RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC) AS rnk FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.Virtual = 'F' ) ranked_schools WHERE rnk <= 5",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["satscores", "schools"],
        "columns": [
          "schools.School",
          "schools.County",
          "satscores.AvgScrRead",
          "satscores.cds",
          "schools.CDSCode",
          "schools.Virtual"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains SAT score data including average reading scores\">satscores</table>",
        "<table purpose=\"Contains school information including virtual status and county\">schools</table>",
        "<column purpose=\"output: 'List the names of virtual schools'\">schools.School</column>",
        "<column purpose=\"filter: 'in their respective counties', used for partitioning\">schools.County</column>",
        "<column purpose=\"calculate: 'top 5 based on average reading scores'\">satscores.AvgScrRead</column>",
        "<column purpose=\"join: schools.CDSCode\">satscores.cds</column>",
        "<column purpose=\"join: satscores.cds\">schools.CDSCode</column>",
        "<column purpose=\"filter: 'Exclusively virtual refers to Virtual = 'F''\">schools.Virtual</column>",
        "<output_schema purpose=\"school names are text\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'virtual schools'--><table>schools</table>",
        "<!--Required for 'average reading scores'--><table>satscores</table>",
        "<!--filter: 'Exclusively virtual'--><column>schools.Virtual</column>",
        "<!--join: satscores.cds--><column>schools.CDSCode</column>",
        "<!--join: schools.CDSCode--><column>satscores.cds</column>",
        "<!--filter and group: 'respective counties'--><column>schools.County</column>",
        "<!--calculate: 'average reading scores'--><column>satscores.AvgScrRead</column>",
        "<!--'names of virtual schools'--><column>schools.School</column>",
        "<!--names of virtual schools--><output_schema>text</output_schema>",
        "<!--respective counties--><output_schema>text</output_schema>",
        "<!--average reading scores--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 45,
      "db_id": "california_schools",
      "question": "What is the average writing score of each of the schools managed by Ricci Ulrich? List the schools and the corresponding average writing scores.",
      "evidence": "Usually, administrators manage the school stuff.",
      "SQL": "SELECT T2.School, T1.AvgScrWrite FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.AdmFName1 = 'Ricci' AND T2.AdmLName1 = 'Ulrich'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["satscores", "schools"],
        "columns": [
          "schools.School",
          "satscores.AvgScrWrite",
          "satscores.cds",
          "schools.CDSCode",
          "schools.AdmFName1",
          "schools.AdmLName1"
        ],
        "output_schema": ["text", "integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains SAT score data, including average writing scores\">satscores</table>",
        "<table purpose=\"Contains school information, including administrator names\">schools</table>",
        "<column purpose=\"Output: school name\">schools.School</column>",
        "<column purpose=\"Output: average writing score\">satscores.AvgScrWrite</column>",
        "<column purpose=\"Join: links satscores to schools\">satscores.cds</column>",
        "<column purpose=\"Join: links schools to satscores\">schools.CDSCode</column>",
        "<column purpose=\"Filter: administrator's first name\">schools.AdmFName1</column>",
        "<column purpose=\"Filter: administrator's last name\">schools.AdmLName1</column>",
        "<output_schema purpose=\"School name\">text</output_schema>",
        "<output_schema purpose=\"Average writing score\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for school information and administrator details--><table>schools</table>",
        "<!--Required for SAT score data--><table>satscores</table>",
        "<!--Join: schools.CDSCode--><column>satscores.cds</column>",
        "<!--Join: satscores.cds--><column>schools.CDSCode</column>",
        "<!--Filter: 'managed by Ricci Ulrich'--><column>schools.AdmFName1</column>",
        "<!--Filter: 'managed by Ricci Ulrich'--><column>schools.AdmLName1</column>",
        "<!--Filter: 'managed by Ricci Ulrich'--><column>schools.AdmFName2</column>",
        "<!--Filter: 'managed by Ricci Ulrich'--><column>schools.AdmLName2</column>",
        "<!--Filter: 'managed by Ricci Ulrich'--><column>schools.AdmFName3</column>",
        "<!--Filter: 'managed by Ricci Ulrich'--><column>schools.AdmLName3</column>",
        "<!--Output: 'List the schools'--><column>schools.School</column>",
        "<!--Output: 'average writing score'--><column>satscores.AvgScrWrite</column>",
        "<!--School names--><output_schema>text</output_schema>",
        "<!--Average writing scores--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 46,
      "db_id": "california_schools",
      "question": "Which state special schools have the highest number of enrollees from grades 1 through 12?",
      "evidence": "State Special Schools refers to DOC = 31; Grades 1 through 12 means K-12",
      "SQL": "SELECT T2.School FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.DOC = 31 ORDER BY T1.\"Enrollment (K-12)\" DESC LIMIT 1",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["frpm", "schools"],
        "columns": [
          "schools.School",
          "frpm.CDSCode",
          "schools.CDSCode",
          "schools.DOC",
          "frpm.Enrollment (K-12)"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains enrollment data for schools\">frpm</table>",
        "<table purpose=\"Contains school information including DOC (District Ownership Code)\">schools</table>",
        "<column purpose=\"Output: name of the school with highest enrollment\">schools.School</column>",
        "<column purpose=\"Join: link frpm and schools tables\">frpm.CDSCode</column>",
        "<column purpose=\"Join: link frpm and schools tables\">schools.CDSCode</column>",
        "<column purpose=\"Filter: identify state special schools (DOC = 31)\">schools.DOC</column>",
        "<column purpose=\"Sort: determine highest number of enrollees\">frpm.\"Enrollment (K-12)\"</column>",
        "<output_schema purpose=\"Return school name as text\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'state special schools'--><table>schools</table>",
        "<!--Required for 'number of enrollees from grades 1 through 12'--><table>satscores</table>",
        "<!--filter: 'State Special Schools refers to DOC = 31'--><column>schools.DOC</column>",
        "<!--join: schools.CDSCode--><column>satscores.cds</column>",
        "<!--join: satscores.cds--><column>schools.CDSCode</column>",
        "<!--calculate: 'number of enrollees from grades 1 through 12'--><column>satscores.enroll12</column>",
        "<!--Required for school identification--><column>schools.School</column>",
        "<!--state special schools--><output_schema>text</output_schema>",
        "<!--highest number of enrollees from grades 1 through 12--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 47,
      "db_id": "california_schools",
      "question": "What is the monthly average number of schools that opened in Alameda County under the jurisdiction of the Elementary School District in 1980?",
      "evidence": "Elementary School District refers to DOC = 52; Monthly average number of schools that opened in 1980 = count(schools that opened in 1980) / 12",
      "SQL": "SELECT CAST(COUNT(School) AS REAL) / 12 FROM schools WHERE DOC = 52 AND County = 'Alameda' AND strftime('%Y', OpenDate) = '1980'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["schools"],
        "columns": [
          "schools.School",
          "schools.County",
          "schools.DOC",
          "schools.OpenDate"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains school opening dates and district information\">schools</table>",
        "<column purpose=\"Used for counting schools\">schools.School</column>",
        "<column purpose=\"Filter: 'in Alameda County'\">schools.County</column>",
        "<column purpose=\"Filter: 'Elementary School District (DOC = 52)'\">schools.DOC</column>",
        "<column purpose=\"Filter: 'opened in 1980'\">schools.OpenDate</column>",
        "<output_schema purpose=\"Monthly average number of schools\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for school openings in Alameda County--><table>schools</table>",
        "<!--Filter: 'in Alameda County'--><column>schools.County</column>",
        "<!--Filter: 'Elementary School District' (DOC = 52)--><column>schools.DOC</column>",
        "<!--Filter and calculate: 'opened in 1980'--><column>schools.OpenDate</column>",
        "<!--Monthly average number of schools--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 48,
      "db_id": "california_schools",
      "question": "What is the ratio of merged Unified School District schools in Orange County to merged Elementary School District schools?",
      "evidence": "Elementary School District refers to DOC = 52; Unified School District refers to DOC = 54.",
      "SQL": "SELECT CAST(SUM(CASE WHEN DOC = 54 THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN DOC = 52 THEN 1 ELSE 0 END) FROM schools WHERE StatusType = 'Merged' AND County = 'Orange'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["schools"],
        "columns": ["schools.DOC", "schools.County", "schools.StatusType"],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains information about schools, including their district type, county, and status\">schools</table>",
        "<column purpose=\"filter: 'Elementary School District refers to DOC = 52; Unified School District refers to DOC = 54'\">schools.DOC</column>",
        "<column purpose=\"filter: 'in Orange County'\">schools.County</column>",
        "<column purpose=\"filter: 'merged'\">schools.StatusType</column>",
        "<output_schema purpose=\"ratio of merged Unified School District schools to merged Elementary School District schools\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Unified School District' and 'Elementary School District'--><table>schools</table>",
        "<!--Filter: 'Orange County'--><column>schools.County</column>",
        "<!--Filter: 'merged'--><column>schools.StatusType</column>",
        "<!--Filter: 'Unified School District' (DOC = 54)--><column>schools.DOC</column>",
        "<!--Filter: 'Elementary School District' (DOC = 52)--><column>schools.DOC</column>",
        "<!--Count of merged Unified School District schools--><output_schema>integer</output_schema>",
        "<!--Count of merged Elementary School District schools--><output_schema>integer</output_schema>",
        "<!--Ratio of merged Unified to Elementary School District schools--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 50,
      "db_id": "california_schools",
      "question": "What is the postal street address for the school with the 7th highest Math average? Indicate the school's name.",
      "evidence": "Postal street and mailing street are synonyms.",
      "SQL": "SELECT T2.MailStreet, T2.School FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrMath DESC LIMIT 6, 1",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["satscores", "schools"],
        "columns": [
          "schools.MailStreet",
          "schools.School",
          "satscores.cds",
          "schools.CDSCode",
          "satscores.AvgScrMath"
        ],
        "output_schema": ["text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains SAT score data, including Math average\">satscores</table>",
        "<table purpose=\"Contains school information, including postal address\">schools</table>",
        "<column purpose=\"Output: 'postal street address'\">schools.MailStreet</column>",
        "<column purpose=\"Output: 'school's name'\">schools.School</column>",
        "<column purpose=\"join: schools.CDSCode\">satscores.cds</column>",
        "<column purpose=\"join: satscores.cds\">schools.CDSCode</column>",
        "<column purpose=\"filter: '7th highest Math average'\">satscores.AvgScrMath</column>",
        "<output_schema purpose=\"postal street address\">text</output_schema>",
        "<output_schema purpose=\"school's name\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Math average'--><table>satscores</table>",
        "<!--Required for 'postal street address' and 'school's name'--><table>schools</table>",
        "<!--Join satscores with schools--><column>satscores.cds</column>",
        "<!--Join schools with satscores--><column>schools.CDSCode</column>",
        "<!--Calculate and order by 'Math average'--><column>satscores.AvgScrMath</column>",
        "<!--'postal street address'--><column>schools.MailStreet</column>",
        "<!--'school's name'--><column>schools.School</column>",
        "<!--school's name--><output_schema>text</output_schema>",
        "<!--postal street address--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 62,
      "db_id": "california_schools",
      "question": "What is the total number of non-chartered schools in the county of Los Angeles with a percent (%) of eligible free meals for grades 1 through 12 that is less than 0.18%?",
      "evidence": "non-chartered schools refer to schools whose Charter = 0; K-12 means grades 1 through 12; percent of eligible free rate for K-12 = \"Free Meal Count (K-12)\" * 100 / \"Enrollment (K-12)\"",
      "SQL": "SELECT COUNT(T2.School) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Los Angeles' AND T2.Charter = 0 AND CAST(T1.\"Free Meal Count (K-12)\" AS REAL) * 100 / T1.\"Enrollment (K-12)\" < 0.18",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["frpm", "schools"],
        "columns": [
          "schools.School",
          "frpm.CDSCode",
          "schools.CDSCode",
          "schools.Charter",
          "schools.County",
          "frpm.Free Meal Count (K-12)",
          "frpm.Enrollment (K-12)"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains free meal and enrollment data\">frpm</table>",
        "<table purpose=\"Contains school information including charter status and county\">schools</table>",
        "<column purpose=\"Not necessary for the count\">schools.School</column>",
        "<column purpose=\"join: schools.CDSCode\">frpm.CDSCode</column>",
        "<column purpose=\"join: frpm.CDSCode\">schools.CDSCode</column>",
        "<column purpose=\"filter: non-chartered schools\">schools.Charter</column>",
        "<column purpose=\"filter: county of Los Angeles\">schools.County</column>",
        "<column purpose=\"calculate: percent of eligible free meals for K-12\">frpm.Free Meal Count (K-12)</column>",
        "<column purpose=\"calculate: percent of eligible free meals for K-12\">frpm.Enrollment (K-12)</column>",
        "<output_schema purpose=\"total number of non-chartered schools meeting the criteria\">integer</output_schema>",
        "<warning>The query uses COUNT(*) or COUNT(1), but the proposal includes schools.School. This is not necessary for the count.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'non-chartered schools'--><table>schools</table>",
        "<!--Required for 'percent (%) of eligible free meals for grades 1 through 12'--><table>frpm</table>",
        "<!--filter: 'non-chartered schools'--><column>schools.Charter</column>",
        "<!--filter: 'county of Los Angeles'--><column>schools.County</column>",
        "<!--join: frpm.CDSCode--><column>schools.CDSCode</column>",
        "<!--join: schools.CDSCode--><column>frpm.CDSCode</column>",
        "<!--calculate: 'percent (%) of eligible free meals for grades 1 through 12'--><column>frpm.\"Free Meal Count (K-12)\"</column>",
        "<!--calculate: 'percent (%) of eligible free meals for grades 1 through 12'--><column>frpm.\"Enrollment (K-12)\"</column>",
        "<!--total number of schools meeting criteria--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 72,
      "db_id": "california_schools",
      "question": "How many students from the ages of 5 to 17 are enrolled at the State Special School school in Fremont for the 2014-2015 academic year?",
      "evidence": "State Special School means EdOpsCode = 'SSS'",
      "SQL": "SELECT T1.\"Enrollment (Ages 5-17)\" FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.EdOpsCode = 'SSS' AND T2.City = 'Fremont' AND T1.\"Academic Year\" BETWEEN 2014 AND 2015",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["frpm", "schools"],
        "columns": [
          "frpm.Enrollment (Ages 5-17)",
          "frpm.CDSCode",
          "schools.CDSCode",
          "schools.City",
          "schools.EdOpsCode",
          "frpm.Academic Year"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains enrollment data for students ages 5-17\">frpm</table>",
        "<table purpose=\"Contains school information including location and educational option codes\">schools</table>",
        "<column purpose=\"calculate: 'How many students from the ages of 5 to 17 are enrolled'\">frpm.\"Enrollment (Ages 5-17)\"</column>",
        "<column purpose=\"join: schools.CDSCode\">frpm.CDSCode</column>",
        "<column purpose=\"join: frpm.CDSCode\">schools.CDSCode</column>",
        "<column purpose=\"filter: 'in Fremont'\">schools.City</column>",
        "<column purpose=\"filter: 'State Special School means EdOpsCode = 'SSS''\">schools.EdOpsCode</column>",
        "<column purpose=\"filter: 'for the 2014-2015 academic year'\">frpm.\"Academic Year\"</column>",
        "<output_schema purpose=\"Number of students enrolled\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for enrollment data--><table>frpm</table>",
        "<!--Required for school type information--><table>schools</table>",
        "<!--Filter: '2014-2015 academic year'--><column>frpm.\"Academic Year\"</column>",
        "<!--Enrollment data for ages 5-17--><column>frpm.\"Enrollment (Ages 5-17)\"</column>",
        "<!--Join: frpm.CDSCode--><column>frpm.CDSCode</column>",
        "<!--Join: schools.CDSCode--><column>schools.CDSCode</column>",
        "<!--Filter: 'State Special School'--><column>schools.EdOpsCode</column>",
        "<!--Filter: 'in Fremont'--><column>schools.City</column>",
        "<!--Number of students enrolled--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 77,
      "db_id": "california_schools",
      "question": "Which schools served a grade span of Kindergarten to 9th grade in the county of Los Angeles and what is its Percent (%) Eligible FRPM (Ages 5-17)?",
      "evidence": "Percent (%) Eligible FRPM (Ages 5-17) can be acquired by \"FRPM Count (Ages 5-17)\" / \"Enrollment (Ages 5-17)\" * 100",
      "SQL": "SELECT T2.School, T1.\"FRPM Count (Ages 5-17)\" * 100 / T1.\"Enrollment (Ages 5-17)\" FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Los Angeles' AND T2.GSserved = 'K-9'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["frpm", "schools"],
        "columns": [
          "schools.School",
          "frpm.FRPM Count (Ages 5-17)",
          "frpm.Enrollment (Ages 5-17)",
          "frpm.CDSCode",
          "schools.CDSCode",
          "schools.County",
          "schools.GSserved"
        ],
        "output_schema": ["text", "real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains FRPM data for schools\">frpm</table>",
        "<table purpose=\"Contains general school information\">schools</table>",
        "<column purpose=\"Output: school name\">schools.School</column>",
        "<column purpose=\"Calculate: 'Percent (%) Eligible FRPM (Ages 5-17)'\">frpm.FRPM Count (Ages 5-17)</column>",
        "<column purpose=\"Calculate: 'Percent (%) Eligible FRPM (Ages 5-17)'\">frpm.Enrollment (Ages 5-17)</column>",
        "<column purpose=\"Join: frpm.CDSCode\">frpm.CDSCode</column>",
        "<column purpose=\"Join: schools.CDSCode\">schools.CDSCode</column>",
        "<column purpose=\"Filter: 'in the county of Los Angeles'\">schools.County</column>",
        "<column purpose=\"Filter: 'served a grade span of Kindergarten to 9th grade'\">schools.GSserved</column>",
        "<output_schema purpose=\"School name\">text</output_schema>",
        "<output_schema purpose=\"Calculated Percent (%) Eligible FRPM (Ages 5-17)\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'schools served a grade span'--><table>schools</table>",
        "<!--Required for 'Percent (%) Eligible FRPM (Ages 5-17)'--><table>frpm</table>",
        "<!--Filter: 'grade span of Kindergarten to 9th grade'--><column>schools.GSserved</column>",
        "<!--Filter: 'in the county of Los Angeles'--><column>schools.County</column>",
        "<!--Join: schools.CDSCode--><column>schools.CDSCode</column>",
        "<!--Join: frpm.CDSCode--><column>frpm.CDSCode</column>",
        "<!--Calculate: 'Percent (%) Eligible FRPM (Ages 5-17)'--><column>frpm.\"FRPM Count (Ages 5-17)\"</column>",
        "<!--Calculate: 'Percent (%) Eligible FRPM (Ages 5-17)'--><column>frpm.\"Enrollment (Ages 5-17)\"</column>",
        "<!--Output: school name--><output_schema>text</output_schema>",
        "<!--Output: Percent (%) Eligible FRPM (Ages 5-17)--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 79,
      "db_id": "california_schools",
      "question": "Between San Diego and Santa Barbara, which county offers the most number of schools that does not offer physical building? Indicate the amount.",
      "evidence": "'Does not offer physical building' means Virtual = F in the database.",
      "SQL": "SELECT County, COUNT(Virtual) FROM schools WHERE (County = 'San Diego' OR County = 'Santa Barbara') AND Virtual = 'F' GROUP BY County ORDER BY COUNT(Virtual) DESC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["schools"],
        "columns": ["schools.County", "schools.Virtual"],
        "output_schema": ["text", "integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains information about schools, including county and virtual status\">schools</table>",
        "<column purpose=\"filter: 'San Diego and Santa Barbara', group by: 'which county'\">schools.County</column>",
        "<column purpose=\"filter: 'does not offer physical building', count: 'most number of schools'\">schools.Virtual</column>",
        "<output_schema purpose=\"County name\">text</output_schema>",
        "<output_schema purpose=\"Count of schools\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for county information--><table>schools</table>",
        "<!--Filter for San Diego and Santa Barbara counties--><column>schools.County</column>",
        "<!--Filter for schools without physical buildings--><column>schools.Virtual</column>",
        "<!--Count schools per county--><column>schools.CDSCode</column>",
        "<!--County with most virtual schools--><output_schema>text</output_schema>",
        "<!--Number of virtual schools in that county--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 82,
      "db_id": "california_schools",
      "question": "What is the grade span offered in the school with the highest longitude?",
      "evidence": "the highest longitude refers to the school with the maximum absolute longitude value.",
      "SQL": "SELECT GSoffered FROM schools ORDER BY ABS(longitude) DESC LIMIT 1",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["schools"],
        "columns": ["schools.GSoffered", "schools.Longitude"],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains the required information about schools, including grade span and longitude\">schools</table>",
        "<column purpose=\"Output: 'grade span offered'\">schools.GSoffered</column>",
        "<column purpose=\"Filter: 'highest longitude'\">schools.Longitude</column>",
        "<output_schema purpose=\"Grade span offered is a text value\">text</output_schema>",
        "<warning>The query should use ABS(Longitude) to find the highest absolute longitude value, as specified in the question.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'grade span offered' and 'highest longitude'--><table>schools</table>",
        "<!--'grade span offered'--><column>schools.GSoffered</column>",
        "<!--'highest longitude'--><column>schools.Longitude</column>",
        "<!--grade span offered for the school with highest longitude--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 83,
      "db_id": "california_schools",
      "question": "Of the schools that offers a magnet program serving a grade span of Kindergarten to 8th grade, how many offers Multiple Provision Types? List the number of cities that offers a Kindergarten to 8th grade span and indicate how many schools are there serving such grade span for each city.",
      "evidence": "Kindergarten to 8th grade refers to K-8; 'Offers a magnet program' means Magnet = 1; Multiple Provision Types refers to \"NSLP Provision Status\" = 'Multiple Provision Types'",
      "SQL": "SELECT T2.City, COUNT(T2.CDSCode) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.Magnet = 1 AND T2.GSoffered = 'K-8' AND T1.\"NSLP Provision Status\" = 'Multiple Provision Types' GROUP BY T2.City",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["frpm", "schools"],
        "columns": [
          "schools.City",
          "schools.CDSCode",
          "frpm.CDSCode",
          "schools.GSoffered",
          "schools.Magnet",
          "frpm.NSLP Provision Status"
        ],
        "output_schema": ["text", "integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains NSLP Provision Status information\">frpm</table>",
        "<table purpose=\"Contains school information including magnet status and grade span\">schools</table>",
        "<column purpose=\"join: frpm.CDSCode, output: 'List the number of cities'\">schools.City</column>",
        "<column purpose=\"join: frpm.CDSCode, count: 'how many schools are there serving such grade span for each city'\">schools.CDSCode</column>",
        "<column purpose=\"join: schools.CDSCode\">frpm.CDSCode</column>",
        "<column purpose=\"filter: 'serving a grade span of Kindergarten to 8th grade'\">schools.GSoffered</column>",
        "<column purpose=\"filter: 'Offers a magnet program'\">schools.Magnet</column>",
        "<column purpose=\"filter: 'Multiple Provision Types'\">frpm.NSLP Provision Status</column>",
        "<output_schema purpose=\"City names\">text</output_schema>",
        "<output_schema purpose=\"Count of schools per city\">integer</output_schema>",
        "<error>The query does not answer the first part of the question: \"Of the schools that offers a magnet program serving a grade span of Kindergarten to 8th grade, how many offers Multiple Provision Types?\" A COUNT DISTINCT or subquery is needed for this.</error>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'schools that offers a magnet program'--><table>schools</table>",
        "<!--Required for 'grade span of Kindergarten to 8th grade'--><table>schools</table>",
        "<!--Required for 'Multiple Provision Types'--><table>frpm</table>",
        "<!--Required for 'number of cities'--><table>schools</table>",
        "<!--filter: 'Offers a magnet program'--><column>schools.Magnet</column>",
        "<!--filter: 'grade span of Kindergarten to 8th grade'--><column>schools.GSserved</column>",
        "<!--join: frpm.CDSCode--><column>schools.CDSCode</column>",
        "<!--join: schools.CDSCode--><column>frpm.CDSCode</column>",
        "<!--filter: 'Multiple Provision Types'--><column>frpm.\"NSLP Provision Status\"</column>",
        "<!--count: 'how many offers Multiple Provision Types'--><output_schema>integer</output_schema>",
        "<!--group by: 'number of cities'--><column>schools.City</column>",
        "<!--count: 'how many schools are there serving such grade span for each city'--><output_schema>integer</output_schema>",
        "<!--list: 'List the number of cities'--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 85,
      "db_id": "california_schools",
      "question": "What is the Percent (%) Eligible Free (K-12) in the school administered by an administrator whose first name is Alusine. List the district code of the school.",
      "evidence": "Percent (%) Eligible Free (K-12) = \"Free Meal Count (K-12)\" / \"Enrollment (K-12)\" * 100%",
      "SQL": "SELECT T1.\"Free Meal Count (K-12)\" * 100 / T1.\"Enrollment (K-12)\", T1.\"District Code\" FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Alusine'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["frpm", "schools"],
        "columns": [
          "frpm.Free Meal Count (K-12)",
          "frpm.Enrollment (K-12)",
          "frpm.District Code",
          "frpm.CDSCode",
          "schools.CDSCode",
          "schools.AdmFName1"
        ],
        "output_schema": ["real", "integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains data on free meal eligibility and enrollment\">frpm</table>",
        "<table purpose=\"Contains administrator information\">schools</table>",
        "<column purpose=\"calculate: 'Percent (%) Eligible Free (K-12)'\">frpm.Free Meal Count (K-12)</column>",
        "<column purpose=\"calculate: 'Percent (%) Eligible Free (K-12)'\">frpm.Enrollment (K-12)</column>",
        "<column purpose=\"output: 'List the district code of the school'\">frpm.District Code</column>",
        "<column purpose=\"join: schools.CDSCode\">frpm.CDSCode</column>",
        "<column purpose=\"join: frpm.CDSCode\">schools.CDSCode</column>",
        "<column purpose=\"filter: 'administrator whose first name is Alusine'\">schools.AdmFName1</column>",
        "<output_schema purpose=\"Percent (%) Eligible Free (K-12)\">real</output_schema>",
        "<output_schema purpose=\"District Code\">integer</output_schema>",
        "<warning>The query calculates the percentage, but the frpm table already contains a column \"Percent (%) Eligible Free (K-12)\" which could be used directly instead of recalculating.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'Percent (%) Eligible Free (K-12)'--><table>frpm</table>",
        "<!--Required for administrator information--><table>schools</table>",
        "<!--Join frpm and schools tables--><column>frpm.CDSCode</column>",
        "<!--Join frpm and schools tables--><column>schools.CDSCode</column>",
        "<!--Filter: administrator whose first name is Alusine--><column>schools.AdmFName1</column>",
        "<!--Calculate: 'Free Meal Count (K-12)'--><column>frpm.\"Free Meal Count (K-12)\"</column>",
        "<!--Calculate: 'Enrollment (K-12)'--><column>frpm.\"Enrollment (K-12)\"</column>",
        "<!--Output: district code of the school--><column>frpm.\"District Code\"</column>",
        "<!--District code of the school--><output_schema>integer</output_schema>",
        "<!--Percent (%) Eligible Free (K-12)--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 87,
      "db_id": "california_schools",
      "question": "What are the valid e-mail addresses of the administrator of the school located in the San Bernardino county, City of San Bernardino City Unified that opened between 1/1/2009 to 12/31/2010 whose school types are public Intermediate/Middle Schools and Unified Schools?",
      "evidence": "Intermediate/Middle Schools refers to SOC = 62; Unified School refers to DOC = 54; years between 2009 and 2010 can refer to 'between 1/1/2009 to 12/31/2010'",
      "SQL": "SELECT T2.AdmEmail1, T2.AdmEmail2 FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'San Bernardino' AND T2.City = 'San Bernardino' AND T2.DOC = 54 AND strftime('%Y', T2.OpenDate) BETWEEN '2009' AND '2010' AND T2.SOC = 62",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["frpm", "schools"],
        "columns": [
          "schools.AdmEmail1",
          "schools.AdmEmail2",
          "frpm.CDSCode",
          "schools.CDSCode",
          "schools.City",
          "schools.County",
          "schools.DOC",
          "schools.SOC",
          "schools.OpenDate"
        ],
        "output_schema": ["text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for joining with schools table\">frpm</table>",
        "<table purpose=\"Contains administrator email and school information\">schools</table>",
        "<column purpose=\"Output: administrator's primary email\">schools.AdmEmail1</column>",
        "<column purpose=\"Output: administrator's secondary email\">schools.AdmEmail2</column>",
        "<column purpose=\"Join: with schools.CDSCode\">frpm.CDSCode</column>",
        "<column purpose=\"Join: with frpm.CDSCode\">schools.CDSCode</column>",
        "<column purpose=\"Filter: 'City of San Bernardino City Unified'\">schools.City</column>",
        "<column purpose=\"Filter: 'San Bernardino county'\">schools.County</column>",
        "<column purpose=\"Filter: 'Unified Schools (DOC = 54)'\">schools.DOC</column>",
        "<column purpose=\"Filter: 'Intermediate/Middle Schools (SOC = 62)'\">schools.SOC</column>",
        "<column purpose=\"Filter: 'opened between 1/1/2009 to 12/31/2010'\">schools.OpenDate</column>",
        "<output_schema purpose=\"Email address output\">text</output_schema>",
        "<output_schema purpose=\"Email address output\">text</output_schema>",
        "<warning>Consider adding schools.AdmEmail3 to the output, as it might contain a valid email address for some administrators.</warning>",
        "<error>The frpm table is unnecessary for this query. All required information is available in the schools table.</error>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for school information--><table>schools</table>",
        "<!--Filter: 'San Bernardino county'--><column>schools.County</column>",
        "<!--Filter: 'City of San Bernardino City Unified'--><column>schools.District</column>",
        "<!--Filter: 'opened between 1/1/2009 to 12/31/2010'--><column>schools.OpenDate</column>",
        "<!--Filter: 'Intermediate/Middle Schools (SOC = 62)'--><column>schools.SOC</column>",
        "<!--Filter: 'Unified School (DOC = 54)'--><column>schools.DOC</column>",
        "<!--Output: 'valid e-mail addresses of the administrator'--><column>schools.AdmEmail1</column>",
        "<!--Output: 'valid e-mail addresses of the administrator'--><column>schools.AdmEmail2</column>",
        "<!--Output: 'valid e-mail addresses of the administrator'--><column>schools.AdmEmail3</column>",
        "<!--Valid e-mail addresses of the administrator--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 89,
      "db_id": "financial",
      "question": "How many accounts who choose issuance after transaction are staying in East Bohemia region?",
      "evidence": "A3 contains the data of region; 'POPLATEK PO OBRATU' represents for 'issuance after transaction'.",
      "SQL": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T1.A3 = 'east Bohemia' AND T2.frequency = 'POPLATEK PO OBRATU'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["district", "account"],
        "columns": [
          "account.account_id",
          "district.district_id",
          "account.district_id",
          "account.frequency",
          "district.A3"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for region information\">district</table>",
        "<table purpose=\"Required for account information\">account</table>",
        "<column purpose=\"calculate: count of accounts\">account.account_id</column>",
        "<column purpose=\"join: district.district_id\">district.district_id</column>",
        "<column purpose=\"join: account.district_id\">account.district_id</column>",
        "<column purpose=\"filter: 'issuance after transaction'\">account.frequency</column>",
        "<column purpose=\"filter: 'East Bohemia region'\">district.A3</column>",
        "<output_schema purpose=\"count of accounts\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for account information--><table>account</table>",
        "<!--Required for region information--><table>district</table>",
        "<!--Filter: 'issuance after transaction'--><column>account.frequency</column>",
        "<!--Join: account.district_id--><column>account.district_id</column>",
        "<!--Join: district.district_id--><column>district.district_id</column>",
        "<!--Filter: 'East Bohemia region'--><column>district.A3</column>",
        "<!--Count of accounts--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 92,
      "db_id": "financial",
      "question": "List out the no. of districts that have female average salary is more than 6000 but less than 10000?",
      "evidence": "A11 refers to average salary; Female mapps to gender = 'F'",
      "SQL": "SELECT COUNT(DISTINCT T2.district_id)  FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' AND T2.A11 BETWEEN 6000 AND 10000",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["client", "district"],
        "columns": [
          "district.district_id",
          "client.district_id",
          "district.A11",
          "client.gender"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for client information, including gender\">client</table>",
        "<table purpose=\"Required for district information, including average salary\">district</table>",
        "<column purpose=\"join: client.district_id, calculate: distinct count of districts\">district.district_id</column>",
        "<column purpose=\"join: district.district_id\">client.district_id</column>",
        "<column purpose=\"filter: 'average salary is more than 6000 but less than 10000'\">district.A11</column>",
        "<column purpose=\"filter: 'Female mapps to gender = 'F''\">client.gender</column>",
        "<output_schema purpose=\"count of districts meeting the criteria\">integer</output_schema>",
        "<warning>The proposal is missing the use of a COUNT or DISTINCT function to get the number of districts, as required by the question.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for district information--><table>district</table>",
        "<!--Required for client information--><table>client</table>",
        "<!--Join district and client tables--><column>district.district_id</column>",
        "<!--Join district and client tables--><column>client.district_id</column>",
        "<!--Filter for female clients--><column>client.gender</column>",
        "<!--Average salary information--><column>district.A11</column>",
        "<!--Count of districts--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 93,
      "db_id": "financial",
      "question": "How many male customers who are living in North Bohemia have average salary greater than 8000?",
      "evidence": "Male means that gender = 'M'; A3 refers to region; A11 pertains to average salary.",
      "SQL": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A3 = 'north Bohemia' AND T2.A11 > 8000",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["client", "district"],
        "columns": [
          "client.client_id",
          "client.district_id",
          "district.district_id",
          "district.A11",
          "district.A3",
          "client.gender"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains client information including gender and district\">client</table>",
        "<table purpose=\"Contains district information including region and average salary\">district</table>",
        "<column purpose=\"join: client.district_id, calculate: count of clients\">client.client_id</column>",
        "<column purpose=\"join: district.district_id\">client.district_id</column>",
        "<column purpose=\"join: client.district_id\">district.district_id</column>",
        "<column purpose=\"filter: 'average salary greater than 8000'\">district.A11</column>",
        "<column purpose=\"filter: 'living in North Bohemia'\">district.A3</column>",
        "<column purpose=\"filter: 'male customers'\">client.gender</column>",
        "<output_schema purpose=\"count of male customers in North Bohemia with average salary > 8000\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for customer information--><table>client</table>",
        "<!--Required for district information--><table>district</table>",
        "<!--Filter: 'Male means that gender = 'M''--><column>client.gender</column>",
        "<!--Join: client.district_id--><column>client.district_id</column>",
        "<!--Join: district.district_id--><column>district.district_id</column>",
        "<!--Filter: 'living in North Bohemia'--><column>district.A3</column>",
        "<!--Filter: 'average salary greater than 8000'--><column>district.A11</column>",
        "<!--Count of male customers in North Bohemia with average salary > 8000--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 94,
      "db_id": "financial",
      "question": "List out the account numbers of female clients who are oldest and has lowest average salary, calculate the gap between this lowest average salary with the highest average salary?",
      "evidence": "Female means gender = 'F'; A11 refers to average salary; Gap = highest average salary - lowest average salary; If the person A's birthdate > B's birthdate, it means that person B is order than person A.",
      "SQL": "SELECT T1.account_id , ( SELECT MAX(A11) - MIN(A11) FROM district ) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T1.account_id = T3.account_id INNER JOIN client AS T4 ON T3.client_id = T4.client_id WHERE T2.district_id = ( SELECT district_id FROM client WHERE gender = 'F' ORDER BY birth_date ASC LIMIT 1 ) ORDER BY T2.A11 DESC LIMIT 1",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["account", "district", "disp", "client"],
        "columns": [
          "client.district_id",
          "client.gender",
          "client.birth_date",
          "district.A11",
          "account.account_id",
          "account.district_id",
          "district.district_id",
          "disp.account_id",
          "disp.client_id",
          "client.client_id"
        ],
        "output_schema": ["integer", "integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for account information\">account</table>",
        "<table purpose=\"Required for salary and district information\">district</table>",
        "<table purpose=\"Required to link accounts with clients\">disp</table>",
        "<table purpose=\"Required for client gender and birth date information\">client</table>",
        "<column purpose=\"join: account.district_id, filter: oldest female client\">client.district_id</column>",
        "<column purpose=\"filter: 'Female means gender = 'F''\">client.gender</column>",
        "<column purpose=\"filter: 'oldest'\">client.birth_date</column>",
        "<column purpose=\"calculate: 'lowest average salary', 'highest average salary'\">district.A11</column>",
        "<column purpose=\"output: 'account numbers of female clients'\">account.account_id</column>",
        "<column purpose=\"join: district.district_id\">account.district_id</column>",
        "<column purpose=\"join: account.district_id, client.district_id\">district.district_id</column>",
        "<column purpose=\"join: account.account_id\">disp.account_id</column>",
        "<column purpose=\"join: client.client_id\">disp.client_id</column>",
        "<column purpose=\"join: disp.client_id\">client.client_id</column>",
        "<output_schema purpose=\"account numbers of female clients\">integer</output_schema>",
        "<output_schema purpose=\"gap between lowest and highest average salary\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for client information--><table>client</table>",
        "<!--Required for district information--><table>district</table>",
        "<!--Required for account information--><table>account</table>",
        "<!--Required for joining client and district--><column>client.district_id</column>",
        "<!--Required for joining district and client--><column>district.district_id</column>",
        "<!--Required for joining client and account--><column>client.client_id</column>",
        "<!--Required for joining account and client--><table>disp</table>",
        "<!--Required for joining account and client--><column>disp.client_id</column>",
        "<!--Required for joining account and client--><column>disp.account_id</column>",
        "<!--Required for joining account and disp--><column>account.account_id</column>",
        "<!--Filter: 'female clients'--><column>client.gender</column>",
        "<!--Filter: 'oldest'--><column>client.birth_date</column>",
        "<!--Filter: 'lowest average salary'--><column>district.A11</column>",
        "<!--Output: 'account numbers'--><column>account.account_id</column>",
        "<!--Output: 'account numbers of female clients who are oldest and has lowest average salary'--><output_schema>integer</output_schema>",
        "<!--Output: 'gap between this lowest average salary with the highest average salary'--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 95,
      "db_id": "financial",
      "question": "List out the account numbers of clients who are youngest and have highest average salary?",
      "evidence": "If the person A's birthdate < B's birthdate, it means that person B is younger than person A; A11 refers to average salary",
      "SQL": "SELECT T1.account_id  FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id INNER JOIN client AS T3 ON T2.client_id = T3.client_id INNER JOIN district AS T4 on T4.district_id = T1.district_id WHERE T2.client_id = ( SELECT client_id FROM client ORDER BY birth_date DESC LIMIT 1) GROUP BY T4.A11, T1.account_id",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["account", "disp", "district", "client"],
        "columns": [
          "client.client_id",
          "client.birth_date",
          "account.account_id",
          "disp.account_id",
          "account.district_id",
          "district.district_id",
          "disp.client_id",
          "district.A11"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for account information\">account</table>",
        "<table purpose=\"Required to link clients with accounts\">disp</table>",
        "<table purpose=\"Required for salary information\">district</table>",
        "<table purpose=\"Required for client birth date information\">client</table>",
        "<column purpose=\"join: disp.client_id, filter: youngest client\">client.client_id</column>",
        "<column purpose=\"filter: 'youngest'\">client.birth_date</column>",
        "<column purpose=\"output: 'account numbers of clients'\">account.account_id</column>",
        "<column purpose=\"join: account.account_id\">disp.account_id</column>",
        "<column purpose=\"join: district.district_id\">account.district_id</column>",
        "<column purpose=\"join: account.district_id\">district.district_id</column>",
        "<column purpose=\"join: client.client_id\">disp.client_id</column>",
        "<column purpose=\"filter: 'highest average salary'\">district.A11</column>",
        "<output_schema purpose=\"account numbers\">integer</output_schema>",
        "<warning>The proposed solution doesn't guarantee finding all accounts with the highest average salary. You might need to use a subquery or window function to identify the maximum salary.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for client information--><table>client</table>",
        "<!--Required for district information--><table>district</table>",
        "<!--Required for account information--><table>account</table>",
        "<!--Required for joining client and district--><column>client.district_id</column>",
        "<!--Required for joining client and district--><column>district.district_id</column>",
        "<!--Required for joining client and account--><column>client.client_id</column>",
        "<!--Required for joining client and account--><table>disp</table>",
        "<!--Required for joining client and account--><column>disp.client_id</column>",
        "<!--Required for joining client and account--><column>disp.account_id</column>",
        "<!--Required for joining disp and account--><column>account.account_id</column>",
        "<!--Required to find 'youngest' clients--><column>client.birth_date</column>",
        "<!--Required to find 'highest average salary'--><column>district.A11</column>",
        "<!--List out the account numbers--><column>account.account_id</column>",
        "<!--List out the account numbers--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 98,
      "db_id": "financial",
      "question": "Among the accounts who have approved loan date in 1997, list out the accounts that have the lowest approved amount and choose weekly issuance statement.",
      "evidence": "'POPLATEK TYDNE' stands for weekly issuance",
      "SQL": "SELECT T2.account_id FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T1.date) = '1997' AND T2.frequency = 'POPLATEK TYDNE' ORDER BY T1.amount LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["loan", "account"],
        "columns": [
          "account.account_id",
          "loan.account_id",
          "account.frequency",
          "loan.date",
          "loan.amount"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for loan information\">loan</table>",
        "<table purpose=\"Required for account information\">account</table>",
        "<column purpose=\"output: 'list out the accounts', join: loan.account_id\">account.account_id</column>",
        "<column purpose=\"join: account.account_id\">loan.account_id</column>",
        "<column purpose=\"filter: 'choose weekly issuance statement'\">account.frequency</column>",
        "<column purpose=\"filter: 'approved loan date in 1997'\">loan.date</column>",
        "<column purpose=\"filter: 'lowest approved amount'\">loan.amount</column>",
        "<output_schema purpose=\"account_id is an integer\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'accounts who have approved loan date in 1997'--><table>loan</table>",
        "<!--Required for 'accounts that have the lowest approved amount'--><table>loan</table>",
        "<!--Required for 'choose weekly issuance statement'--><table>account</table>",
        "<!--filter: 'approved loan date in 1997'--><column>loan.date</column>",
        "<!--calculate: 'lowest approved amount'--><column>loan.amount</column>",
        "<!--join: account.account_id--><column>loan.account_id</column>",
        "<!--join: loan.account_id--><column>account.account_id</column>",
        "<!--filter: 'weekly issuance statement'--><column>account.frequency</column>",
        "<!--list out the accounts--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 99,
      "db_id": "financial",
      "question": "Among the accounts who have loan validity more than 12 months, list out the accounts that have the highest approved amount and have account opening date in 1993.",
      "evidence": "Loan validity more than 12 months refers to duration > 12",
      "SQL": "SELECT T1.account_id FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T2.date) = '1993' AND T1.duration > 12 ORDER BY T1.amount DESC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["loan", "account"],
        "columns": [
          "loan.account_id",
          "account.account_id",
          "account.date",
          "loan.duration",
          "loan.amount"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for loan information\">loan</table>",
        "<table purpose=\"Required for account opening date\">account</table>",
        "<column purpose=\"join: account.account_id, output: 'list out the accounts'\">loan.account_id</column>",
        "<column purpose=\"join: loan.account_id\">account.account_id</column>",
        "<column purpose=\"filter: 'account opening date in 1993'\">account.date</column>",
        "<column purpose=\"filter: 'loan validity more than 12 months'\">loan.duration</column>",
        "<column purpose=\"sort: 'highest approved amount'\">loan.amount</column>",
        "<output_schema purpose=\"account ID of the result\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for loan information--><table>loan</table>",
        "<!--Required for account opening date--><table>account</table>",
        "<!--Filter: 'loan validity more than 12 months'--><column>loan.duration</column>",
        "<!--Calculate: 'highest approved amount'--><column>loan.amount</column>",
        "<!--Filter: 'account opening date in 1993'--><column>account.date</column>",
        "<!--Join: loan.account_id--><column>account.account_id</column>",
        "<!--Join: account.account_id--><column>loan.account_id</column>",
        "<!--Output: account identifiers--><output_schema>integer</output_schema>",
        "<!--Output: highest approved amount--><output_schema>integer</output_schema>",
        "<!--Output: account opening date--><output_schema>date</output_schema>"
      ]
    },
    {
      "question_id": 100,
      "db_id": "financial",
      "question": "Among the account opened, how many female customers who were born before 1950 and stayed in Sokolov?",
      "evidence": "Customers refer to clients; Female refers to gender = 'F'; Names of districts appear in column A2",
      "SQL": "SELECT COUNT(T2.client_id) FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.gender = 'F' AND STRFTIME('%Y', T2.birth_date) < '1950' AND T1.A2 = 'Sokolov'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["district", "client"],
        "columns": [
          "client.client_id",
          "district.district_id",
          "client.district_id",
          "client.gender",
          "client.birth_date",
          "district.A2"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for district information, specifically 'Sokolov'\">district</table>",
        "<table purpose=\"Required for client information, including gender and birth date\">client</table>",
        "<column purpose=\"calculate: count of clients meeting the criteria\">client.client_id</column>",
        "<column purpose=\"join: client.district_id\">district.district_id</column>",
        "<column purpose=\"join: district.district_id\">client.district_id</column>",
        "<column purpose=\"filter: 'Female refers to gender = 'F''\">client.gender</column>",
        "<column purpose=\"filter: 'born before 1950'\">client.birth_date</column>",
        "<column purpose=\"filter: 'stayed in Sokolov'\">district.A2</column>",
        "<output_schema purpose=\"count of female customers born before 1950 in Sokolov\">integer</output_schema>",
        "<warning>The question asks about \"account opened\", but the proposal doesn't include the account table. Consider including the account table and joining it with the client table through the disp table to ensure only clients with opened accounts are counted.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for account information--><table>account</table>",
        "<!--Required for client information--><table>client</table>",
        "<!--Required for district information--><table>district</table>",
        "<!--Required for linking clients to accounts--><table>disp</table>",
        "<!--Join: account.account_id--><column>disp.account_id</column>",
        "<!--Join: disp.client_id--><column>client.client_id</column>",
        "<!--Join: client.district_id--><column>district.district_id</column>",
        "<!--Filter: 'female customers'--><column>client.gender</column>",
        "<!--Filter: 'born before 1950'--><column>client.birth_date</column>",
        "<!--Filter: 'stayed in Sokolov'--><column>district.A2</column>",
        "<!--Count of customers meeting criteria--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 112,
      "db_id": "financial",
      "question": "For the female client who was born in 1976/1/29, which district did she opened her account?",
      "evidence": "Female refers to gender = 'F'; A2 refers to district names",
      "SQL": "SELECT T1.A2 FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.birth_date = '1976-01-29' AND T2.gender = 'F'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["district", "client"],
        "columns": [
          "district.A2",
          "district.district_id",
          "client.district_id",
          "client.birth_date",
          "client.gender"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for district information\">district</table>",
        "<table purpose=\"Required for client information\">client</table>",
        "<column purpose=\"output: 'which district'\">district.A2</column>",
        "<column purpose=\"join: client.district_id\">district.district_id</column>",
        "<column purpose=\"join: district.district_id\">client.district_id</column>",
        "<column purpose=\"filter: 'born in 1976/1/29'\">client.birth_date</column>",
        "<column purpose=\"filter: 'Female client'\">client.gender</column>",
        "<output_schema purpose=\"district name\">text</output_schema>",
        "<error>The question asks about the district where the client opened her account, but the proposal only includes client and district tables. The account table is missing, which is necessary to determine where the account was opened.</error>",
        "<error>The account.district_id column is missing, which is needed to link the account to the district where it was opened.</error>",
        "<error>The disp table is missing, which is needed to link the client to their account(s).</error>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for client information--><table>client</table>",
        "<!--Required for district information--><table>district</table>",
        "<!--Required for account information--><table>account</table>",
        "<!--Required for linking client to account--><table>disp</table>",
        "<!--Filter: 'female client'--><column>client.gender</column>",
        "<!--Filter: 'born in 1976/1/29'--><column>client.birth_date</column>",
        "<!--Join: client.client_id--><column>disp.client_id</column>",
        "<!--Join: disp.account_id--><column>account.account_id</column>",
        "<!--Join: account.district_id--><column>district.district_id</column>",
        "<!--Output: 'which district'--><column>district.A2</column>",
        "<!--District name--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 115,
      "db_id": "financial",
      "question": "For the branch which located in the south Bohemia with biggest number of inhabitants, what is the percentage of the male clients?",
      "evidence": "Percentage of the male clients = DIVIDE(COUNT(male clients), COUNT(clients)) * 100; Male refers to gender = 'M', A3 is the region name. A4 contains the information about inhabitants.",
      "SQL": "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A3 = 'south Bohemia' GROUP BY T2.A4 ORDER BY T2.A4 DESC LIMIT 1",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["client", "district"],
        "columns": [
          "client.gender",
          "client.client_id",
          "client.district_id",
          "district.district_id",
          "district.A3",
          "district.A4"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains client information including gender\">client</table>",
        "<table purpose=\"Contains district information including region and number of inhabitants\">district</table>",
        "<column purpose=\"filter: 'Male refers to gender = 'M''\">client.gender</column>",
        "<column purpose=\"calculate: COUNT(clients) for percentage calculation\">client.client_id</column>",
        "<column purpose=\"join: client.district_id\">client.district_id</column>",
        "<column purpose=\"join: district.district_id\">district.district_id</column>",
        "<column purpose=\"filter: 'branch which located in the south Bohemia'\">district.A3</column>",
        "<column purpose=\"filter and sort: 'branch ... with biggest number of inhabitants'\">district.A4</column>",
        "<output_schema purpose=\"percentage of male clients\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for branch location and inhabitants--><table>district</table>",
        "<!--Required for client information--><table>client</table>",
        "<!--Filter: 'in the south Bohemia'--><column>district.A3</column>",
        "<!--Find: 'biggest number of inhabitants'--><column>district.A4</column>",
        "<!--Join: client.district_id--><column>district.district_id</column>",
        "<!--Join: district.district_id--><column>client.district_id</column>",
        "<!--Filter: 'Male refers to gender = 'M''--><column>client.gender</column>",
        "<!--Calculate: 'percentage of the male clients'--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 116,
      "db_id": "financial",
      "question": "For the client whose loan was approved first in 1993/7/5, what is the increase rate of his/her account balance from 1993/3/22 to 1998/12/27?",
      "evidence": "Increase rate of his/her account balance = [(balance of date A - balance of date B) / balance of Date B] * 100%",
      "SQL": "SELECT CAST((SUM(IIF(T3.date = '1998-12-27', T3.balance, 0)) - SUM(IIF(T3.date = '1993-03-22', T3.balance, 0))) AS REAL) * 100 / SUM(IIF(T3.date = '1993-03-22', T3.balance, 0)) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T3.account_id = T2.account_id WHERE T1.date = '1993-07-05'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["loan", "account", "trans"],
        "columns": [
          "trans.date",
          "trans.balance",
          "loan.account_id",
          "account.account_id",
          "trans.account_id",
          "loan.date"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to identify the client whose loan was approved first on 1993/7/5\">loan</table>",
        "<table purpose=\"Required to link loan to account\">account</table>",
        "<table purpose=\"Required to get account balance information\">trans</table>",
        "<column purpose=\"filter: '1993/3/22 to 1998/12/27', used in calculation\">trans.date</column>",
        "<column purpose=\"calculate: 'increase rate of his/her account balance'\">trans.balance</column>",
        "<column purpose=\"join: account.account_id\">loan.account_id</column>",
        "<column purpose=\"join: loan.account_id, trans.account_id\">account.account_id</column>",
        "<column purpose=\"join: account.account_id\">trans.account_id</column>",
        "<column purpose=\"filter: 'loan was approved first in 1993/7/5'\">loan.date</column>",
        "<output_schema purpose=\"increase rate of account balance\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'client whose loan was approved first in 1993/7/5'--><table>loan</table>",
        "<!--Required for account balance information--><table>trans</table>",
        "<!--Required to link loan to account--><table>account</table>",
        "<!--Filter: 'loan was approved first in 1993/7/5'--><column>loan.date</column>",
        "<!--Join: loan.account_id--><column>account.account_id</column>",
        "<!--Join: account.account_id--><column>trans.account_id</column>",
        "<!--Filter: 'from 1993/3/22 to 1998/12/27'--><column>trans.date</column>",
        "<!--Calculate: 'increase rate of his/her account balance'--><column>trans.balance</column>",
        "<!--Increase rate of account balance--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 117,
      "db_id": "financial",
      "question": "What is the percentage of loan amount that has been fully paid with no issue.",
      "evidence": "Loan paid with no issue means contract finished, no problems; status = 'A' means contract finished, no problems; Percentage of accounts by condition = [(total(amount) & condition) / (total amount)] * 100%",
      "SQL": "SELECT (CAST(SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) AS REAL) * 100) / SUM(amount) FROM loan",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["loan"],
        "columns": ["loan.status", "loan.amount"],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for loan information and calculations\">loan</table>",
        "<column purpose=\"filter: 'Loan paid with no issue means contract finished, no problems; status = 'A' means contract finished, no problems'\">loan.status</column>",
        "<column purpose=\"calculate: 'Percentage of loan amount that has been fully paid with no issue'\">loan.amount</column>",
        "<output_schema purpose=\"Percentage calculation result\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for loan information--><table>loan</table>",
        "<!--Filter for 'contract finished, no problems'--><column>loan.status</column>",
        "<!--Calculate percentage of loan amount--><column>loan.amount</column>",
        "<!--Percentage of loan amount fully paid with no issue--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 118,
      "db_id": "financial",
      "question": "For loan amount less than USD100,000, what is the percentage of accounts that is still running with no issue.",
      "evidence": "Status = 'C' stands for running contract, ok so far; Percentage of accounts by condition = [(total(amount) & condition) / (total amount)] * 100.",
      "SQL": "SELECT CAST(SUM(status = 'C') AS REAL) * 100 / COUNT(account_id) FROM loan WHERE amount < 100000",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["loan"],
        "columns": ["loan.status", "loan.account_id", "loan.amount"],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for loan information\">loan</table>",
        "<column purpose=\"filter: 'Status = 'C' stands for running contract, ok so far'\">loan.status</column>",
        "<column purpose=\"calculate: 'Percentage of accounts'\">loan.account_id</column>",
        "<column purpose=\"filter: 'loan amount less than USD100,000'\">loan.amount</column>",
        "<output_schema purpose=\"percentage calculation result\">real</output_schema>",
        "<warning>The proposed SQL query does not match the description in the question. The question asks for a percentage based on the total amount, but the query calculates based on the count of accounts.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for loan information--><table>loan</table>",
        "<!--Filter: 'loan amount less than USD100,000'--><column>loan.amount</column>",
        "<!--Filter: 'Status = 'C' stands for running contract, ok so far'--><column>loan.status</column>",
        "<!--Calculate: 'percentage of accounts'--><column>loan.account_id</column>",
        "<!--Percentage of accounts by condition--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 125,
      "db_id": "financial",
      "question": "For loans contracts which are still running where client are in debt, list the district of the and the state the percentage unemployment rate increment from year 1995 to 1996.",
      "evidence": "Unemployment increment rate in percentage = [(unemployment rate 2016 - unemployment rate 2015) / unemployment rate 2015] * 100; unemployment rate 2015 appears in the A12; unemployment rate 2016 appears in the A13; Loan contracts which are still running where client are in debt can be presented as status = 'D'",
      "SQL": "SELECT CAST((T3.A13 - T3.A12) AS REAL) * 100 / T3.A12 FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.status = 'D'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["loan", "account", "district"],
        "columns": [
          "district.A13",
          "district.A12",
          "loan.account_id",
          "account.account_id",
          "account.district_id",
          "district.district_id",
          "loan.status"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for loan contract information\">loan</table>",
        "<table purpose=\"Required to link loans to districts\">account</table>",
        "<table purpose=\"Required for district unemployment data\">district</table>",
        "<column purpose=\"calculate: unemployment rate 1996\">district.A13</column>",
        "<column purpose=\"calculate: unemployment rate 1995\">district.A12</column>",
        "<column purpose=\"join: account.account_id\">loan.account_id</column>",
        "<column purpose=\"join: loan.account_id\">account.account_id</column>",
        "<column purpose=\"join: district.district_id\">account.district_id</column>",
        "<column purpose=\"join: account.district_id\">district.district_id</column>",
        "<column purpose=\"filter: 'client are in debt'\">loan.status</column>",
        "<output_schema purpose=\"percentage unemployment rate increment\">real</output_schema>",
        "<warning>The proposal is missing district.A2 (district name) which is needed to \"list the district\"</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for loan status--><table>loan</table>",
        "<!--Required for district information--><table>account</table>",
        "<!--Required for district details--><table>district</table>",
        "<!--Filter for running contracts with clients in debt--><column>loan.status</column>",
        "<!--Join loan with account--><column>loan.account_id</column>",
        "<!--Join account with loan--><column>account.account_id</column>",
        "<!--Join account with district--><column>account.district_id</column>",
        "<!--Join district with account--><column>district.district_id</column>",
        "<!--District name--><column>district.A2</column>",
        "<!--Unemployment rate 1995--><column>district.A12</column>",
        "<!--Unemployment rate 1996--><column>district.A13</column>",
        "<!--District name--><output_schema>text</output_schema>",
        "<!--Unemployment rate increment percentage--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 128,
      "db_id": "financial",
      "question": "List the top nine districts, by descending order, from the highest to the lowest, the number of female account holders.",
      "evidence": "A2 refers to districts; Female refers to gender = 'F'",
      "SQL": "SELECT T2.A2, COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' GROUP BY T2.district_id, T2.A2 ORDER BY COUNT(T1.client_id) DESC LIMIT 9",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["client", "district"],
        "columns": [
          "district.A2",
          "client.client_id",
          "client.district_id",
          "district.district_id",
          "client.gender"
        ],
        "output_schema": ["text", "integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for client information and gender filtering\">client</table>",
        "<table purpose=\"Required for district names and joining with client table\">district</table>",
        "<column purpose=\"Output: district name\">district.A2</column>",
        "<column purpose=\"Count: number of female account holders\">client.client_id</column>",
        "<column purpose=\"Join: client to district\">client.district_id</column>",
        "<column purpose=\"Join: district to client\">district.district_id</column>",
        "<column purpose=\"Filter: 'Female refers to gender = 'F''\">client.gender</column>",
        "<output_schema purpose=\"District name (A2)\">text</output_schema>",
        "<output_schema purpose=\"Count of female account holders\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for district information--><table>district</table>",
        "<!--Required for client information--><table>client</table>",
        "<!--Required for account information--><table>account</table>",
        "<!--Required for disposition information--><table>disp</table>",
        "<!--Join: district.district_id--><column>client.district_id</column>",
        "<!--Join: client.client_id--><column>disp.client_id</column>",
        "<!--Join: disp.account_id--><column>account.account_id</column>",
        "<!--Filter: 'Female refers to gender = 'F''--><column>client.gender</column>",
        "<!--'List the top nine districts'--><column>district.A2</column>",
        "<!--'List the top nine districts'--><column>district.district_id</column>",
        "<!--Output: district name--><output_schema>text</output_schema>",
        "<!--Output: number of female account holders--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 136,
      "db_id": "financial",
      "question": "Between 1/1/1995 and 12/31/1997, how many loans in the amount of at least 250,000 per account that chose monthly statement issuance were approved?",
      "evidence": "Frequency = 'POPLATEK MESICNE' stands for monthly issurance",
      "SQL": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.date BETWEEN '1995-01-01' AND '1997-12-31' AND T1.frequency = 'POPLATEK MESICNE' AND T2.amount >= 250000",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["account", "loan"],
        "columns": [
          "account.account_id",
          "loan.account_id",
          "loan.amount",
          "loan.date",
          "account.frequency"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for account details and frequency information\">account</table>",
        "<table purpose=\"Required for loan details\">loan</table>",
        "<column purpose=\"join: loan.account_id\">account.account_id</column>",
        "<column purpose=\"join: account.account_id\">loan.account_id</column>",
        "<column purpose=\"filter: 'loans in the amount of at least 250,000'\">loan.amount</column>",
        "<column purpose=\"filter: 'Between 1/1/1995 and 12/31/1997'\">loan.date</column>",
        "<column purpose=\"filter: 'monthly statement issuance'\">account.frequency</column>",
        "<output_schema purpose=\"count of loans meeting the criteria\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for loan information--><table>loan</table>",
        "<!--Required for account information--><table>account</table>",
        "<!--Filter: 'Between 1/1/1995 and 12/31/1997'--><column>loan.date</column>",
        "<!--Filter: 'loans in the amount of at least 250,000'--><column>loan.amount</column>",
        "<!--Join: loan.account_id--><column>loan.account_id</column>",
        "<!--Join: account.account_id--><column>account.account_id</column>",
        "<!--Filter: 'accounts that chose monthly statement issuance'--><column>account.frequency</column>",
        "<!--Count of loans meeting the criteria--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 137,
      "db_id": "financial",
      "question": "How many accounts have running contracts in Branch location 1?",
      "evidence": "Status = 'C' stands for running contract, OK so far; Status = 'D' stands for running contract, client in debt",
      "SQL": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T1.district_id = 1 AND (T3.status = 'C' OR T3.status = 'D')",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["account", "district", "loan"],
        "columns": [
          "account.account_id",
          "account.district_id",
          "district.district_id",
          "loan.account_id",
          "loan.status"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for account information and district association\">account</table>",
        "<table purpose=\"Required to filter by Branch location 1\">district</table>",
        "<table purpose=\"Required for loan status information\">loan</table>",
        "<column purpose=\"join: loan.account_id, count: 'How many accounts'\">account.account_id</column>",
        "<column purpose=\"filter: 'Branch location 1', join: district.district_id\">account.district_id</column>",
        "<column purpose=\"join: account.district_id, filter: 'Branch location 1'\">district.district_id</column>",
        "<column purpose=\"join: account.account_id\">loan.account_id</column>",
        "<column purpose=\"filter: 'running contracts'\">loan.status</column>",
        "<output_schema purpose=\"count of accounts with running contracts in Branch location 1\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'accounts' and 'running contracts'--><table>account</table>",
        "<!--Required for 'running contracts' status--><table>loan</table>",
        "<!--Join account and loan tables--><column>account.account_id</column>",
        "<!--Join account and loan tables--><column>loan.account_id</column>",
        "<!--Filter for 'Branch location 1'--><column>account.district_id</column>",
        "<!--Filter for 'running contracts'--><column>loan.status</column>",
        "<!--Count of accounts with running contracts in Branch location 1--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 138,
      "db_id": "financial",
      "question": "In the branch where the second-highest number of crimes were committed in 1995 occurred, how many male clients are there?",
      "evidence": "Male refers to gender = 'M'; A15 stands for no. of commited crimes 1995",
      "SQL": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A15 = (SELECT T3.A15 FROM district AS T3 ORDER BY T3.A15 DESC LIMIT 1, 1)",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["client", "district"],
        "columns": [
          "district.A15",
          "client.client_id",
          "client.district_id",
          "district.district_id",
          "client.gender"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for client information and gender filtering\">client</table>",
        "<table purpose=\"Required for crime statistics and district information\">district</table>",
        "<column purpose=\"filter: 'second-highest number of crimes were committed in 1995'\">district.A15</column>",
        "<column purpose=\"calculate: count of male clients\">client.client_id</column>",
        "<column purpose=\"join: client.district_id\">client.district_id</column>",
        "<column purpose=\"join: district.district_id\">district.district_id</column>",
        "<column purpose=\"filter: 'Male refers to gender = 'M''\">client.gender</column>",
        "<output_schema purpose=\"count of male clients\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for crime statistics in 1995--><table>district</table>",
        "<!--Required for client information--><table>client</table>",
        "<!--Number of crimes in 1995--><column>district.A15</column>",
        "<!--Link client to district--><column>client.district_id</column>",
        "<!--Link district to client--><column>district.district_id</column>",
        "<!--Filter for male clients--><column>client.gender</column>",
        "<!--Count of male clients--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 129,
      "db_id": "financial",
      "question": "Which are the top ten withdrawals (non-credit card) by district names for the month of January 1996?",
      "evidence": "Non-credit card withdraws refers to type = 'VYDAJ'; January 1996 can be found by date LIKE '1996-01%' in the database; A2 means district names",
      "SQL": "SELECT DISTINCT T1.A2 FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T3.type = 'VYDAJ' AND T3.date LIKE '1996-01%' ORDER BY A2 ASC LIMIT 10",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["district", "account", "trans"],
        "columns": [
          "district.A2",
          "district.district_id",
          "account.district_id",
          "account.account_id",
          "trans.account_id",
          "trans.date",
          "trans.type"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for district names\">district</table>",
        "<table purpose=\"Required to link districts with transactions\">account</table>",
        "<table purpose=\"Required for withdrawal information\">trans</table>",
        "<column purpose=\"filter: 'district names'\">district.A2</column>",
        "<column purpose=\"join: account.district_id\">district.district_id</column>",
        "<column purpose=\"join: district.district_id\">account.district_id</column>",
        "<column purpose=\"join: trans.account_id\">account.account_id</column>",
        "<column purpose=\"join: account.account_id\">trans.account_id</column>",
        "<column purpose=\"filter: 'for the month of January 1996'\">trans.date</column>",
        "<column purpose=\"filter: 'Non-credit card withdraws refers to type = 'VYDAJ''\">trans.type</column>",
        "<output_schema purpose=\"district names\">text</output_schema>",
        "<error>trans.amount is missing, which is needed to determine the 'top ten withdrawals'</error>",
        "<warning>The proposal doesn't include a way to aggregate or rank the withdrawals by district, which is necessary to determine the 'top ten'</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for transaction details--><table>trans</table>",
        "<!--Required for district information--><table>district</table>",
        "<!--Required for linking transactions to districts--><table>account</table>",
        "<!--Filter: 'for the month of January 1996'--><column>trans.date</column>",
        "<!--Filter: 'withdrawals (non-credit card)'--><column>trans.type</column>",
        "<!--Filter: 'withdrawals (non-credit card)'--><column>trans.operation</column>",
        "<!--Calculate: 'top ten withdrawals'--><column>trans.amount</column>",
        "<!--Join: trans to account--><column>trans.account_id</column>",
        "<!--Join: account to trans--><column>account.account_id</column>",
        "<!--Join: account to district--><column>account.district_id</column>",
        "<!--Join: district to account--><column>district.district_id</column>",
        "<!--Output: 'district names'--><column>district.A2</column>",
        "<!--district names--><output_schema>text</output_schema>",
        "<!--withdrawal amount--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 137,
      "db_id": "financial",
      "question": "How many accounts have running contracts in Branch location 1?",
      "evidence": "Status = 'C' stands for running contract, OK so far; Status = 'D' stands for running contract, client in debt",
      "SQL": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T1.district_id = 1 AND (T3.status = 'C' OR T3.status = 'D')",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["account", "district", "loan"],
        "columns": [
          "account.account_id",
          "account.district_id",
          "district.district_id",
          "loan.account_id",
          "loan.status"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for account information and district association\">account</table>",
        "<table purpose=\"Required to filter by Branch location 1\">district</table>",
        "<table purpose=\"Required for loan status information\">loan</table>",
        "<column purpose=\"join: loan.account_id, count: 'How many accounts'\">account.account_id</column>",
        "<column purpose=\"filter: 'Branch location 1', join: district.district_id\">account.district_id</column>",
        "<column purpose=\"join: account.district_id, filter: 'Branch location 1'\">district.district_id</column>",
        "<column purpose=\"join: account.account_id\">loan.account_id</column>",
        "<column purpose=\"filter: 'running contracts'\">loan.status</column>",
        "<output_schema purpose=\"count of accounts with running contracts in Branch location 1\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'accounts' and 'running contracts'--><table>account</table>",
        "<!--Required for 'running contracts' status--><table>loan</table>",
        "<!--Join account and loan tables--><column>account.account_id</column>",
        "<!--Join account and loan tables--><column>loan.account_id</column>",
        "<!--Filter for 'Branch location 1'--><column>account.district_id</column>",
        "<!--Filter for 'running contracts'--><column>loan.status</column>",
        "<!--Count of accounts with running contracts in Branch location 1--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 138,
      "db_id": "financial",
      "question": "In the branch where the second-highest number of crimes were committed in 1995 occurred, how many male clients are there?",
      "evidence": "Male refers to gender = 'M'; A15 stands for no. of commited crimes 1995",
      "SQL": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A15 = (SELECT T3.A15 FROM district AS T3 ORDER BY T3.A15 DESC LIMIT 1, 1)",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["client", "district"],
        "columns": [
          "district.A15",
          "client.client_id",
          "client.district_id",
          "district.district_id",
          "client.gender"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for client information and gender filtering\">client</table>",
        "<table purpose=\"Required for crime statistics and district information\">district</table>",
        "<column purpose=\"filter: 'second-highest number of crimes were committed in 1995'\">district.A15</column>",
        "<column purpose=\"calculate: count of male clients\">client.client_id</column>",
        "<column purpose=\"join: client.district_id\">client.district_id</column>",
        "<column purpose=\"join: district.district_id\">district.district_id</column>",
        "<column purpose=\"filter: 'Male refers to gender = 'M''\">client.gender</column>",
        "<output_schema purpose=\"count of male clients\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for crime statistics--><table>district</table>",
        "<!--Required for client information--><table>client</table>",
        "<!--Number of crimes in 1995--><column>district.A15</column>",
        "<!--District identifier for joining--><column>district.district_id</column>",
        "<!--Client's district for joining--><column>client.district_id</column>",
        "<!--Filter for male clients--><column>client.gender</column>",
        "<!--Count of male clients--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 145,
      "db_id": "financial",
      "question": "Who are the account holder identification numbers whose who have transactions on the credit card with the amount is less than the average, in 1998?",
      "evidence": "Operation = 'VYBER KARTOU' refers to credit card withdrawal",
      "SQL": "SELECT T1.account_id FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T1.date) = '1998' AND T1.operation = 'VYBER KARTOU' AND T1.amount < (SELECT AVG(amount) FROM trans WHERE STRFTIME('%Y', date) = '1998')",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["trans", "account"],
        "columns": [
          "trans.amount",
          "trans.date",
          "trans.account_id",
          "account.account_id",
          "trans.operation"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains transaction data including amounts, dates, and operation types\">trans</table>",
        "<table purpose=\"Contains account information to link transactions to account holders\">account</table>",
        "<column purpose=\"filter: 'amount is less than the average', calculate: average amount\">trans.amount</column>",
        "<column purpose=\"filter: 'in 1998'\">trans.date</column>",
        "<column purpose=\"join: account.account_id, output: 'account holder identification numbers'\">trans.account_id</column>",
        "<column purpose=\"join: trans.account_id\">account.account_id</column>",
        "<column purpose=\"filter: 'Operation = 'VYBER KARTOU' refers to credit card withdrawal'\">trans.operation</column>",
        "<output_schema purpose=\"account holder identification numbers\">integer</output_schema>",
        "<warning>The proposal is missing a GROUP BY clause or DISTINCT keyword to ensure unique account holder identification numbers are returned.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for account holders--><table>disp</table>",
        "<!--Required for transactions--><table>trans</table>",
        "<!--Required for credit card information--><table>card</table>",
        "<!--Join disp and trans--><column>disp.account_id</column>",
        "<!--Join disp and trans--><column>trans.account_id</column>",
        "<!--Join disp and card--><column>disp.disp_id</column>",
        "<!--Join disp and card--><column>card.disp_id</column>",
        "<!--Filter for credit card transactions--><column>trans.operation</column>",
        "<!--Filter for transactions in 1998--><column>trans.date</column>",
        "<!--Calculate average and compare amounts--><column>trans.amount</column>",
        "<!--Filter for account owners--><column>disp.type</column>",
        "<!--Output: account holder identification numbers--><column>disp.client_id</column>",
        "<!--Account holder identification numbers--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 149,
      "db_id": "financial",
      "question": "Please list the account types that are not eligible for loans, and the average income of residents in the district where the account is located exceeds $8000 but is no more than $9000.",
      "evidence": "A11 represents the average salary; Salary and income share the similar meanings; when the account type = 'OWNER', it's eligible for loans",
      "SQL": "SELECT T3.type FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T2.account_id = T3.account_id WHERE T3.type != 'OWNER' AND T1.A11 BETWEEN 8000 AND 9000",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["district", "account", "disp"],
        "columns": [
          "disp.type",
          "district.district_id",
          "account.district_id",
          "account.account_id",
          "disp.account_id",
          "district.A11"
        ],
        "output_schema": ["text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for average income information\">district</table>",
        "<table purpose=\"Required to link districts with accounts\">account</table>",
        "<table purpose=\"Required for account type information\">disp</table>",
        "<column purpose=\"filter: 'account types that are not eligible for loans'\">disp.type</column>",
        "<column purpose=\"join: account.district_id\">district.district_id</column>",
        "<column purpose=\"join: district.district_id\">account.district_id</column>",
        "<column purpose=\"join: disp.account_id\">account.account_id</column>",
        "<column purpose=\"join: account.account_id\">disp.account_id</column>",
        "<column purpose=\"filter: 'average income of residents in the district ... exceeds $8000 but is no more than $9000'\">district.A11</column>",
        "<output_schema purpose=\"account types that are not eligible for loans\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for account types and loan eligibility--><table>disp</table>",
        "<!--Required for district information--><table>account</table>",
        "<!--Required for average income information--><table>district</table>",
        "<!--Filter: account types not eligible for loans--><column>disp.type</column>",
        "<!--Join: disp.account_id--><column>account.account_id</column>",
        "<!--Join: account.district_id--><column>district.district_id</column>",
        "<!--Filter: average income between $8000 and $9000--><column>district.A11</column>",
        "<!--Output: account types not eligible for loans--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 152,
      "db_id": "financial",
      "question": "What is the average number of crimes committed in 1995 in regions where the number exceeds 4000 and the region has accounts that are opened starting from the year 1997?",
      "evidence": "A3 refers to region names; A15 stands for the average number of crimes commited in 1995.",
      "SQL": "SELECT AVG(T1.A15) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) >= '1997' AND T1.A15 > 4000",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["district", "account"],
        "columns": [
          "district.A15",
          "district.district_id",
          "account.district_id",
          "account.date"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Contains crime statistics and region information\">district</table>",
        "<table purpose=\"Contains account opening dates\">account</table>",
        "<column purpose=\"calculate: 'average number of crimes committed in 1995', filter: 'number exceeds 4000'\">district.A15</column>",
        "<column purpose=\"join: account.district_id\">district.district_id</column>",
        "<column purpose=\"join: district.district_id\">account.district_id</column>",
        "<column purpose=\"filter: 'accounts that are opened starting from the year 1997'\">account.date</column>",
        "<output_schema purpose=\"average number of crimes\">real</output_schema>",
        "<warning>The question mentions A3 (region names), but it's not included in the proposal. It might be useful for additional context or verification.</warning>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for 'average number of crimes committed in 1995'--><table>district</table>",
        "<!--Required for 'accounts that are opened starting from the year 1997'--><table>account</table>",
        "<!--Required for joining district and account tables--><column>district.district_id</column>",
        "<!--Required for joining district and account tables--><column>account.district_id</column>",
        "<!--Filter: 'regions where the number exceeds 4000'--><column>district.A15</column>",
        "<!--Filter: 'accounts that are opened starting from the year 1997'--><column>account.date</column>",
        "<!--Group by: 'regions'--><column>district.A3</column>",
        "<!--Calculate: 'average number of crimes committed in 1995'--><column>district.A15</column>",
        "<!--Average number of crimes committed in 1995--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 159,
      "db_id": "financial",
      "question": "List all the withdrawals in cash transactions that the client with the id 3356 makes.",
      "evidence": "operation = 'VYBER' refers to withdrawal in cash",
      "SQL": "SELECT T4.trans_id FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id INNER JOIN trans AS T4 ON T3.account_id = T4.account_id WHERE T1.client_id = 3356 AND T4.operation = 'VYBER'",
      "difficulty": "simple",
      "sql_refs": {
        "tables": ["client", "disp", "account", "trans"],
        "columns": [
          "trans.trans_id",
          "client.client_id",
          "disp.client_id",
          "disp.account_id",
          "account.account_id",
          "trans.account_id",
          "trans.operation"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required to identify the client\">client</table>",
        "<table purpose=\"Required to link client to account\">disp</table>",
        "<table purpose=\"Required to link disposition to account\">account</table>",
        "<table purpose=\"Required for transaction details\">trans</table>",
        "<column purpose=\"output: 'List all the withdrawals'\">trans.trans_id</column>",
        "<column purpose=\"filter: 'client with the id 3356'\">client.client_id</column>",
        "<column purpose=\"join: client.client_id\">disp.client_id</column>",
        "<column purpose=\"join: account.account_id\">disp.account_id</column>",
        "<column purpose=\"join: disp.account_id\">account.account_id</column>",
        "<column purpose=\"join: account.account_id\">trans.account_id</column>",
        "<column purpose=\"filter: 'withdrawals in cash transactions'\">trans.operation</column>",
        "<output_schema purpose=\"transaction ID for withdrawals\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for client information--><table>client</table>",
        "<!--Required for account-client relationship--><table>disp</table>",
        "<!--Required for transaction details--><table>trans</table>",
        "<!--Filter: 'client with the id 3356'--><column>client.client_id</column>",
        "<!--Join: client.client_id--><column>disp.client_id</column>",
        "<!--Join: disp.account_id--><column>trans.account_id</column>",
        "<!--Filter: \"operation = 'VYBER'\"--><column>trans.operation</column>",
        "<!--Transaction date--><column>trans.date</column>",
        "<!--Transaction amount--><column>trans.amount</column>",
        "<!--Transaction balance--><column>trans.balance</column>",
        "<!--Output: transaction date--><output_schema>date</output_schema>",
        "<!--Output: transaction amount--><output_schema>integer</output_schema>",
        "<!--Output: balance after transaction--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 168,
      "db_id": "financial",
      "question": "What percentage of clients who opened their accounts in the district with an average salary of over 10000 are women?",
      "evidence": "Female refers to gender = 'F'; Woman and female are closed; Average salary can be found in A11",
      "SQL": "SELECT CAST(SUM(T2.gender = 'F') AS REAL) * 100 / COUNT(T2.client_id) FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T1.A11 > 10000",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["district", "client"],
        "columns": [
          "client.gender",
          "client.client_id",
          "district.district_id",
          "client.district_id",
          "district.A11"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for 'average salary of over 10000'\">district</table>",
        "<table purpose=\"Required for client information and gender\">client</table>",
        "<column purpose=\"filter: 'women', calculate: percentage of women\">client.gender</column>",
        "<column purpose=\"count: total number of clients\">client.client_id</column>",
        "<column purpose=\"join: district.district_id\">district.district_id</column>",
        "<column purpose=\"join: client.district_id\">client.district_id</column>",
        "<column purpose=\"filter: 'average salary of over 10000'\">district.A11</column>",
        "<output_schema purpose=\"percentage of women clients\">real</output_schema>",
        "<error>The question asks about clients who opened their accounts in the district, but the proposal doesn't include the account table or its creation date.</error>",
        "<error>The account table and its district_id column should be included to properly link clients to the districts where they opened their accounts.</error>",
        "<error>The account.date column should be included to determine when accounts were opened.</error>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for client information--><table>client</table>",
        "<!--Required for account information--><table>account</table>",
        "<!--Required for district information--><table>district</table>",
        "<!--Join client and account tables--><column>client.district_id</column>",
        "<!--Join client and account tables--><column>account.district_id</column>",
        "<!--Filter: 'average salary of over 10000'--><column>district.A11</column>",
        "<!--Join district and account tables--><column>district.district_id</column>",
        "<!--Filter: 'Female refers to gender = 'F''--><column>client.gender</column>",
        "<!--Calculate percentage of women--><column>client.gender</column>",
        "<!--Percentage of clients who are women--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 169,
      "db_id": "financial",
      "question": "What was the growth rate of the total amount of loans across all accounts for a male client between 1996 and 1997?",
      "evidence": "Growth rate = (sum of amount_1997 - sum of amount_1996) / (sum of amount_1996) * 100%; Male refers to gender = 'M'",
      "SQL": "SELECT CAST((SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1997' THEN T1.amount ELSE 0 END) - SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END)) AS REAL) * 100 / SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T3 ON T3.account_id = T2.account_id INNER JOIN client AS T4 ON T4.client_id = T3.client_id WHERE T4.gender = 'M' AND T3.type = 'OWNER'",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["loan", "account", "disp", "client"],
        "columns": [
          "loan.date",
          "loan.amount",
          "loan.account_id",
          "account.account_id",
          "disp.account_id",
          "disp.type",
          "disp.client_id",
          "client.client_id",
          "client.gender"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for loan information\">loan</table>",
        "<table purpose=\"Required to link loans to accounts\">account</table>",
        "<table purpose=\"Required to link accounts to clients\">disp</table>",
        "<table purpose=\"Required for client gender information\">client</table>",
        "<column purpose=\"filter: '1996 and 1997', calculate: growth rate\">loan.date</column>",
        "<column purpose=\"calculate: 'total amount of loans'\">loan.amount</column>",
        "<column purpose=\"join: account.account_id\">loan.account_id</column>",
        "<column purpose=\"join: loan.account_id, disp.account_id\">account.account_id</column>",
        "<column purpose=\"join: account.account_id\">disp.account_id</column>",
        "<column purpose=\"filter: 'OWNER' to ensure only account owners are considered\">disp.type</column>",
        "<column purpose=\"join: client.client_id\">disp.client_id</column>",
        "<column purpose=\"join: disp.client_id\">client.client_id</column>",
        "<column purpose=\"filter: 'Male refers to gender = 'M''\">client.gender</column>",
        "<output_schema purpose=\"growth rate as a percentage\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for loan information--><table>loan</table>",
        "<!--Required for client gender--><table>client</table>",
        "<!--Required to link clients to accounts--><table>disp</table>",
        "<!--Filter loans by year--><column>loan.date</column>",
        "<!--Calculate total loan amount--><column>loan.amount</column>",
        "<!--Filter for male clients--><column>client.gender</column>",
        "<!--Link client to disposition--><column>client.client_id</column>",
        "<!--Link disposition to client--><column>disp.client_id</column>",
        "<!--Link disposition to account--><column>disp.account_id</column>",
        "<!--Link loan to account--><column>loan.account_id</column>",
        "<!--Growth rate of total loan amount--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 173,
      "db_id": "financial",
      "question": "How often does account number 3 request an account statement to be released? What was the aim of debiting 3539 in total?",
      "evidence": "k_symbol refers to the purpose of payments",
      "SQL": "SELECT T1.frequency, T2.k_symbol FROM account AS T1 INNER JOIN (SELECT account_id, k_symbol, SUM(amount) AS total_amount FROM \"order\" GROUP BY account_id, k_symbol) AS T2 ON T1.account_id = T2.account_id WHERE T1.account_id = 3 AND T2.total_amount = 3539",
      "difficulty": "challenging",
      "sql_refs": {
        "tables": ["account", "order"],
        "columns": [
          "order.account_id",
          "order.k_symbol",
          "order.amount",
          "account.frequency",
          "account.account_id"
        ],
        "output_schema": ["text", "text"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for account frequency information\">account</table>",
        "<table purpose=\"Required for order details and payment purpose\">order</table>",
        "<column purpose=\"join: account.account_id, filter: 'account number 3'\">order.account_id</column>",
        "<column purpose=\"output: 'aim of debiting', 'k_symbol refers to the purpose of payments'\">order.k_symbol</column>",
        "<column purpose=\"calculate: 'debiting 3539 in total'\">order.amount</column>",
        "<column purpose=\"output: 'How often does account number 3 request an account statement to be released?'\">account.frequency</column>",
        "<column purpose=\"join: order.account_id, filter: 'account number 3'\">account.account_id</column>",
        "<output_schema purpose=\"account statement frequency\">text</output_schema>",
        "<output_schema purpose=\"purpose of payment (k_symbol)\">text</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for account frequency--><table>account</table>",
        "<!--Required for account statement and debit purpose--><table>trans</table>",
        "<!--Required for account number 3--><column>account.account_id</column>",
        "<!--Required for account frequency--><column>account.frequency</column>",
        "<!--Required for account number 3 and joining with account table--><column>trans.account_id</column>",
        "<!--Required for identifying statement requests--><column>trans.k_symbol</column>",
        "<!--Required for identifying debit transactions--><column>trans.type</column>",
        "<!--Required for calculating total debit amount--><column>trans.amount</column>",
        "<!--Account statement frequency--><output_schema>text</output_schema>",
        "<!--Purpose of debiting 3539 in total--><output_schema>text</output_schema>"
      ]
    },
    {
      "question_id": 186,
      "db_id": "financial",
      "question": "What percentage of male clients request for weekly statements to be issued?",
      "evidence": "Percentage of male clients = [count(male clients who requested weekly statements / count(clients who requested weekly statements)] * 100%; Male means gender = 'M'; 'POPLATEK TYDNE' stands for weekly issuance",
      "SQL": "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T3 ON T1.district_id = T3.district_id INNER JOIN account AS T2 ON T2.district_id = T3.district_id INNER JOIN disp as T4 on T1.client_id = T4.client_id AND T2.account_id = T4.account_id WHERE T2.frequency = 'POPLATEK TYDNE'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["client", "district", "account", "disp"],
        "columns": [
          "client.gender",
          "client.client_id",
          "client.district_id",
          "district.district_id",
          "account.district_id",
          "account.frequency",
          "disp.client_id",
          "account.account_id",
          "disp.account_id"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for client information, including gender\">client</table>",
        "<table purpose=\"Required for joining client and account information\">district</table>",
        "<table purpose=\"Required for account frequency information\">account</table>",
        "<table purpose=\"Required for linking clients to accounts\">disp</table>",
        "<column purpose=\"filter: 'Male means gender = 'M''\">client.gender</column>",
        "<column purpose=\"calculate: count of clients\">client.client_id</column>",
        "<column purpose=\"join: client.district_id = district.district_id\">client.district_id</column>",
        "<column purpose=\"join: client.district_id = district.district_id, district.district_id = account.district_id\">district.district_id</column>",
        "<column purpose=\"join: district.district_id = account.district_id\">account.district_id</column>",
        "<column purpose=\"filter: ''POPLATEK TYDNE' stands for weekly issuance'\">account.frequency</column>",
        "<column purpose=\"join: client.client_id = disp.client_id\">disp.client_id</column>",
        "<column purpose=\"join: account.account_id = disp.account_id\">account.account_id</column>",
        "<column purpose=\"join: account.account_id = disp.account_id\">disp.account_id</column>",
        "<output_schema purpose=\"percentage of male clients\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for client gender information--><table>client</table>",
        "<!--Required for account frequency information--><table>account</table>",
        "<!--Required to link clients to accounts--><table>disp</table>",
        "<!--Filter for male clients--><column>client.gender</column>",
        "<!--Filter for weekly statements--><column>account.frequency</column>",
        "<!--Join client to disp--><column>client.client_id</column>",
        "<!--Join disp to client--><column>disp.client_id</column>",
        "<!--Join disp to account--><column>disp.account_id</column>",
        "<!--Join account to disp--><column>account.account_id</column>",
        "<!--Percentage of male clients--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 189,
      "db_id": "financial",
      "question": "Name the account numbers of female clients who are oldest and have lowest average salary?",
      "evidence": "Female refers to 'F' in the gender; A11 contains information about average salary",
      "SQL": "SELECT T3.account_id FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN account AS T3 ON T2.district_id = T3.district_id INNER JOIN disp AS T4 ON T1.client_id = T4.client_id AND T4.account_id = T3.account_id  WHERE T1.gender = 'F' ORDER BY T1.birth_date ASC, T2.A11 ASC LIMIT 1",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["client", "district", "account", "disp"],
        "columns": [
          "account.account_id",
          "client.district_id",
          "district.district_id",
          "account.district_id",
          "client.client_id",
          "disp.client_id",
          "disp.account_id",
          "client.gender",
          "client.birth_date",
          "district.A11"
        ],
        "output_schema": ["integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for client information\">client</table>",
        "<table purpose=\"Required for salary information\">district</table>",
        "<table purpose=\"Required for account information\">account</table>",
        "<table purpose=\"Required to link clients to accounts\">disp</table>",
        "<column purpose=\"output: 'Name the account numbers'\">account.account_id</column>",
        "<column purpose=\"join: district.district_id\">client.district_id</column>",
        "<column purpose=\"join: client.district_id, account.district_id\">district.district_id</column>",
        "<column purpose=\"join: district.district_id\">account.district_id</column>",
        "<column purpose=\"join: disp.client_id\">client.client_id</column>",
        "<column purpose=\"join: client.client_id\">disp.client_id</column>",
        "<column purpose=\"join: account.account_id\">disp.account_id</column>",
        "<column purpose=\"filter: 'Female refers to 'F' in the gender'\">client.gender</column>",
        "<column purpose=\"filter: 'clients who are oldest'\">client.birth_date</column>",
        "<column purpose=\"filter: 'have lowest average salary'\">district.A11</column>",
        "<output_schema purpose=\"account numbers\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for client information--><table>client</table>",
        "<!--Required for district information--><table>district</table>",
        "<!--Required for account information--><table>disp</table>",
        "<!--Required for account information--><table>account</table>",
        "<!--Filter: 'female clients'--><column>client.gender</column>",
        "<!--Determine: 'oldest'--><column>client.birth_date</column>",
        "<!--Join: client.district_id--><column>district.district_id</column>",
        "<!--Determine: 'lowest average salary'--><column>district.A11</column>",
        "<!--Join: client.client_id--><column>disp.client_id</column>",
        "<!--Join: disp.account_id--><column>account.account_id</column>",
        "<!--Output: 'account numbers'--><output_schema>integer</output_schema>"
      ]
    },
    {
      "question_id": 192,
      "db_id": "financial",
      "question": "What is the average amount of loan which are still on running contract with statement issuance after each transaction?",
      "evidence": "status = 'C' stands for running contract, OK so far; status = 'D' stands for running contract, client in debt. 'POPLATEK PO OBRATU' stands for issuance after transaction",
      "SQL": "SELECT AVG(T2.amount) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.status IN ('C', 'D') AND T1.frequency = 'POPLATEK PO OBRATU'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["account", "loan"],
        "columns": [
          "loan.amount",
          "account.account_id",
          "loan.account_id",
          "loan.status",
          "account.frequency"
        ],
        "output_schema": ["real"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"Required for account details and frequency information\">account</table>",
        "<table purpose=\"Required for loan details including amount and status\">loan</table>",
        "<column purpose=\"calculate: 'average amount of loan'\">loan.amount</column>",
        "<column purpose=\"join: loan.account_id\">account.account_id</column>",
        "<column purpose=\"join: account.account_id\">loan.account_id</column>",
        "<column purpose=\"filter: 'running contract' (status 'C' or 'D')\">loan.status</column>",
        "<column purpose=\"filter: 'issuance after each transaction'\">account.frequency</column>",
        "<output_schema purpose=\"average amount of loan\">real</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for loan information--><table>loan</table>",
        "<!--Required for account information--><table>account</table>",
        "<!--Filter: 'running contract'--><column>loan.status</column>",
        "<!--Calculate: 'average amount of loan'--><column>loan.amount</column>",
        "<!--Join: loan.account_id--><column>account.account_id</column>",
        "<!--Filter: 'issuance after each transaction'--><column>account.frequency</column>",
        "<!--Average amount of loan for running contracts with statement issuance after each transaction--><output_schema>real</output_schema>"
      ]
    },
    {
      "question_id": 194,
      "db_id": "financial",
      "question": "Provide the IDs and age of the client with high level credit card, which is eligible for loans.",
      "evidence": "the credit card is high-level refers to card.type = 'gold'; eligible for loans refers to disp.type = 'OWNER'",
      "SQL": "SELECT T1.client_id, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T3.birth_date) FROM disp AS T1 INNER JOIN card AS T2 ON T2.disp_id = T1.disp_id INNER JOIN client AS T3 ON T1.client_id = T3.client_id WHERE T2.type = 'gold' AND T1.type = 'OWNER'",
      "difficulty": "moderate",
      "sql_refs": {
        "tables": ["disp", "card", "client"],
        "columns": [
          "disp.client_id",
          "client.birth_date",
          "disp.disp_id",
          "card.disp_id",
          "card.type",
          "client.client_id",
          "disp.type"
        ],
        "output_schema": ["integer", "integer"]
      },
      "sql_refs_annotated": [
        "<table purpose=\"contains disposition information linking clients to accounts\">disp</table>",
        "<table purpose=\"contains credit card information\">card</table>",
        "<table purpose=\"contains client information including birth date\">client</table>",
        "<column purpose=\"join: client, output: client ID\">disp.client_id</column>",
        "<column purpose=\"calculate: age of client\">client.birth_date</column>",
        "<column purpose=\"join: card\">disp.disp_id</column>",
        "<column purpose=\"join: disp\">card.disp_id</column>",
        "<column purpose=\"filter: 'high level credit card' (gold)\">card.type</column>",
        "<column purpose=\"join: disp\">client.client_id</column>",
        "<column purpose=\"filter: 'eligible for loans' (OWNER)\">disp.type</column>",
        "<output_schema purpose=\"client ID\">integer</output_schema>",
        "<output_schema purpose=\"age of client\">integer</output_schema>"
      ],
      "sql_refs_cold_annotated": [
        "<!--Required for client information--><table>client</table>",
        "<!--Required for credit card information--><table>card</table>",
        "<!--Required for account disposition information--><table>disp</table>",
        "<!--Client ID for output--><column>client.client_id</column>",
        "<!--Calculate age from birth date--><column>client.birth_date</column>",
        "<!--Filter for 'gold' card type--><column>card.type</column>",
        "<!--Join client and card tables--><column>card.disp_id</column>",
        "<!--Join card and disp tables--><column>disp.disp_id</column>",
        "<!--Filter for 'OWNER' disposition type--><column>disp.type</column>",
        "<!--Join disp and client tables--><column>disp.client_id</column>",
        "<!--Join disp and client tables--><column>client.client_id</column>",
        "<!--Client ID for output--><output_schema>integer</output_schema>",
        "<!--Age of client for output--><output_schema>integer</output_schema>"
      ]
    }
  ]
  